{
  "DocGen/Documentation/Concepts.html": {
    "href": "DocGen/Documentation/Concepts.html",
    "title": "World Locking Tools concepts | World Locking Tools for Unity Documentation",
    "keywords": "World Locking Tools concepts The problem In the day-to-day physical world, space is well described by a stationary coordinate system. A motionless object in a stationary coordinate system will continue having the same coordinates forever. A group of objects laid out in a specific configuration will maintain that configuration. Two objects moving with identical velocities will remain at a fixed offset from each other. These and similar laws are such a basic part of existence that when they no longer hold, intuition about the world becomes unreliable. Previous solutions Unity's global coordinate space and spatial anchors each address different aspects of the problems caused by sensor inaccuracies and drift. Unity's global coordinate space provides a stable frame of reference in which holographic objects remain fixed relative to one another. While objects in this space will behave consistently relative to each other, consistency with the physical world is not guaranteed nor generally provided. Inconsistencies will develop especially when the user is moving around. Unity's spatial anchors can maintain a hologram's position in the physical world when the user is mobile, but at the sacrifice of self-consistency within the virtual world. Different anchors are constantly moving relative to one another. They are also moving through the global coordinate space, making simple tasks like layout difficult, and physics simulation problematic. The source of the problem Discussion here will center around HoloLens technology, but these concepts apply generally to inside-out markerless tracking techniques, especially as augmented by inertial systems. The HoloLens is amazing at determining where it is relative to visible features in its surroundings. By extension, it's also amazing at positioning other virtual objects based on those same visible features. When the user is sitting or standing in a roughly constant position, the device is great at keeping virtual objects registered with visible physical reference points. A virtual cup placed on a physical table will mostly stay in the same spot on the surface of the table. That's when the HoloLens is confined to the same small volume, with a constant set of visible features in view for reference. But there are other interesting scenarios. When the user gets up and moves about the room, or possibly even between rooms, the HoloLens must switch between old features that are leaving view and new features that are coming into view. Without getting into implementation details, it's clear to see that while in transit, tracking accuracy is going to be very much degraded. Here's a simplistic scenario for context. Illustration The user is at point A. Looking around, there are many good visible reference features, so the head tracking quality is excellent, and any holograms placed will stay put. The user then walks 10 meters in physical space to point B. But tracking in transit has lower fidelity, so as a result, after the user reaches point B, the device registers that it has traveled only 9 meters. This is a large even amount for illustration, but it's consistent with the device specifications, which allow a +-10% distance error in such a case. As the device looks around at point B, good visible features are recorded. Tracking and stability of holograms at point B is excellent, too. While the user is at a particular point, things around that point look great. But there's an inconsistency. The 10 meters between points A and B in physical space are only 9 meters in virtual space. That's often referred to as \"the scale problem\", although \"the distance problem\" might be more accurate. We'll look into that problem soon. Back to our scenario: for the next action, the user walks back to point A. This time the tracking errors make the 10-meter walk from B to A in physical space add up to 10.5 meters in virtual space. That means that the full walk from A to B to A adds up to a net distance of 1.5 meters, when it should be 0.0 meters. This is an obvious problem. A hologram placed at point A before the walk will now appear 1.5 meters away from point A. This is where spatial anchors can help. After walking to B and back, the system recognizes that it's back at point A, yet the head's Unity coordinates have changed by 1.5 meters. But if the hologram at point A has a spatial anchor attached, the spatial anchor can think \"I'm at point A, the head is at point A, but my coordinates differ from the head's coordinates by 1.5 meters. I'll just change my coordinates by 1.5 meters so that we're in agreement again.\" And a spatial anchor at point C, a meter to the left of the user, is going through the same process. In essence, the spatial anchor constantly redefines where point A is in Unity space so that the head's coordinates are always right. And each spatial anchor does this adjustment independently for its place in the physical world. World Locking Tools for Unity World Locking Tools keeps an internal supply of spatial anchors it spreads as the user moves around. It analyses the coordinates of the camera and those spatial anchors every frame. It detects when all of those spatial anchors are moving over 1.5 meters to match the coordinates of the head, and says \"Hmm, instead of changing the coordinates of everything in the world to compensate for the head having different coordinates than the last time it was here, I'll just fix the head's coordinates instead.\" That means that, rather than having to have a spatial anchor drag a hologram through Unity space so that it will remain fixed in physical space, the entire Unity world space is locked to physical space. If a hologram is motionless in Unity space, it will remain motionless relative to the physical world features around it. And just as importantly, it will remain fixed relative to the virtual features around it. Obviously it's more complicated under the hood than that. For example, remember that a problem with the spatial anchors is that they move independently, so they don't always agree with each other. The underlying FrozenWorld engine arbitrates those disagreements to come up with the most perceptually correct camera correction, and does that every frame. The scale problem again If the user walks from point A to point B and back to point A, the system has enough information to fix the drift that occurred in transit. It may not know where point B is (and generally doesn't know exactly where any point B is relative to point A), but it knows whether it is at point A or not. When it gets back to point A, it expects things to be pretty much as it left them. If they aren't, the system can make it so. But what about at point B? It thought the 10-meter walk was only 9 meters. And it has no way of knowing whether that 9 meters is correct, and if it isn't, how much it's off. Spatial anchors don't help here. Spatial anchors have the same problem the head tracker does; each knows where it is in the physical world (relative to visible features), but one spatial anchor doesn't know anything about another spatial anchor. Specifically, spatial anchors don't know how far apart they are. This can be inconvenient in many forms, but it becomes a blocking issue when objects, or systems of objects, are larger in size than a meter or so. Consider a model of a room, or a building, or a set of desks, or even a car. While a spatial anchor can keep one end of the model registered with a physical world feature, by the time the other end of the model is reached, significant error might have accumulated. The other end won't be lined up correctly. And the error will be different from device to device, and possibly even between runs on the same device. And so far in this discussion, the minimum information required to fix the problem hasn't been introduced. World Locking Tools addresses that problem with the Space Pins API, which allows the application to supply enough information relating to the physical world and holographic world to correct for the errors in distance traveled. This allows large holograms to appear aligned with the physical world all over. Next These advanced mechanisms will be covered in later sections, but it's useful to first look in detail at World Locking Tools' baseline operation. Understanding what services the baseline operation does and doesn't supply will help you to determine the proper use of advanced concepts later, and whether those advanced techniques are even required for a specific application. See also FAQ The basic system Advanced topics"
  },
  "DocGen/Documentation/Concepts/Advanced/Architecture/Architecture.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/Architecture/Architecture.html",
    "title": "Architecture | World Locking Tools for Unity Documentation",
    "keywords": "Architecture The World Locking Tools for Unity architecture may be summarized by the following diagram. In general, the client application will make its intent known declaratively through settings on the World Locking Manager. The managers, in turn, imperatively drive the processing by lower layers. While all World Locking Tools capabilities are available through asset creation in the Unity Editor, every effort has been made to provide equal access to construction and configuration from script. Any capability missing available in Unity's Inspector but not from the scripting API should be considered a code defect. Reporting is as a bug is appreciated! See contributing for more info. An exception to this flow is in the attachment point mechanism, which is discussed in detail in several articles within this documentation. In short, the client requests attachment points from the World Locking Attachment Point Manager. These attachment points then serve as conduits through which the application may be informed about refit operations. See also Attachment points WorldLockingManager IAnchorManager IFragmentManager IAttachmentPointManager IAlignmentManager And in API reference: WorldLockingManager IAnchorManager IFragmentManager IAttachmentPointManager IAlignmentManager"
  },
  "DocGen/Documentation/Concepts/Advanced/Architecture/FrozenWorldDLL.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/Architecture/FrozenWorldDLL.html",
    "title": "FrozenWorldEngine | World Locking Tools for Unity Documentation",
    "keywords": "Inside the Frozen World Engine Typedefs , structs , and constants used throughout this documentation Typedefs typedef uint64_t FrozenWorld_AnchorId; typedef uint64_t FrozenWorld_FragmentId; Structs struct FrozenWorld_Vector { float x; float y; float z; }; struct FrozenWorld_Quaternion { float x; float y; float z; float w; }; struct FrozenWorld_Transform { FrozenWorld_Vector position; FrozenWorld_Quaternion rotation; }; struct FrozenWorld_AttachmentPoint { FrozenWorld_AnchorId anchorId; FrozenWorld_Vector locationFromAnchor; }; Constants // Special values for FrozenWorld_AnchorId static const FrozenWorld_AnchorId FrozenWorld_AnchorId_INVALID = 0; static const FrozenWorld_AnchorId FrozenWorld_AnchorId_UNKNOWN = 0xFFFFFFFFFFFFFFFF; // Special values for FrozenWorld_FragmentId static const FrozenWorld_FragmentId FrozenWorld_FragmentId_INVALID = 0; static const FrozenWorld_FragmentId FrozenWorld_FragmentId_UNKNOWN = 0xFFFFFFFFFFFFFFFF; The most significant practical distinction between the INVALID and UNKNOWN anchor or fragment identifiers is that INVALID identifiers can never be stored in a snapshot (and attempting to do so anyway will lead to an error being reported) but UNKNOWN identifiers can. Semantically, use INVALID to express 'the anchor or fragment does not exist' and UNKNOWN to express 'the anchor or fragment exists, but it is ambiguous, not known, or not relevant at this point'. You can use FrozenWorld_FragmentId_UNKNOWN as the fragment association of all anchors you add to a SPONGY snapshot, for example, as Frozen World ignores them anyway and automatically assigns unique fragment identifiers to all anchors when they are added to the FROZEN snapshot during alignment. General considerations and conventions Parameter naming conventions Parameters may have an implied contract based on their name if it matches any of the following patterns (with foo in the following description being a generic placeholder that's substituted by any valid symbol name): Naming pattern Implied contract fooBufferSize, fooOut The fooOut pointer points to a writable memory buffer that has room for (at least) fooBufferSize elements of fooOut's pointed-to data type. fooBufferSize must be zero or positive. fooBufferSize is counted in elements of fooOut's pointed-to data type (not e.g. bytes). fooOut must not be null. It must always point to a valid address, even if fooBufferSize is zero. The called function will write no more than fooBufferSize elements to the memory pointed to by fooOut even if more data would be available. fooOut The memory pointed to by fooOut must be safe to be written to. Existing data in the pointed-to memory location is ignored. The function will not change the pointed-to memory except by writing a valid update to it; if fooOut points to a buffer intended to receive multiple elements of the same type, only some of the elements may have been written if an error occurs, but each of the written elements will have been written completely. fooInOut The memory pointed to by fooInOut may be read and must be safe to be written to. The information at the memory location pointed to by fooInOut must be valid (per the function's description). The function will not change the pointed-to memory except by writing a valid update to it; if fooInOut points to a buffer containing multiple elements of the same type, only some of the elements may have been updated if an error occurs, but each of the actually updated elements will have been updated completely. Thread safety This library is thread-aware, but functions in this library that change its state are not generally re-entrant or safe for being called concurrently unless explicitly noted otherwise. Read or query operations can be called safely from different threads in parallel as long as there are no concurrent calls to any functions that change the internal state of the library. Version information can be queried at any time in any thread. Error information can be queried at any time in any thread and always return error information for the last function called in the same thread. Startup and teardown are internally synchronized. It is acceptable to call FrozenWorld_Destroy() from a different thread than the one FrozenWorld_Init() was called on. Snapshot access of different snapshots is thread-safe – but reads and modifications of the same snapshot are not. However, it is safe to query the same snapshot's data from multiple threads in parallel as long as there are no concurrent modifications to it. Refit operations can be safely prepared in a background thread – though Init() and Apply() must be externally synchronized with all other accesses to the snapshots they read and modify. Persistence allows reading or writing to streams in a background thread – though Gather() and Apply() must be externally synchronized with all other accesses to the snapshots they read and modify. Diagnostics and errors Version information // -> number of chars (excluding trailing null) copied to the buffer int FrozenWorld_GetVersion( bool detail, int versionBufferSize, char* versionOut); Returns a representation of the DLL's version. This is useful to know when investigating suspected bugs and weird phenomena because it allows us to relate what you're seeing with a specific version of the Frozen World source code. If the detail flag is false, the returned version information is a short, single-line string contains a number – this representation is suitable for being displayed on screen or in an info dialog box. If the detail flag is true, the version information is a multi-line string that specifies exactly which source files were compiled to build the DLL. Under extraordinary circumstances, e.g. if you received a bleeding-edge test build of the DLL directly from a Frozen World developer, both the compact and the detailed version information may describe several distinct version numbers or contain a more detailed listing of different source files and their respective revisions. This function can be called safely regardless of the library's state (i.e. even before startup and after teardown) and the thread they're called from. Error flag and diagnostic error messages bool FrozenWorld_GetError(); // -> number of chars (excluding trailing null) copied to the buffer int FrozenWorld_GetErrorMessage( int messageBufferSize, char* messageOut); Every function validates parameters and preconditions. If anything is amiss, the function returns immediately (with 0, false, or a similar non-result) and sets the error flag that can be queried with FrozenWorld_GetError() . If the function completes without errors, the error flag is reset. Call FrozenWorld_GetErrorMessage() to get further detailed diagnostic information about the cause of the error to help you debug the problem. If the error flag isn't set, the returned error message is empty. These functions can be called safely regardless of the library's state (i.e. even before startup and after teardown). The error information returned by these functions always relates to the most recent (other) function call executed on the same thread. Diagnostic data recordings Frozen World's serialization facility can be used to create a continuous recording of all state necessary to investigate Frozen World's runtime behavior after the fact. Diagnostic recordings can be invaluable assets for offline debugging and testing and are designed to be sufficiently compact and unobtrusive to allow them to be created by default. See Persistence below. Startup and teardown void FrozenWorld_Init(); void FrozenWorld_Destroy(); The FrozenWorld_Init() function initializes memory management and allocates some internal data structures in the Frozen World library. It must be called at least once at the start of the session before any of the other Frozen World functions are called. At the end of the session, FrozenWorld_Destroy() must be called once for every prior call to FrozenWorld_Init() to clean up. Both functions can be called multiple times, but must be called in pairs: The first invocation of FrozenWorld_Init() performs the actual initialization, and the corresponding (last) invocation of FrozenWorld_Destroy() performs the actual cleanup. All other invocations do nothing. This is useful if there are several user libraries that want to access the Frozen World library without requiring them to coordinate startup and teardown among themselves. These functions are internally synchronized. It is acceptable to call FrozenWorld_Destroy() from a different thread than FrozenWorld_Init() . Alignment (frame-to-frame) Initializing the spongy snapshot and aligning the frozen frame of reference 1. Initialize the spongy snapshot // Step 1 of 3: void FrozenWorld_Step_Init(); This clears the SPONGY snapshot. After you've called FrozenWorld_Step_Init() , just must fill the SPONGY snapshot manually with… The head's current position and orientation. All anchors you know the current transform (in relation to the head) of. The fragment association of anchors in the SPONGY snapshot is ignored (fragments are created during the alignment step automatically based on whether Frozen World can automatically deduce a spatial relationship between them), so you can use FrozenWorld_FragmentId_UNKNOWN for them. Edges between those anchors to signify which pairs of anchors are directly spatially related to each other. For example, two anchors next to each other in the same room should be connected by an edge; but two anchors separated by a wall shouldn't be. The current most significant anchor among those you've added to the SPONGY snapshot. This is the anchor whose relation to the head is presumably (or likely) most accurately represented in the SPONGY snapshot. This information is used in various ways, e.g. as a starting point when walking though the anchor graph to gather supports (see next step) or when placing scene objects (see Creating and tracking scene object attachment points below). See Accessing snapshots below (also for an introduction on the different kinds of snapshots). 2. Gather alignment supports from the spongy snapshot // Step 2 of 3: int FrozenWorld_Step_GatherSupports(); // -> number of gathered supports After this function has run, alignment supports can be inspected or tweaked (e.g. to extend or filter the set gathered by default, change the specific location used for alignment, change the relevance and tightness metrics used to weigh supports against each other, or just to visualize the gathered supports). This function uses the Frozen World alignment configuration to select which anchors from the SPONGY snapshot to gather for supports and how their relevance and tightness metrics are calculated. Calling this function is optional: You can just as well implement this step manually by creating a set of alignment supports yourself. See Configuring Frozen World alignment and Accessing alignment supports below. 3. Align the Frozen World to the alignment supports // Step 3 of 3: void FrozenWorld_Step_AlignSupports(); Alignment is based on the previously initialized SPONGY snapshot and the previously gathered supports. After this function has run, the FROZEN snapshot can be inspected to find the updated head (i.e. camera) transform (or the alignment transform of the most recently used spongy coordinate frame relative to the frozen coordinate frame) or to visualize frozen anchors and edges. In addition, after running this function all alignment metrics are also updated and can be queried to find out if a fragment merge or refreeze is indicated (based on configurable thresholds). See Accessing snapshots and Querying metrics below. Configuring Frozen World alignment Modify the Frozen World alignment configuration to tweak the results of FrozenWorld_Step_GatherSupports() , which affect alignment quality, to the requirements of the implemented scenario. There is a default Frozen World alignment configuration, so doing this is optional. struct FrozenWorld_AlignConfig { // Max edge deviation (0.0..1.0, default 0.05) to cut off // significantly deviating anchors from alignment float edgeDeviationThreshold; // Relevance gradient away from head float relevanceSaturationRadius; // 1.0 at this distance from head float relevanceDropoffRadius; // 0.0 at this distance (must be // greater than saturation radius) // Tightness gradient away from head float tightnessSaturationRadius; // 1.0 at this distance from head float tightnessDropoffRadius; // 0.0 at this distance (must be greater // than saturation radius) }; void FrozenWorld_GetAlignConfig( FrozenWorld_AlignConfig* configOut); void FrozenWorld_SetAlignConfig( FrozenWorld_AlignConfig* config); Accessing alignment supports Access alignment supports after the FrozenWorld_Step_Gather() function has run to extend, filter, change, or just inspect the alignment supports gathered from the SPONGY snapshot. Doing this is optional. struct FrozenWorld_Support { FrozenWorld_AttachmentPoint attachmentPoint; float relevance; // 1.0 (max) .. 0.0 (min, excluded) float tightness; // 1.0 (max) .. 0.0 (min, only lateral alignment) }; int FrozenWorld_GetNumSupports(); int FrozenWorld_GetSupports( int supportsBufferSize, FrozenWorld_Support* supportsOut); // -> number of elements copied to the buffer void FrozenWorld_SetSupports( int numSupports, FrozenWorld_Support* supports); Accessing snapshots Anchor and edge data is organized in different snapshots. Each snapshot contains (at least) any number of anchors along with their poses, fragment associations, and connecting edges. In addition, the SPONGY and FROZEN snapshots contain information about the current head pose and most significant anchor. The SPONGY snapshot must be populated (by you) frame-to-frame with input data to be used for alignment . The FROZEN snapshot is maintained and kept up to date as a matter of course during alignment and will also be updated when the results of a refit operation are applied. Use these enum constants to indicate which snapshot's information you want to access: enum FrozenWorld_Snapshot { FrozenWorld_Snapshot_SPONGY = 0, FrozenWorld_Snapshot_FROZEN = 1, }; It is safe to read and modify different snapshots concurrently from different threads. It is unsafe to access the same snapshot (read or modify) concurrently from different threads, including through the use of functions that are documented to require access to these snapshots (e.g. all alignment functions, which require access to the SPONGY and FROZEN snapshots). Accessing the head pose and alignment Get or set the head (i.e. camera) location and directions (only SPONGY and FROZEN snapshots): void FrozenWorld_GetHead( FrozenWorld_Snapshot snapshot, FrozenWorld_Vector* headPositionOut, FrozenWorld_Vector* headDirectionForwardOut, FrozenWorld_Vector* headDirectionUpOut); void FrozenWorld_SetHead( FrozenWorld_Snapshot snapshot, FrozenWorld_Vector* headPosition, FrozenWorld_Vector* headDirectionForward, FrozenWorld_Vector* headDirectionUp); Get or set the alignment transform, which maps coordinates in the Frozen World frame of reference into the most recently used spongy frame of reference: void FrozenWorld_GetAlignment( FrozenWorld_Transform* spongyFromFrozenTransformOut); void FrozenWorld_SetAlignment( FrozenWorld_Transform* spongyFromFrozenTransform); The alignment transform together with the most recent spongy head transform is wholly redundant with the frozen head transform. Use whichever is more convenient for you. Accessing the most significant anchor Get or set the most significant anchor, i.e. the anchor whose pose relative to the head is currently known best (only SPONGY and FROZEN snapshots): void FrozenWorld_GetMostSignificantAnchorId( FrozenWorld_Snapshot snapshot, FrozenWorld_AnchorId* anchorIdOut); void FrozenWorld_SetMostSignificantAnchorId( FrozenWorld_Snapshot snapshot, FrozenWorld_AnchorId anchorId); Get the fragment identifier (as defined by the FROZEN snapshot) of the current most significant anchor: void FrozenWorld_GetMostSignificantFragmentId( FrozenWorld_Snapshot snapshot, FrozenWorld_FragmentId* fragmentIdOut); If the queried snapshot's most significant anchor is FrozenWorld_AnchorId_INVALID , this function returns FrozenWorld_FragmentId_INVALID . If you query the fragment identifier of the most significant anchor in the SPONGY snapshot, this will still look up this anchor's fragment stored in the FROZEN snapshot (because fragment associations in the SPONGY snapshot are ignored). If the spongy most significant anchor doesn't exist in the FROZEN snapshot yet, querying its fragment identifier returns FrozenWorld_FragmentId_UNKNOWN . Accessing anchors struct FrozenWorld_Anchor { FrozenWorld_AnchorId anchorId; FrozenWorld_FragmentId fragmentId; FrozenWorld_Transform transform; }; Read all anchors in the snapshot: int FrozenWorld_GetNumAnchors( FrozenWorld_Snapshot snapshot); int FrozenWorld_GetAnchors( // -> number of elements copied to the buffer FrozenWorld_Snapshot snapshot, int anchorsBufferSize, FrozenWorld_Anchor* anchorsOut); Add anchors to the snapshot or update an individual anchor's transform or fragment association (use with care!): void FrozenWorld_AddAnchors( FrozenWorld_Snapshot snapshot, int numAnchors, FrozenWorld_Anchor* anchors); bool FrozenWorld_SetAnchorTransform( // -> true if the anchor exists FrozenWorld_Snapshot snapshot, FrozenWorld_AnchorId anchorId, FrozenWorld_Transform* transform); bool FrozenWorld_SetAnchorFragment( // -> true if the anchor exists FrozenWorld_Snapshot snapshot, FrozenWorld_AnchorId anchorId, FrozenWorld_FragmentId fragmentId); Remove an individual anchor (and all edges attached to it), or all anchors (along with all edges) at once: bool FrozenWorld_RemoveAnchor( // -> true if the anchor existed before being removed FrozenWorld_Snapshot snapshot, FrozenWorld_AnchorId anchorId); void FrozenWorld_ClearAnchors( FrozenWorld_Snapshot snapshot); Accessing graph edges struct FrozenWorld_Edge { FrozenWorld_AnchorId anchorId1; FrozenWorld_AnchorId anchorId2; }; Read all edges between anchors in the snapshot: int FrozenWorld_GetNumEdges( FrozenWorld_Snapshot snapshot); int FrozenWorld_GetEdges( // -> number of elements copied to the buffer FrozenWorld_Snapshot snapshot, int edgesBufferSize, FrozenWorld_Edge* edgesOut); Note that querying the number of edges is not a constant-time operation because edges are stored in a sparse array, so all edges must be enumerated in order to find out how many edges there are. If this is a performance concern, consider saving the number of edges from frame to frame and change your edge buffer size based on the number of edges stored indicated by the return value of FrozenWorld_GetEdges() . Add edges between anchors to the snapshot: void FrozenWorld_AddEdges( FrozenWorld_Snapshot snapshot, int numEdges, FrozenWorld_Edge* edges); Remove an individual edge, or all edges at once: bool FrozenWorld_RemoveEdge( // -> true if the edge existed before being removed FrozenWorld_Snapshot snapshot, FrozenWorld_AnchorId anchorId1, FrozenWorld_AnchorId anchorId2); void FrozenWorld_ClearEdges( FrozenWorld_Snapshot snapshot); Utility functions Merging anchors and edges int FrozenWorld_MergeAnchorsAndEdges( // -> number of anchors added to the target snapshot FrozenWorld_Snapshot sourceSnapshot, FrozenWorld_Snapshot targetSnapshot); Copies all anchors and edges that exist in sourceSnapshot but don't exist in targetSnapshot into targetSnapshot, effectively merging all anchors and edges from both snapshots into targetSnapshot. While doing that, this function adapts fragment associations and anchor poses of the source anchors that are copied over: If there is an overlap of anchors between a source and a target fragment, all non-overlapping anchors in that source fragment are added to the corresponding target fragment (i.e. have their fragmentId reassigned to match the target fragment) and have their poses adapted to become consistent with the poses of previously existing target anchors in the target fragment. If one source fragment overlaps several target fragments , the source fragment is split and all non-overlapping source anchors are added to the single target fragment that has the greatest overlap with the source fragment (in number of overlapping anchors). If a source fragment overlaps no target fragment at all, its anchors are copied into targetSnapshot into a new target fragment with a uniquely chosen fragmentId that doesn't exist yet in targetSnapshot. The poses of these anchors remain the same as in sourceSnapshot. You can use this function to bulk-integrate an entire SPONGY snapshot into the FROZEN snapshot instead of relying on auto-discovery of not-yet-seen support anchors during alignment. This is not usually needed, but it can be useful if you require a guarantee that all anchors you have in your SPONGY snapshot have meaningful corresponding FROZEN poses. Identifying missing edges that would guarantee full graph connectivity int FrozenWorld_GuessMissingEdges( // -> number of elements copied to the buffer FrozenWorld_Snapshot snapshot, int guessedEdgesBufferSize, FrozenWorld_Edge* guessedEdgesOut); Identifies edges that are missing in the given snapshot to guarantee that all anchors in every fragment are fully connected through edges. The 'guessing' aspect of this function that's suggested by the function name is that while an edge between two anchors should signify that there's traversable free space between these two anchors, this function (obviously) can't know that and therefore makes a guess based on the geometric proximity of anchors. The result of this is a graph that more or less represents the path a user might have taken while creating these anchors. This function attempts (on a best-effort basis) to avoid very short edges between anchors that are very close to each other. Since the 'edge deviation' metric used internally to identify fractures in the graph (which are caused by SPONGY anchor relations deviating too much from FROZEN anchor relations) is relative to edge length, a very short edge will exhibit a huge 'edge deviation' metric (and cause undesired fracturing or refreeze) if its two anchors change their relation even just a little bit. For this reason, this function will suggest a detour over a slightly more distant anchor to avoid a very short edge as long as full graph connectivity can still be guaranteed. If the return value of this function indicates that the entire guessedEdgesOut buffer was filled with data, there may be more missing edges than can be returned given the buffer size specified by guessedEdgesBufferSize . In this case, you can add the guessed edges to the snapshot using the FrozenWorld_AddEdges() function and call FrozenWorld_GuessMissingEdges() again to identify more missing edges. Inspecting metrics and indicators Query Frozen World alignment metrics to get a standardized high-level view on the current alignment quality. Metrics include indicator flags you can use to determine if a fragment merge is currently possible or if a refreeze is indicated (based on thresholds you configured in your Frozen World alignment and metric configuration settings). Visual deviation, which is caused by trade-offs made while aligning the Frozen World to the SPONGY snapshot, is measured by these metrics: Linear deviation is simply the distance between a support point in the most recent SPONGY snapshot and its aligned counterpart in the Frozen World. If alignment is perfect, linear deviation is zero. Lateral deviation shoots two imaginary rays, a 'spongy ray' and a 'frozen ray', from the head (i.e. camera) position to a support point in the most recent SPONGY snapshot and to its aligned counterpart in the Frozen World. The spongy ray is then intersected with the frozen support point's view plane (i.e. a plane that is orthogonal to the frozen ray and goes through the frozen support point). The lateral deviation metric is the distance between this intersection point of the spongy ray and the frozen support point. If alignment is perfect, lateral deviation is zero. Angular deviation is the angle (expressed in radians) between the spongy ray and the frozen ray described for lateral deviation above. If alignment is perfect, angular deviation is zero; the maximum possible angular deviation is pi (i.e. 180°). Angular deviation is capped to a configurable minimum distance between the head and the spongy and frozen support point, i.e. limited to the angle as if the head was moved to the center of a circle whose radius is the configured 'near distance' and that goes through the spongy and frozen support point. Other than being convenient, using these functions is optional: All metrics calculated by the built-in function could just as well be calculated in user code. Querying metrics struct FrozenWorld_Metrics { // Merge and refreeze indicators bool refitMergeIndicated; bool refitRefreezeIndicated; // configurable // Currently trackable fragments int numTrackableFragments; // Alignment supports int numVisualSupports; int numVisualSupportAnchors; int numIgnoredSupports; int numIgnoredSupportAnchors; // Visual deviation metrics float maxLinearDeviation; float maxLateralDeviation; float maxAngularDeviation; // configurable float maxLinearDeviationInFrustum; // configurable float maxLateralDeviationInFrustum; // configurable float maxAngularDeviationInFrustum; // configurable }; void FrozenWorld_GetMetrics( FrozenWorld_Metrics* metricsOut); Metrics are calculated for the support points in the SPONGY snapshot, so if you use FrozenWorld_Step_GatherSupports() instead of your own code to gather supports, metrics are affected by these alignment configuration settings (see Configuring Frozen World alignment above): The relevanceDropoffRadius setting controls the maximum distance of a support point from the head. The edgeDeviationThreshold setting may cause some supports to be ignored for visual alignment, which is a refreeze indicator in and of itself and also excludes the ignored supports from all visual deviation metrics. Some metrics are also affected by metrics configuration settings (see Configuring metrics below): The refitRefreezeIndicated flag is controlled by the refreeze… thresholds. The angular deviation metrics (maxAngularDeviation and …InFrustum) are limited by the angularDeviationNearDistance setting. The max…DeviationInFrustum metrics are controlled by the frustum… settings. Metrics apply to the most recent result of calling FrozenWorld_Step_Align() and are calculated lazily when FrozenWorld_GetMetrics() is called either for the first time during a step or after FrozenWorld_SetMetricsConfig() was called. Configuring metrics Modify the metrics configuration to tweak indicators and frustum-dependent metrics to the requirements of the implemented scenario. There is a default metrics configuration, so doing this is optional. struct FrozenWorld_MetricsConfig { // Angular deviation capped to this distance float angularDeviationNearDistance; // View frustum float frustumHorzAngle; float frustumVertAngle; // Thresholds for refreeze indicator float refreezeLinearDeviationThreshold; float refreezeLateralDeviationThreshold; float refreezeAngularDeviationThreshold; }; void FrozenWorld_GetMetricsConfig( FrozenWorld_MetricsConfig* configOut); void FrozenWorld_SetMetricsConfig( FrozenWorld_MetricsConfig* config); Understanding refit operations (fragment merge and refreeze) In general, you can simply work with locations, distances, and scene object transforms in your scene graph as in any big, rigid coordinate system. Allowing you to do this is at the core of what Frozen World wants to provide to you. However, as the device's tracking doesn't supply an absolute position in the real world, sometimes two parts of the coordinate system that were originally thought to be separate are discovered to be actually connected to each other, necessitating a fragment merge; or tracking errors accumulate to a degree that makes it necessary to rearrange things in the scene graph to improve alignment quality from there on out, necessitating a refreeze. These refit operations (i.e. fragment merge and refreeze) occur relatively rarely. Usually, they happen somewhat more frequently as long as the device is still exploring unknown spaces, and they become more infrequent (or even stop happening at all) as the device continues learning about its environment. (In fact, if your device has sufficiently learned about the environment you are using it in, you may never have to deal with refit operations at all.) Refit operations do not happen automatically: You must actively initiate them when they are indicated. This gives you the opportunity to postpone them until your scene is in a state that makes it easier for you to deal with the refit. You can even rate-limit refit operations yourself. A refit operation becomes indicated (see Inspecting metrics and indicators above) as deviations between the generally immutable Frozen World and the always-changing, always-evolving SPONGY snapshots supplied during alignment become too great. Whatever counts as 'too great' is a subjective and application-dependent quality trade-off you must make based on your particular scenario. (You can use the default configuration and indicators as a starting point.) As the last step of doing a refit operation, some or all of your scene objects must change their actual transform in the scene coordinate system so they stay visually aligned with the real world. Since you are yourself in control of initiating refit operations, there is no need for this 'scene refit' to be done in realtime on a per-frame budget: Your code can take however much time it needs to get it right. Creating and tracking scene object attachment points Unfortunately, as device tracking errors accumulate, the result can be that things are close to each other (or even overlap) in Frozen World coordinate space that are nowhere near each other in the real world. For that reason, Frozen World coordinates alone aren't sufficient to fullly describe which ways two nearby scene objects should move, respectively, as the result of a refit operation. Attachment points are small data structures (see Typedefs, structs, and constants used throughout this page above) that describe the logical attachment of something to a certain part of the Frozen World. In essence, an attachment point captures which anchor is that scene object's own 'most significant' one (like the most significant anchor supplied for the device itself in a SPONGY snapshot). In addition to the anchor identifier, an attachment point also contains a location in that anchor's own frame of reference. This location normally coincides with the scene object's location if the scene object is sufficiently close to its anchor, but this is not a general rule you should rely on. You should create and maintain an attachment point for every top-level scene object that can move independently. Attachment points aren't anchors . Even though they technically refer to one anchor in the frozen graph and encode a point in that anchor's coordinate system, they are not interpreted by Frozen World in a way that relates them to just that one anchor. Instead, an attachment point logically encodes 'a point in the graph between its anchors' for future reference when applying a refit operation, and to a significant degree any given attachment point could be referencing any of the anchors close to it without affecting its behavior at all. This seems not so different from attaching a scene object directly to an anchor (e.g. an individual SpatialAnchor or Unity WorldAnchor) without Frozen World. However, there are two significant differences: Firstly, Frozen World attachment points never change position on their own; and secondly, unlike anchors, attachment points can (and should) be purposely transitioned through the scene to tag along with the scene object they're attaching to the Frozen World. Attachment points are lightweight . Creating or using an attachment point leaves no footprint inside the Frozen World library. None of the library functions that accept FrozenWorld_AttachmentPoint parameters alter the state of the Frozen World in any way (though they do inspect it). There is no library-side overhead involved in creating or maintaining a great number of attachment points (aside from, obviously, the compute involved in calling library functions with them). Create an attachment point for a newly placed scene object void FrozenWorld_Tracking_CreateFromHead( FrozenWorld_Vector* frozenLocation, FrozenWorld_AttachmentPoint* attachmentPointOut); void FrozenWorld_Tracking_CreateFromSpawner( FrozenWorld_AttachmentPoint* spawnerAttachmentPoint, FrozenWorld_Vector* frozenLocation, FrozenWorld_AttachmentPoint* attachmentPointOut); Which one of these functions you should call to create an attachment point for a newly placed scene object depends on whether the newly placed scene object was, from the logic and intent of your particular scenario, spawned off some already-existing scene object (like a rocket launched from a rocket launcher, or an egg laid by a duck, or a child window slate detached from its parent window slate) or not. If you are placing a scene object without an initial relation to any existing scene objects, use FrozenWorld_Tracking_CreateFromHead() , which creates the initial attachment point for the scene object as if the device had spawned it. Otherwise, use FrozenWorld_Tracking_CreateFromSpawner() and pass the existing scene object's attachment point as the spawnerAttachmentPoint. Track an attachment point when its scene object moves When your scene object continuously moves through the scene (because it is animated or simulated; this does not apply to scene objects being relocated because of a refit operation!), you should move its attachment point along with it. void FrozenWorld_Tracking_Move( FrozenWorld_Vector* targetFrozenLocation, FrozenWorld_AttachmentPoint* attachmentPointInOut); It is not necessary to move a scene object's attachment point every frame during continuous movement: You can wait until it has moved into a distance of at least a half-unit away from where you updated its attachment point before until you need to move the attachment point along with it. However, if you do so, you should, after preparing a refreeze, make sure to do one final update of the attachment point just prior to invoking FrozenWorld_RefitRefreeze_CalcAdjustment() to ensure that the calculated adjustment is based on the scene object's latest position. Note that if you teleport a scene object through the scene (instead of continuously moving it through the scene), you should forget its prior attachment point data and initialize a new one from scratch based on the same considerations as for a newly placed scene object. Initiating and executing a fragment merge Fragment merge is due when there are multiple simultaneously trackable fragments represented in the SPONGY snapshot. (Built-in Frozen World metrics take only the support anchors used for alignment into consideration for the refitMergeIndicated flag.) 1. Initialize the fragment merge // Step 1 of 4: bool FrozenWorld_RefitMerge_Init(); The fragment merge operation is initialized with the current version of the SPONGY snapshot set up after FrozenWorld_Step_Init() . After the fragment merge has been initialized, it is safe to change the SPONGY and FROZEN snapshots without affecting the results of the fragment merge. FrozenWorld_RefitMerge_Init() returns true if the necessary preconditions for performing a fragment merge are given (i.e. there's more than one simultaneously trackable fragment represented in the SPONGY snapshot). If this is not the case, the function returns false, and the fragment merge operation is not initialized. Successfully initializing a fragment merge operation while any other refit operation is running silently cancels the previous refit operation and discards its results. If initializing the fragment merge operation is not successful, the other refit operation (if any) remains unaffected. 2. Prepare the fragment merge // Step 2 of 4: // Can be executed in a background thread. void FrozenWorld_RefitMerge_Prepare(); Preparing the fragment merge is done based on information gathered by FrozenWorld_RefitMerge_Init() and is independent from ongoing changes to the state of the SPONGY snapshot or the overall Frozen World (including the FROZEN snapshot and Frozen World configuration). Normally, this step executes quickly, but if guaranteed realtime performance is a concern, it is safe to execute FrozenWorld_RefitMerge_Prepare() asynchronously in a background worker thread even across several frames while the SPONGY snapshot continues to evolve and the Frozen World alignment continues to be done. However, you must take care to not initialize another refit operation while this one is being prepared in the background. 3. Inspect fragment merge results and refit the scene When FrozenWorld_RefitMerge_Prepare() has finished executing, you must change the transforms of some or all of your scene objects to accommodate the pending fragment merge. The scene objects affected by this are identified by the anchorId (or more precisely: the fragmentId of that anchor) stored in the attachment point you created and maintained for that scene object (see Creating and tracking scene object attachment points above). struct FrozenWorld_RefitMerge_AdjustedFragment { FrozenWorld_FragmentId fragmentId; int numAdjustedAnchors; FrozenWorld_Transform adjustment; // post-merged from pre-merged }; // Step 3.1 of 4: int FrozenWorld_RefitMerge_GetNumAdjustedFragments(); // Step 3.2 of 4: // -> number of elements copied to the buffer int FrozenWorld_RefitMerge_GetAdjustedFragments( int adjustedFragmentsBufferSize, FrozenWorld_RefitMerge_Adjustment* adjustedFragmentsOut); // Step 3.3 of 4, for each adjusted fragment: // -> number of elements copied to the buffer int FrozenWorld_RefitMerge_GetAdjustedAnchorIds( FrozenWorld_FragmentId fragmentId, int adjustedAnchorIdsBufferSize, FrozenWorld_AnchorId* adjustedAnchorIdsOut); // Step 3.4 of 4: void FrozenWorld_RefitMerge_GetMergedFragmentId( FrozenWorld_FragmentId* mergedFragmentIdOut); All scene objects that are in the same Frozen World fragment (i.e. attached to anchors that have the same fragmentId) must have their transforms adjusted by a single common adjustment transform, so you can rely on scene objects in the same fragment keeping relative position and orientation to each other. Keep in mind that orientations may change, too, so don't forget to adjust any directional vectors (e.g. velocities and accelerations) as well. Note that the fragment itself that everything else is merged into is kept stationary. (Among all fragments that need to be merged, the one whose axis-aligned bounding box has the greatest volume in the Frozen World is chosen to remain stationary and be merged into.) Scene objects in the stationary fragment don't require adjustment, so this fragment isn't reported as an adjusted fragment. 4. Apply the fragment merge results to the Frozen World itself Finally, after you have taken care of adjusting your own scene objects, corresponding adjustments must be applied to the Frozen World itself to finalize the fragment merge operation. // Step 4 of 4: void FrozenWorld_RefitMerge_Apply(); You can only call FrozenWorld_RefitMerge_Apply() only once for a fragment merge operation. After FrozenWorld_RefitMerge_Apply() has been called, the function calls required to refit your scene's objects (see 3. Inspect fragment merge results and refit the scene above) cannot be called any longer until the next fragment merge has been prepared. Initiating and executing a refreeze Refreeze is due when anchor relations in the SPONGY snapshot have become so different from their Frozen World counterparts that the visual trade-offs made to align the Frozen World to the SPONGY snapshot are too significant to simply ignore. There is no clear-cut, objective threshold for this: Whether a refreeze is advisable depends on the quality trade-offs you are willing to make in your particular scenario. (Built-in Frozen World metrics use configurable thresholds and take only support anchors into consideration for the refitRefreezeIndicated flag.) If a refreeze is executed when there are multiple simultaneously trackable fragments in the SPONGY snapshot, it will implicitly merge all anchors in those fragments into a single fragment during the refreeze. 1. Initialize the refreeze // Step 1 of 4: bool FrozenWorld_RefitRefreeze_Init(); The refreeze operation is initialized with the current version of the SPONGY snapshot set up after FrozenWorld_Step_Init() . After the refreeze has been initialized, it is safe to change the SPONGY and FROZEN snapshot without affecting the results of the refreeze. FrozenWorld_RefitRefreeze_Init() returns true if the necessary preconditions for performing a refreeze are given (i.e. there's more than one trackable anchor represented in the SPONGY snapshot within relevance distance from the head that's graph-connected to the current most significant anchor). If this is not the case, the function returns false, and the refreeze operation is not initialized. Initializing a refreeze operation while any other refit operation is running silently cancels the previous refit operation and discards its results. If initializing the refreeze operation is not successful, the other refit operation (if any) remains unaffected. 2. Prepare the refreeze // Step 2 of 4: // Can be executed in a background thread. void FrozenWorld_RefitRefreeze_Prepare(); Preparing the refreeze is done based on information gathered by FrozenWorld_RefitRefreeze_Init() and is independent from changes to the ongoing state of the SPONGY snapshot or the overall Frozen World (including the FROZEN snapshot and Frozen World configuration). Normally, this step executes quickly, but if guaranteed realtime performance is a concern, it is safe to execute FrozenWorld_RefitRefreeze_Prepare() asynchronously in a background worker thread even across several frames while the SPONGY snapshot continues to evolve and the Frozen World alignment continues to be done. However, you must take care to not initialize another refit operation while this one is being prepared in the background. 3. Inspect refreeze results and refit the scene When FrozenWorld_RefitRefreeze_Prepare() has finished executing, you must change the transforms of some or all of your scene objects to accommodate the pending refreeze. The scene objects affected by this are identified by the anchorId stored in the attachment point you created and maintained for that scene object (see Creating and tracking scene object attachment points above). // Step 3.1 of 4: int FrozenWorld_RefitRefreeze_GetNumAdjustedAnchors(); int FrozenWorld_RefitRefreeze_GetNumAdjustedFragments(); // Step 3.2 of 4: // -> number of elements copied to the buffer int FrozenWorld_RefitRefreeze_GetAdjustedFragmentIds( int adjustedFragmentIdsBufferSize, FrozenWorld_FragmentId* adjustedFragmentIdsOut); // -> number of elements copied to the buffer int FrozenWorld_RefitRefreeze_GetAdjustedAnchorIds( int adjustedAnchorIdsBufferSize, FrozenWorld_AnchorId* adjustedAnchorIdsOut); // Step 3.3 of 4, for each attached scene object: // -> true if actually adjusted bool FrozenWorld_RefitRefreeze_CalcAdjustment( FrozenWorld_AttachmentPoint* attachmentPointInOut, FrozenWorld_Transform* objectAdjustmentOut); // post-refrozen from pre-refrozen // Step 3.4 of 4: void FrozenWorld_RefitRefreeze_GetMergedFragmentId( FrozenWorld_FragmentId* mergedFragmentIdOut); All scene objects that are attached to one of the anchors reported by FrozenWorld_RefitRefreeze_GetAdjustedAnchorIds() must have their transforms adjusted by the attachment-point-specific adjustment transform supplied by FrozenWorld_RefitRefreeze_CalcAdjustment() . The scene object's attachment point itself must also adjusted, which happens automatically to the attachment point passed to this function. It's possible for an anchor (or fragment) to be reported by FrozenWorld_RefitRefreeze_GetAdjustedAnchorIds() or …_GetAdjustedFragmentIds() but for FrozenWorld_RefitRefreeze_CalcAdjustment() still to return false when it is called with an attachment point attached to that anchor. This can happen when the more in-depth calculations performed by FrozenWorld_RefitRefreeze_CalcAdjustment() come to the conclusion that, despite this anchor being within the refrozen area, it doesn't actually require any adjustment. In this case you're free to simply skip any follow-on processing you might otherwise want to do on your side after an adjustment. 4. Apply the refreeze results to the Frozen World itself Finally, after you have taken care of adjusting your own scene objects, corresponding adjustments must be applied to the Frozen World itself to finalize the refreeze operation. // Step 4 of 4: void FrozenWorld_RefitRefreeze_Apply(); You can only call FrozenWorld_RefitRefreeze_Apply() only once for a refreeze operation. After FrozenWorld_RefitRefreeze_Apply() has been called, the function calls required to refit your scene's objects (see 3. Inspect refreeze results and refit the scene above) cannot be called any longer until the next refreeze has been prepared. Persistence The Frozen World library's persistence support is mainly there for your convenience – there's no inaccessible essential internal state in the library and the binary recording/persistence format is simple and well-documented (see Frozen World binary recording format for details). Instead of using the functions described in this section, you can also implement your own writing and reading facilities for Frozen World without any loss of fidelity. The functions described here just give you a simple, portable way to do the same with less effort, and they give you the no-effort guarantee that they will always be up to date with the latest version of both Frozen World itself (which might perhaps change or extend its data representation in a future update) and the Frozen World binary recording format (which might perhaps be extended to represent some data more efficiently in a future update). The canonical Frozen World binary format is organized as a series (or: stream) of records and can be used for… Persistence – i.e. saving essential Frozen World data with the intention of restoring its state later to continue a session. Diagnostics – i.e. saving all Frozen World data, including transient data like the SPONGY snapshot, with the intention of using it later to investigate why Frozen World behaved in a certain way in a certain situation (e.g. to debug your scene, or Frozen World's integration into your scene, or Frozen World itself) or to implement automated offline testing based on real recordings and interactions. Each stream of records is self-contained, i.e. can be usefully stored, transmitted, and read on its own. However, the records in a given stream are not necessarily all self-contained: The recording format includes the possibility of encoding some data as updates relative to the previous record in the same stream in order to save space, so you need all records from the very start of that stream to guarantee that you can fully restore the recorded Frozen World state up to that point. For any given stream you create using these functions, you can select what data is going to be saved to or restored from it: The includePersistent flag controls inclusion of the most essential Frozen World data required to fully restore a session. This includes all data that can be accessed through the following functions: FrozenWorld_GetAnchors(FROZEN, …) FrozenWorld_GetEdges(FROZEN, …) The includeTransient flag controls inclusion of all other Frozen World state required to diagnose or replay a session. This includes all data that can be accessed through the following functions: FrozenWorld_GetAlignConfig() FrozenWorld_GetHead(SPONGY, …) and (FROZEN, …) FrozenWorld_GetAlignment() FrozenWorld_GetMostSignificantAnchor(SPONGY, …) and (FROZEN, …) FrozenWorld_GetAnchors(SPONGY, …) FrozenWorld_GetEdges(SPONGY, …) FrozenWorld_GetSupports() Note that you should enable both flags to get useful diagnostic recordings. Enabling just the includeTransient flag by itself only really makes sense if your only intention is to replay SPONGY snapshot data for offline scene testing. Serializing (saving) Frozen World state struct FrozenWorld_Serialize_Stream { // Internal handle to this serialization stream int handle; // Number of bytes that at least remain to be serialized for a complete record int numBytesBuffered; // Real time in seconds serialized into this stream so far // (can be modified to control relative timestamps serialized into the stream) float time; // Selection of data to include in the stream // (can be modified to control what is serialized into the stream) bool includePersistent; // frozen anchors and edges bool includeTransient; // alignment config, all other snapshot data, supports }; Frozen World recordings are an unbounded sequence of records. Each record encodes a single update's worth of Frozen World data including a relative time stamp that indicates how much real time passed since the last record in the stream was created. The granularity of updates is entirely up to you: For recordings intended for persistence, you might write just a single record and then close the stream again – or keep a stream open and infrequently (e.g. once every few seconds) append regular updates as a good trade-off between storage space consumption and the timeliness and completeness of the saved data in case your scene quits unexpectedly (e.g. because it crashed). For recordings intended for diagnostics and replay, keep the stream open and frequently (i.e. once every step, just after doing Frozen World alignment) append updates to your recording file. The recording format is designed to be space-efficient and doesn't write a lot of data if nothing much changed since the last record. 1. Opening the stream // Step 1 of 3: void FrozenWorld_Serialize_Open( FrozenWorld_Serialize_Stream* streamInOut); Allocate one instance of the FrozenWorld_Serialize_Stream data structure per stream you want to keep open at the same time. The stream's time property passed to FrozenWorld_Serialize_Open() defines the absolute starting time of the stream, which is used later to calculate the relative time encoded in the first record when FrozenWorld_Serialize_Gather() is called for the first time for this stream. It's best to set the stream's initial time property to your scene's current absolute runtime when you call FrozenWorld_Serialize_Open() . 2. Preparing a data record and getting its binary data to save After opening the stream (which allocates and prepares some resources in the library) you can then repeat the following steps as often as you like, even across an entire session: // Step 2.1 of 3: void FrozenWorld_Serialize_Gather( FrozenWorld_Serialize_Stream* streamInOut); // Step 2.2 of 3, repeated until no more data is available: // Can be executed in a background thread. int FrozenWorld_Serialize_Read( // -> number of bytes copied to the buffer FrozenWorld_Serialize_Stream* streamInOut, int bytesBufferSize, char* bytesOut); Calling FrozenWorld_Serialize_Gather() quickly gathers all information needed for a full record. The stream's time property when FrozenWorld_Serialize_Gather() is called directly controls what relative time (since last record) is encoded in the new record – it's best to keep the stream's time property always set to your scene's absolute runtime. After gathering data, repeatedly call FrozenWorld_Serialize_Read() to copy the serialized binary data of the record into a buffer provided by you, which you can then in turn output/write to wherever you want the recording stream to be physically stored (e.g. a file on disk or a network stream). While you're reading data you can check the stream's numBytesBuffered property to get an indication of how much more data there is at least left to be serialized for this record, which may be useful if you want to e.g. implement rotating size-limited recording files on your side. Reading serialized binary data by calling FrozenWorld_Serialize_Read() can be safely done in a background thread. Doing this can be very useful because it decouples your main thread that runs your scene from unpredictable I/O latencies that are hard to completely avoid when writing data to disk or over network. You mustn't call FrozenWorld_Serialize_Gather() again before all data from the previous record has been read (it will signal an error if you do), but it is safe to simply skip a call to FrozenWorld_Serialize_Gather() if writing the previous record's data is still in progress in your background thread. This won't cause your saved recording to become inconsistent or lose data – it will only reduce the granularity of the recording in that instance. 3. Closing the stream to release internal resources // Step 3 of 3: void FrozenWorld_Serialize_Close( FrozenWorld_Serialize_Stream* streamInOut); Close the stream after you're finished using it to release some memory used internally in the library to keep track of it. All open streams are implicitly closed when FrozenWorld_Destroy() is called. FrozenWorld_Serialize_Close() will signal an error if the previous record wasn't fully read because that means you have received (and may have output/written) incomplete data that can't be fully deserialized later. You can set the stream's numBytesBuffered property to zero prior to calling FrozenWorld_Serialize_Close() to suppress this error. After calling FrozenWorld_Serialize_Close() , the stream's internal handle is deallocated (and set to zero) and cannot be used anymore. You can, however, reuse the FrozenWorld_Serialize_Stream data structure to open a new stream later. Deserializing (loading and restoring) Frozen World state struct FrozenWorld_Deserialize_Stream { // Internal handle to this deserialization stream int handle; // Number of bytes that at least remain to be deserialized for a complete record int numBytesRequired; // Real time in seconds deserialized from this stream so far // (can be modified to change its base value for subsequent deserialized records) float time; // Selection of data applied from the stream // (can be modified to control what is deserialized from the stream) bool includePersistent; // frozen anchors and edges bool includeTransient; // alignment config, all other snapshot data, supports }; When reading a Frozen World recording, you must read and apply all updates beginning at the start of the stream. However, there is no requirement to do this in real time, and you can read and apply even large streams (in the order of hundreds of megabytes and tens of thousands of records) fairly quickly from start to end in order to arrive at a certain recorded point in time. You can choose to read just a subset of the data contained in the stream by setting the stream's includePersistent and includeTransient flags. Of course, enabling includePersistent won't do anything if the stream doesn't contain such data (i.e. wasn't created with the includePersistent flag set during serialization), and the same goes for includeTransient . 1. Opening the stream // Step 1 of 3: void FrozenWorld_Deserialize_Open( FrozenWorld_Deserialize_Stream* streamInOut); Allocate one instance of the FrozenWorld_Deserialize_Stream structure per stream you want to keep open at the same time. The stream's time property is ignored by FrozenWorld_Deserialize_Open() , but it's later updated by FrozenWorld_Deserialize_Apply() by successively aggregating the relative time stamps included in the records that are read. You can change the time property at any time. It's best to set the stream's initial time property either to zero (in order to track this stream's progress in time) or to your scene's current absolute runtime (in order to track the stream's progress in terms of your scene's absolute runtime). 2. Loading binary data into the stream and applying the results After opening the stream (which allocates and prepares some resources in the library) you can then repeat the following steps as often as you like and as long as you have data to feed into the stream: // Step 2a of 3, repeatedly until no more data is consumed: // Can be executed in a background thread. int FrozenWorld_Deserialize_Write( // -> number of bytes consumed from the buffer FrozenWorld_Deserialize_Stream* streamInOut, int numBytes, char* bytes); // Step 2b of 3: void FrozenWorld_Deserialize_Apply( FrozenWorld_Deserialize_Stream* streamInOut); Repeatedly call FrozenWorld_Deserialize_Write() with more data read from your data source (e.g. a file on disk or a network stream you've opened) until it returns zero, indicating that the record is complete and no more data needs to be consumed for this record. While you're doing this, you can check the stream's numBytesRequired to get an indication of how much more data must be read at least for this record, which is useful if you want to make sure you read no more than the exact required amount of data from your data source. Feeding serialized binary data by calling FrozenWorld_Deserialize_Write() can be safely done in a background thread. Doing this can be very useful because it decouples your main thread that runs your scene from unpredictable I/O latencies (or blocking I/O calls while a network stream is waiting for more data to arrive) that are hard to avoid when reading data from disk or from a network. Even if input data is invalid, FrozenWorld_Deserialize_Write() will never report this as an error (as it's near-impossible to recognize binary recording data as malformed until it is parsed in detail and applied to Frozen World state). However, sufficiently malformed input may mislead FrozenWorld_Deserialize_Write() into requesting and consuming (if not necessarily buffering or meaningfully processing) any amount of input data while waiting for a valid record footer to appear in the data stream. If you're out of data to feed into FrozenWorld_Deserialize_Write() and it's still requesting more data, that in and of itself indicates that something may be wrong with the data you've fed it so far. After feeding a record's worth of data to FrozenWorld_Deserialize_Write() , call FrozenWorld_Deserialize_Apply() to apply the information contained in the record to Frozen World's state. Any invalid data previously fed to FrozenWorld_Deserialize_Write() will be reported as an error by Frozenworld_Deserialize_Apply() . You mustn't call FrozenWorld_Deserialize_Apply() until and unless a full record's worth of data has been fed into the library (it will signal an error if you do). This includes calling FrozenWorld_Deserialize_Apply() more than once without feeding more data in between the two calls. This behavior cannot be suppressed, so it is impossible to apply truncated records. You can change the includePersistent and includeTransient flags in between calls to FrozenWorld_Deserialize_Apply() . However, after the first call to FrozenWorld_Deserialize_Apply() for a given stream, you can only switch those flags off – you cannot start out with one or both of the flags disabled and switch them on mid-stream. The reason for this is that individual records might only encode an update instead of being fully self-contained, so skipping some records in the middle of the stream may leave the affected Frozen World data structures in an incomplete state. 3. Closing the stream to release internal resources // Step 3 of 3: void FrozenWorld_Deserialize_Close( FrozenWorld_Deserialize_Stream* streamInOut); Close the stream after you're finished using it to release some memory used internally in the library to keep track of it. All open streams are implicitly closed when FrozenWorld_Destroy() is called. After calling FrozenWorld_Deserialize_Close() , the stream's internal handle is deallocated (and set to zero) and cannot be used anymore. You can, however, reuse the FrozenWorld_Deserialize_Stream data structure to open a new stream later. Frozen World configuration and snapshots (both spongy and frozen) can be recorded in a platform-independent, compact, binary, streaming format to help with debugging and diagnostics and to create (or record) test scenarios. Frozen World binary recording format General structure A recording stream is an unbounded sequence of records. Each record is a sequence of tagged chunks. Each chunk is a sequence of fields. Field types Symbol Storage Description uint16 2 bytes, little-endian Unsigned 16-bit integer uint32 4 bytes, little-endian Unsigned 32-bit integer uint64 8 bytes, little-endian Unsigned 64-bit integer float 4 bytes, little-endian IEEE single-precision floating point type [N] N times the size of type Sequence of N instances of type Field padding and alignment No padding is inserted between fields. Fields therefore have no particular guaranteed alignment (with respect to the start of the stream). General record structure Each record starts with a record header chunk, followed by any number of data chunks (including potentially no data chunks at all), and completed with a record footer chunk. The required presence of a record footer is designed to allow readers to read a recording data stream without having to look ahead into the next record's data. While records may contain any number of chunks, each chunk tag (see General chunk structure below) can appear at most once per record. Readers are not required to support records that contain several instances (or several versions) of the same kind of chunk. General chunk structure Each chunk has the following structure: Type Content Additional information uint16 tag Defines the kind of the chunk. uint16 version Defines the specific format of the chunk payload (together with the tag). Version numbers start with 1. Version number 0 is reserved and not used. uint32 payload size Number of chunk payload bytes (not including the general chunk header bytes). (…) (…) Chunk payload. The presence of the payload size in the chunk header is designed to allow readers to load entire chunks without having to parse them to find the end of the chunk or to skip chunks they cannot read. Record header and footer chunks Record header chunk Type Content Additional information uint16 tag 0x0000 uint16 version 1 uint32 payload size 4 float relative time since last record Number of (usually fractional) seconds that have passed since the last record in the stream. The value in the first record of the stream is ignored by readers. Record footer chunk Type Content Additional information uint16 tag 0xFFFF uint16 version 1 uint32 payload size 0 Data chunks Alignment configuration chunk Type Content Additional information uint16 tag 0x0101 uint16 version 1 uint32 payload size 20 float edge deviation threshold > 0.0 float relevance saturation radius > 0.0 float relevance drop-off radius Greater than relevance saturation radius. float tightness saturation radius > 0.0 float tightness drop-off radius Greater than tightness saturation radius. Alignment supports chunk Type Content Additional information uint16 tag 0x0401 uint16 version 1 uint32 payload size 4 + 28 * number of supports uint32 number of supports […] Support definitions One definition per support, in no particular order. Support definition Type Content Additional information uint64 support anchor identifier float[3] support position from anchor X, Y, Z (meters) float support relevance 0.0 … 1.0 float support tightness 0.0 … 1.0 Spongy snapshot chunks Spongy snapshots are stored as multiple chunks: the spongy snapshot header and, if required, the spongy graph. The spongy snapshot header chunk can appear before or after the spongy graph chunk in the record, and there may be other chunks in between the header and the graph chunks. In order to improve the stream's compactness (and potentially reader performance), the spongy graph can be stored in several alternative ways, individually chosen for each record: as a complete graph definition (that replaces the last known spongy graph), as a graph update (applied to the last known state of the spongy graph read from this stream), or not at all (to indicate that the spongy graph is unchanged from its last known state read from this stream). Readers assume that the spongy graph is initially empty when a recording stream starts. The first spongy snapshot stored in a recording stream usually includes a complete graph definition (but is not required to). Spongy snapshot header chunk Type Content Additional information uint16 tag 0x0201 uint16 version 1 uint32 payload size 36 float[3] head position X,Y,Z (meters) float[4] head orientation X,Y,Z,W (quaternion) uint64 most significant anchor identifier Spongy graph chunk See Graph chunk alternatives below for version, payload size, and payload. Type Content Additional information uint16 tag 0x0202 – Complete graph definition 0x0203 – Graph update uint16 version uint32 payload size (…) (…) Frozen snapshot chunks Frozen snapshots are stored as multiple chunks: the frozen snapshot header and, if required, the frozen graph. The frozen snapshot header chunk can appear before or after the frozen graph chunk in the record, and there may be other chunks in between the header and the graph chunks. In order to improve the stream's compactness (and potentially reader performance), the frozen graph can be stored in several alternative ways, individually chosen for each record: as a complete graph definition (that replaces the last known frozen graph), as a graph update (applied to the last known state of the frozen graph read from this stream), or not at all (to indicate that the frozen graph is unchanged from its last known state read from this stream). Readers assume that the spongy graph is initially empty when a recording stream starts. The first spongy snapshot stored in a recording stream usually includes a complete graph definition (but is not required to). Frozen snapshot header chunk Type Content Additional information uint16 tag 0x0301 uint16 version 1 uint32 payload size 64 float[3] alignment translation X,Y,Z (meters) float[4] alignment rotation X,Y,Z,W (quaternion) float[3] head position X,Y,Z (meters) float[4] head orientation X,Y,Z,W (quaternion) uint64 most significant anchor identifier Frozen graph chunk See Graph chunk alternatives below for version, payload size, and payload. Type Content Additional information uint16 tag 0x0302 – Complete graph definition 0x0303 – Graph update uint16 version uint32 payload size (…) (…) Graph chunk alternatives Writers should choose the most compact representation for a given graph. If the graph is unchanged compared to its last version written to this stream, no graph chunk should be written at all. Readers are required to support any graph chunk representation at any time. Complete graph definition Type Content Additional information uint16 tag See specific uses above uint16 version 1 uint32 payload size 8 + 44 * number of anchors + 20 * number of edges uint32 number of anchors uint32 number of edges […] Anchor definitions One definition per anchor, in no particular order. Each anchor identifier can appear only once in this chunk. […] Edge definitions One definition per edge, in no particular order. Each pair of edge anchor identifiers (1/2 or 2/1) can appear only once in this chunk. Graph update Type Content Additional information uint16 tag See specific uses above. uint16 version 1 uint32 payload size 8 + 44 * number of added or changed anchors + 20 * number of added or changed edges + 8 * number of removed anchors + 16 * number of removed edges uint32 number of added or changed anchors uint32 number of added or changed edges uint32 number of removed anchors uint32 number of removed edges […] Added or changed anchor definitions One definition per added or changed anchor, in no particular order. […] Added or changed edge definitions One definition per added or changed edge, in no particular order. […] Removed anchor identifiers One identifier per removed anchor, in no particular order. Each anchor identifier can appear only once in this chunk. […] Removed edge anchor identifiers One definition per removed edge, in no particular order. Each pair of edge anchor identifiers (1/2 or 2/1) can appear only once in this chunk. Anchor definition Type Content Additional information uint64 anchor identifier uint64 anchor fragment identifier float[3] anchor position X,Y,Z (meters) float[4] anchor orientation X,Y,Z,W (quaternion) Edge definition Type Content Additional information uint64 edge anchor identifier 1 Edge anchor identifiers are stored in slots 1/2 in no particular order. uint64 edge anchor identifier 2 float edge confidence 0.0 … 1.0 Anchor identifier definition Type Content Additional information uint64 anchor identifier Edge anchor identifier definition Type Content Additional information uint64 edge anchor identifier 1 Edge anchor identifiers are stored in slots 1/2 in no particular order. uint64 edge anchor identifier 2"
  },
  "DocGen/Documentation/Concepts/Advanced/Architecture/Managers/IAlignmentManager.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/Architecture/Managers/IAlignmentManager.html",
    "title": "IAlignmentManager | World Locking Tools for Unity Documentation",
    "keywords": "IAlignmentManager The IAlignmentManager interface abstracts the service of translating and rotating the world-locked space to align with the physical world at a discrete set of Space Pins. The alignment concepts are described in detail in an article dedicated to Space Pins . Application interactions with the IAlignmentManager are not generally required. Rather, the helper component class Space Pin , and components derived from it, is provided to handle the minimal bookkeeping involved. Persistence considerations The IAlignmentManager provides a callback notification on post load. Any object registering for load notifications should un-register at the latest before its destruction. For Unity objects, that can be done in OnDestroy. In addition to explicit Save() and Load() member functions, the IAlignmentManager interface provides a persistence hook in the form of RestoreAlignmentAnchor . RestoreAlignmentAnchor searches its database for enough information to recreate the named Alignment Anchor, which has presumably been created and saved in an earlier session. If successful, an AnchorId valid for this session is returned, and the caller can claim ownership for the session. If for any reason the Alignment Anchor cannot be restored, an invalid AnchorId will be returned, and the caller should assume that the named anchor has not been created (nor saved) yet. The post load callback is useful for suggesting an appropriate time to check with the database whether a named Alignment Anchor is now available. See also IAlignmentManager SpacePin SpacePinManipulation SpacePinOrientable SpacePinOrientableManipulation PinManipulator"
  },
  "DocGen/Documentation/Concepts/Advanced/Architecture/Managers/IAnchorManager.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/Architecture/Managers/IAnchorManager.html",
    "title": "IAnchorManager | World Locking Tools for Unity Documentation",
    "keywords": "IAnchorManager The Frozen World engine relies on a network of spatial anchors surrounding the user, from which to calculate the ideal world locked space. The IAnchorManager maintains that network, and supplies it to the engine for processing each frame. There are currently a number of implementations of IAnchorManager, all of which derive from the base class AnchorManager in Assets/WorldLocking.Core/Scripts/AnchorManager.cs. AnchorManager manipulates abstract SpongyAnchors, performing common anchor graph maintenance operations. Specializations interact with platform specific APIs. For example, class AnchorManagerXR manages SpongyAnchors built atop XRAnchors. The Frozen World engine itself is agnostic to the type of anchors used. As the user moves around the environment, AnchorManager grows the graph of anchors according to the following simple but effective algorithm: If the nearest existing anchor is more than X meters from the user then: Add a new anchor. Add edges from the new anchor to all existing anchors less than Y meters from the new anchor. The values of 'X' and 'Y' above are constants in the AnchorManager, as MinAnchorDistance and MaxAnchorDistance respectively. These could be converted to properties, giving more flexibility at the cost of complexity in the WorldLockingContext API surface. However, the current values of 1 meter and 1.2 meters, respectively, have been satisfactory to date. The above algorithm grows the graph of anchors in the space traversed by the user during the initial exploration, eventually settling into a static network. The anchor manager may also persist the anchor graph across multiple sessions. AnchorManager has options to automatically save its anchor graph during the session, load the previously saved graph at startup, or save and load on demand. Persistence availability is dependent on platform support. See also WorldLockingManager IFragmentManager IAttachmentPointManager And in API reference: WorldLockingManager IAnchorManager IFragmentManager IAttachmentPointManager"
  },
  "DocGen/Documentation/Concepts/Advanced/Architecture/Managers/IAttachmentPointManager.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/Architecture/Managers/IAttachmentPointManager.html",
    "title": "IAttachmentPointManager | World Locking Tools for Unity Documentation",
    "keywords": "IAttachmentPointManager The IAttachmentPointManager is the most common World Locking Tools interface for a client application to access. But the attachment point interface is extremely small. It gives opportunity for the client application to perform the four operations available on attachment points. Create Release Move Teleport CreateAttachmentPoint The interesting thing to note here is the delegates passed in as arguments to the create function. Either or both of these arguments may be null, in which case the created attachment point will not receive any notifications corresponding to that delegate. These delegates may not be changed after creation. This should not be a burden, as the delegate itself may fork behavior based on current state. If even that is not possible, then the attachment point must be released and a new attachment point with the desired new delegates created. ReleaseAttachmentPoint When the attachment point is no longer needed, the client application should notify the system via the release API. MoveAttachmentPoint Unlike most spatial anchors, attachment points may move freely through the world, automatically binding to the most relevant anchors at their new positions. As an attachment point moves, its owner should notify the system of its new position. This movement might be from physics simulation, or any other animation technique. TeleportAttachmentPoint Confusingly, teleporting is more closely related to creation than movement. Rather than thinking of teleport as moving to a new location, it is helpful to think of it as ceasing to exist, then beginning existence again in a (possibly) new location. The rule of thumb is, if the object moved continuously from old location to new location, use MoveAttachmentPoint. If it popped into existence in the new location, use TeleportAttachmentPoint. Contexts for creation and teleporting Creation and the conceptually similar teleport take an optional (may be null) parameter of a creation context. The context is an already existing attachment point that gives the system several hints about where in the anchor graph (which may not be fully connected in the case of multiple fragments) to find the best anchor to base this attachment point on. The current implementation of IAttachmentPointManager is in Assets/WorldLocking.Core/Scripts/FragmentManager.cs, which also implements the IFragmentManager interface. Move and teleport via manager or attachment point APIs It may be noticed that, in addition to the move and teleport interfaces described here, there are corresponding methods on the IAttachmentPoint interface. These are equivalent, and whichever is more convenient to the caller may be used. See also WorldLockingManager IFragmentManager IAnchorManager And in API reference: WorldLockingManager IAnchorManager IFragmentManager IAttachmentPointManager"
  },
  "DocGen/Documentation/Concepts/Advanced/Architecture/Managers/IFragmentManager.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/Architecture/Managers/IFragmentManager.html",
    "title": "IFragmentManager | World Locking Tools for Unity Documentation",
    "keywords": "IFragmentManager The fragment manager maintains the mapping of which attachment points are associated with which fragments. While the concept of fragments is important in understanding the World Locking Tools, fragments themselves are generally not interesting outside of the World Locking library. A client application might want to know whether the fragment an object belongs to is currently being tracked, but that information is supplied directly to the attachment point through its AdjustStateDelegate. Likewise, a fragment merge operation will affect the position of an attachment point, but the attachment point will be notified directly of the location modification irrespective of the containing fragment. The fragment manager handles the book-keeping of which fragment an attachment point is created into, and which fragment it might move into because of refit operations. It also implements the refit operation notifications. However, all these operations are behind the scenes. The client application will generally not interact directly with the IFragmentManager. The current implementation of IFragmentManager is in Assets/WorldLocking.Core/Scripts/FragmentManager.cs, which also implements the IAttachmentPointManager interface. See also WorldLockingManager IAnchorManager IAttachmentPointManager And in API reference: WorldLockingManager IAnchorManager IFragmentManager IAttachmentPointManager"
  },
  "DocGen/Documentation/Concepts/Advanced/Architecture/Managers/WorldLockingManager.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/Architecture/Managers/WorldLockingManager.html",
    "title": "WorldLockingManager | World Locking Tools for Unity Documentation",
    "keywords": "WorldLockingManager The World Locking Tools for Unity is managed by the WorldLockingManager . There is only one WorldLockingManager in an application. The manager may be configured by setting of properties in the Unity editor's inspector, or at runtime. See WorldLockingContext . In addition to managing user options, the WorldLockingManager provides access to three interfaces: IAnchorManager - Build and maintain the network of spatial anchors used as input to the Frozen World engine, feeding them into the engine every frame. IFragmentManager - Maintain grouping of attachment points into fragments, effecting refit operations. IAttachmentPointManager - Creating, releasing, and moving attachment points. IAlignmentManager - Specifying alignment of World Locked Space with physical space. These are described in detail in subsequent sections. See also IAnchorManager IFragmentManager IAttachmentPointManager IAlignmentManager And in API reference: WorldLockingManager IAnchorManager IFragmentManager IAttachmentPointManager IAlignmentManager"
  },
  "DocGen/Documentation/Concepts/Advanced/AttachmentPoints.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/AttachmentPoints.html",
    "title": "Attachment points | World Locking Tools for Unity Documentation",
    "keywords": "Attachment points First and foremost, World Locking Tools provides a stable world-locked coordinate system, the world locked space. This space remains as fixed as possible relative to the physical world. And objects within world locked space enjoy capabilities requiring such a stable frame of reference, such as maintaining relative placement to other virtual objects, simulation of natural physics laws, kinematics, and other animation techniques. In fact, depending on the needs of the application, world locked space may be sufficient for some or all scene content. But while world locked space will remain optimally aligned with physical space, there are situations to be described later in which it is not possible for multiple points in world locked space to remain both fixed in their common coordinate space and fixed relative to reference points in the physical world. For a trivial but illuminating example, suppose that the sensor maps one anchor to the position (3,0,0) and another to the position (-3,0,0). Later, as sensor refinements are processed, it is established that the two coordinates should have been (3,0,0) and (-2,0,0). There is clearly no rotation and offset that can be applied to the camera which will transform a 6 meter distance between the two anchors into a 5 meter offset. Using Unity's spatial anchor system, the two anchors would just silently move into their newly scanned positions. But World Locking Tools guarantees that in world locked space, non-moving objects will \"mostly\" never move. And in fact, any motion is up to the owning application. Another common \"abnormal\" condition is loss of tracking . When tracking is lost in one environment (for example, room) and regained in another environment, then at first there is no information linking the two spaces. The coordinates in one space are meaningless relative to coordinates in the other space. The attachment point paradigm allows the application to gracefully handle the initial phase when spatial information about the old space is unknown (for example, by hiding the objects in that old space), as well as recovering when the spatial relationship between the two spaces does become known. More discussion can be found of these special conditions and the refit operations which WLT performs to handle them. The discussion here is focused on the contract between WLT and the application on smoothly resolving such conditions. Attachment points are the codification of that contract between World Locking Tools and the application. An application creates and positions attachment points using World Locking Tools APIs. When a correction in the position of an attachment point is determined by a refit operation , the application is notified via callback of the new position in world locked space that will keep the attachment point at its old position in physical space. Some scenarios in which World Locking Tools attachment points might be the solution: It is more important to remain fixed relative to features in the physical world than relative to other virtual objects. Objects are placed in the world at runtime rather than in Unity at design time, and it may be important to reconcile relative positions separated by disruptions in tracking (see discussion of fragments ). It is important to manage an object's visibility based on the validity of its physical space positioning. Using attachment points Use of attachment points is fairly straightforward. Client responsibilities For each attachment point required, the client must: Request attachment points from the system. See CreateAttachmentPoint Dispose of attachment points that are no longer needed. See ReleaseAttachmentPoint Apprise the system of the attachment point's initial position and movement. See CreateAttachmentPoint , MoveAttachmentPoint , and TeleportAttachmentPoint Handle refit operation events. See below. World Locking Tools responsibilities World Locking Tools will notify the application, for each affected attachment point, when either of the following occurs: The validity of the attachment point's physical world tracking changes. Its coordinates in world locked space change due to a refit operation, which may be either a fragment merge or a refreeze . These notifications are broadcast through delegates which the application hands to the WorldLockingManager on creation of the attachment point. How to best handle these notifications is left to the application, as each will have its own considerations. Sample handlers, which are used internally and may be either used as is or used as a starting point for custom implementations, are provided. Sample implementations For an attachment point that is to remain fixed in the physical world, and which should hide its contents when its tracking is not valid, AdjusterFixed implements the AdjustStateDelegate with its HandleAdjustState member,and the AdjustLocationDelegate with its HandleAdjustLocation member. A similar component for moving objects is in AdjusterMoving . It is worth noting that supplying either or both these delegates is optional, and in fact reactions to state and location changes may be implemented based on polling rather than events. But unless their use is impossible due to specifics of the application, the event-based system using delegates forms a much more efficient implementation. The recommendation is that you start with the AdjusterFixed component (or very similar AdjusterMoving), and modify the handlers HandleAdjustLocation and HandleAdjustState to suit your applications needs. See also Fragments Refit operations"
  },
  "DocGen/Documentation/Concepts/Advanced/CoordinateSpaces.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/CoordinateSpaces.html",
    "title": "Coordinate spaces | World Locking Tools for Unity Documentation",
    "keywords": "Coordinate Spaces in World Locking Tools for Unity The World Locking Tools for Unity (WLT) ultimately provide a stable world-locked coordinate system, with configurable mapping to the physical world. This transformation from the shifting, non-persistent, and arbitrary native Unity global coordinate space, to the world-locked space happens in steps. Each intermediate coordinate space has a name. To some degree, all names are somewhat arbitrary. These are the names of the intermediate spaces as used in the WLT documentation and code. Spongy Space - The Unity global coordinate space you would get without WLT. A stationary object in Spongy Space (one whose coordinates are unchanging) will drift relative to the physical world. Play Space - A position/rotation transformation of Spongy Space, it can be used to implement features like teleport. Locked Space - The world-locked space as computed by the FrozenWorld Engine and implemented by WLT. A stationary object in Locked Space will remain fixed relative to features in the physical world. However, the numeric values of its coordinates are arbitrary. Pinned Space - A transformation of Locked Space to give coordinates a desired mapping to the physical world. An object with position (X,Y,Z) will appear at a known predetermined position relative to physical world features. Frozen Space - A position/rotation transformation of Pinned Space, allowing the application to apply an arbitrary transform to the camera hierarchy. As a convenience, the WorldLockingManager supplies transformations between all of these spaces. For example, the most useful of these is FrozenFromSpongy , a Pose which transforms from Spongy Space to Frozen Space. This is useful when converting coordinates returned by native APIs, which have no notion of WLT and so operate in Spongy Space, into Frozen Space. Note that when using MRTK , no such translations are needed. Its coordinate space is already Frozen Space. Other conversions between the various spaces are available on the WorldLockingManager , but are not generally needed. See also A primer on Unity coordinate spaces (without WLT) as relates to AR/MR . Explanation of the SessionOrigin"
  },
  "DocGen/Documentation/Concepts/Advanced/Fragments.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/Fragments.html",
    "title": "Fragments | World Locking Tools for Unity Documentation",
    "keywords": "Fragments As mentioned, in World Locking Tools terminology, a fragment is a collection of things which exist in known relation with each other in the same coordinate space. However, there is generally no meaningful spatial relationship between different fragments. A simple example might help clarify. Imagine two well-lit rooms, connected by a long dark hallway. The head-tracked session begins in the first room. The room being well-lit and with appropriate furnishings, the user quickly and easily scans and maps it. Objects in the room, as well as any anchors created, are all in known positions relative to the head and relative to each other. Since the second room hasn't even been visited yet, there is still no knowledge about its contents. Now the user proceeds into the dark hallway. There, tracking is lost immediately because of the poor lighting. The user passes through the hallway to the second room. In the second room, tracking is again restored and the user quickly scans the room, adding some anchors for good measure. At this time, both rooms have been scanned, and the contents of each room is known relative to the other contents of the same room, but there is no knowledge about one room relative to the other. The hallway could have been of any length, and it may have curved. These two rooms, then, are forming isolated islands of spatial relationship. The group of inter-related objects in each room are herein called \"fragments\". And in our hypothetical situation, our session now contains two fragments, one for each room. Because no tracking data was acquired in the hallway, there is no corresponding hallway fragment. All of the objects in both rooms have coordinates, but the two coordinate systems are unrelated. When the camera is in the second room, the head is placed in the same coordinate system as all the other objects in the second room. This allows those second room objects to be rendered appropriately relative to the user's perspective. However, the objects in the first room are in an unrelated coordinate system. Depending on the length of the unmapped hallway, they might be meters or tens of meters away, or off to the side if the hallway bends. Therefore, without further info connecting the two spaces, the system doesn't have enough information to meaningfully place the first room's objects in the user's view. But the system does know it hasn't enough info to render those objects correctly, and through the attachment point mechanism can inform the application of that condition. See also Attachment points Refit operations"
  },
  "DocGen/Documentation/Concepts/Advanced/Persistence.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/Persistence.html",
    "title": "Persisting spatial coordinate systems | World Locking Tools for Unity Documentation",
    "keywords": "Persisting spatial coordinate systems In general, the benefits of World Locking Tools' persistence capabilities are of more interest than the details of their implementation. This article will therefore begin with a discussion of the experiences that World Locking Tools persistence enables. After that comes a look at how World Locking Tools State persistence may be managed. It will then close with a brief sketch of what data is saved and loaded. World Locking Tools across sessions As defined elsewhere , the Frozen State is all data necessary to resume the current world-locked stable space. The primary utility of World Locking Tools' persistence is in allowing the benefits of a preliminary session's work, scanning an area and aligning virtual space to the real world, to be used in subsequent sessions. Restoration of this state allows subsequent sessions to forego tedious or time consuming setup and get straight to the focal experience. Saving World Locking Tools State Before it can be loaded, the Frozen State must be saved. The most straightforward way to save the Frozen State is to enable AutoSave on the World Locking Tools Manager, either in the Unity inspector on the World Locking Tools Context , or at runtime via script. Setting World Locking Tools Manager state via script is performed by first getting the state, changing it in any desired way, and then setting the state back as a block. For example, to toggle the AutoSave feature: var settings = WorldLockingManger.GetInstance().Settings; settings.AutoSave = !settings.AutoSave; WorldLockingManager.GetInstance().Settings = settings; If the AutoSave feature goes from enabled to disabled during a session, no further periodic saves will be attempted. If it goes from disabled to enabled, periodic saves will be begun or resumed. The AutoSave feature will keep an up-to-date saved state by periodically saving the current state asynchronously. If more control over the timing of the saving of state is required, then the AutoSave may be set to false, and manual saving done via script. The asynchronous save is easily triggered, as: WorldLockingManager.GetInstance().Save(); As the save is asynchronous, other attempts to invoke a Save() while a previous is still under way will be ignored. Loading Frozen State Having saved off a Frozen State, it might be desired to reload World Locking Tools back into that state, either in a subsequent session or even later in the same session. As in saving Frozen State, there are two paths for loading state. If the AutoLoad flag on the World Locking Tools Manager is enabled, then any previous saved state will be loaded at startup time. If there is no saved state to load, no error is generated and startup proceeds as if the flag wasn't set. Setting the AutoLoad flag from false to true (for example, via script) at runtime will have no effect. The AutoLoad either happens at initial load, or doesn't happen at all. However, a load may be initiated from script at any time through the World Locking Tools Manager's Load function: WorldLockingManager.GetInstance().Load(); As with the Save, the Load is performed asynchronously. Any subsequent calls to Load while one is still ongoing will be ignored. What is saved? The data required to reconstruct the World Locking Tools mapping, that is the alignment of the virtual world to the real world, can be broken into three groups. Spatial Anchors - The underlying network of spatial anchors created and maintained internally by World Locking Tools' Anchor Manager , supply the requisite binding to the real world. Those anchors are persisted via the platforms underlying storage mechanism. Engine State - Engine state is persisted to allow the engine to resume its current mapping. Restoring this state removes such indeterminacies as the initial pose of the head in the previous session(s). Space Pinning - If the application has applied any further Space Pins to force alignment of modeling coordinates to the real world at a discrete set of points, that mapping is also persisted. What is not saved? Only state is saved. In particular, settings are not saved. Any configuration changes by the application, for example changes made through the WorldLockingManager API, are reset each time the application starts up to their values as set in the Unity Inspector, or if they aren't set in the Inspector then to their default values in code. For example, say the application wants to present the user with the option to AutoSave World Locking state, and have the user's preference persist across sessions until changed. Then the application must: Present the user with UX for setting AutoSave preference (presumably with other application settings). Forward the user's preference to the WorldLockingManager Record the preference to file (presumably with other application settings). On application startup, load the saved preference (if any has been saved) and forward to WorldLockingManager. See notes in WorldLockingContext regarding timing issues when mixing state setting between assets and script. See also Space Pins Attachment points Fragments Refit operations"
  },
  "DocGen/Documentation/Concepts/Advanced/RefitOperations.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/RefitOperations.html",
    "title": "Refit operations | World Locking Tools for Unity Documentation",
    "keywords": "Refit operations Refit operations in World Locking Tools are when the system determines that a repositioning of some of the objects in the scene would better register those objects with their physical world anchors. This section will attempt to give further insight into the situations leading up to refit operations, and the mechanics of the operations themselves. It is important to stress here that refit operations occur infrequently. The default error tolerances triggering a refreeze operation are customizable by the application, but normally MR environments trigger refreeze operations only in extraordinary circumstances. Conditions that might contribute to the need for a refreeze include: Loss of tracking due to poor environment. Fast movement of the head influencing environment scanning. Dynamic environments. Loop closure (that is, accumulating tracking errors on a roundabout path leading back to a previously visited spot). As can be seen, the root cause of these issues is poor tracking, or tracking errors. With reasonable environments producing reasonably good tracking, and especially after an initial scan of the space, refit operations will become exceedingly rare. Fragment merge Many conditions may lead to the existence of multiple fragments, the most common cause being temporary loss of tracking. Fragments are defined as collections of objects sharing a common coordinate space, but where the coordinate space of one fragment is indeterminately located relative to another fragment. When enough new sensor data is received and processed that the contents of two previously unrelated fragments may now be positioned correctly relative to each other in the same space, a fragment merge may be performed. The new coordinate space into which the contents of the two (or more) fragments will be merged is arbitrary. It is mentioned here that the final coordinate space will be that of one of the spaces, which is only relevant because it means that all of the fragments being merged except one, the destination fragment, will need their coordinates adjusted. The contents of the fragment chosen as the final target of the merge will be unaffected. An adjustment transform is computed by the system for each of the source fragments being merged. The AdjustLocationDelegate for each attachment point in those fragments will be called with the adjustment transform. Again, attachment points in the destination fragment will not be affected, nor have their AdjustLocationDelegates called. The two rooms connected by a dark hallway scenario in the description of fragments is an example of one such situation. During the initial phase, both fragments (rooms) have been scanned, but there is no information available regarding the relative positions of the two fragments. So the coordinate system that the contents of each fragment is placed in is arbitrary, as long as it is constant across all objects in that room. For example, the contents of each room might be in a coordinate system with its origin at the southwest corner of that room. The coordinates of two objects in the same fragment indicate the positions of the two objects relative to each other, but the coordinates of two objects in two different fragments tell nothing about their relative positions. When more information is acquired, then there is an opportunity to adjust the coordinates of the contents of the second fragment so that the coordinates of its contents are meaningful relative to objects in the first fragment. For example, the hallway light might be turned on and the hallway traversed, bridging the gap between the two fragments. If the coordinates of all objects in both rooms are adjusted to be in the same consistent coordinate space, there is no longer any real distinction between the two fragments, and so their contents may be considered to all belong to a single common fragment. This operation of collapsing multiple fragments into a single fragment is a merge operation . It's important to note here that for normal Unity objects placed in the scene in world locked space, the merge operation will have no effect. Movement of objects from refit operations only happens through attachment points. Refreeze operations Another situation arises is when the positions of the anchors are refined over time. It becomes apparent that a rotation/offset transform is no longer adequate to compensate for the difference between the initial rough anchor positions and the more recent improved positions in the physical world. Keep in mind that the anchors themselves are constantly moving relative to each other in spongy space. But the attachment points derived from these anchors are fixed in world locked space. When the system recognizes that the attachment points that it manages could be better registered with the physical world, because of updates to anchor positions, then it has another opportunity for a correction event. This adjustment of attachment point positions to reflect new sensor data is known as a refreeze operation . Whereas in a merge operation the contents of a fragment are all adjusted by a single transform to merge coordinate spaces of two fragments into a single unified space, a refreeze adjusts each attachment point individually based on the updated positions of the anchors influencing it. As in the merge operation, each attachment point is informed of its computed adjustment transform via its AdjustLocationDelegate. If conditions are right, the refreeze might also perform a merge operation. That merge will be considered an implicit part of the refreeze: There will be no separate events generated for the merge, and the adjustment transform delivered as part of the refreeze will include both the individual adjustment due to anchor movement and the fragment adjust due to the merge. Reacting to refit events In either merge or refreeze, the reaction to refit events is up to the application. More precisely, it is up to each of the attachment point handlers, as different object types might react differently. Typically, the objects influenced by the attachment point will be moved by the adjustment transform via their GameObject.transform. Motion might instead be implemented by some other mechanism, such as manually moving vertices. It might even be advantageous for some applications to discard objects affected by a merge and begin a new cycle of creation. The point is that World Locking Tools has no dependence on how or whether the application reacts to refit operations. It is entirely up to the application developer's needs. The preferred mechanism for notification and reaction to refit operations is the Attachment point . More details and options are discussed there. See also Attachment points Fragments"
  },
  "DocGen/Documentation/Concepts/Advanced/SessionOrigin.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/SessionOrigin.html",
    "title": "Understanding the ARSessionOrigin | World Locking Tools for Unity Documentation",
    "keywords": "Understanding the SessionOrigin The SessionOrigin is a relatively new implementation, introduced in AR Foundation, but the idea has appeared in camera rigs going back decades of rendering engines. You might be familiar with it as the MRTK Playspace node. It is quite powerful, but unfortunately poorly explained and consequently poorly understood. What is the SessionOrigin? The SessionOrigin is just a Transform object to which the camera is attached. Most plainly, it allows placement of the camera in the virtual scene. More subtly, it defines a special coordinate space. As is usual with the transform parent-child relationship in Unity (and all modern rendering engines), \"moving\" the parent will \"move\" the child. What's meant by the term \"move\" in this context is that a change in the global pose of the parent will change the global coordinates of the child, and when the global coordinates of one object change, that object will appear to have moved relative to objects whose global coordinates have not changed. The camera is rather special in this sense, as it is not rendered. It determines the renderer's viewpoint. A concrete example might clarify this. Simplest example of SessionOrigin Imagine a very simple scene, in which the camera is at the origin at startup (as is normal in AR applications), and there is a single red sphere placed on the Z-axis 10 meters in front of the camera (position=(0,0,10)). For whatever reason, imagine that we want the user to start 1 meter away from the sphere instead. We have two interesting options: Move the camera to new position (0,0,9). Move the sphere to new position (0,0,1). It's fairly obvious that the two options are ultimately equivalent without any other context. In both cases, at startup the sphere is 1 meter in front of the camera. The only difference is the absolute global coordinates of the two objects. Their relative coordinates, that is the vector between the two, is the same in either case. If we want to use option 1., how would we go about it? If we set the coordinates of the camera, they will be overwritten by the tracking system. Instead, we attach the camera to a parent object, then move the parent. The tracker sets the local pose of the camera, which moves it relative to the parent. The parent is now the SessionOrigin. Why move the camera instead of the sphere? In this simple case, the two options are clearly interchangeable. But remember that \"the sphere\" really represents \"everything in the scene but the camera\". As the complexity of the scene grows, moving everything becomes more complicated. Moving the camera, via the SessionOrigin, is always the exact same operation. Furthermore, there are types of objects which are difficult or impossible to reposition, such as particle systems or navigation meshes. But even if none of those are involved, there are clear advantages to changing the coordinates of a single object in the scene, the SessionOrigin, versus changing the global coordinates of everything else. The SessionOrigin shouldn't move everything Consider again our simplest example. But this is an AR application, so along with the rendered red sphere, the user will also see the physical environment. In the interest of simplicity, our physical environment will be limited to the single green chair as shown. Now, when we move the camera via the SessionOrigin, we have moved it relative to the red sphere, but obviously we haven't picked up the user and moved them relative to the green chair. The sphere now appears closer, but the chair is in the exact same position. What if there is an anchor on the chair seat? Should the anchor move with the red sphere, or remain fixed relative to the chair seat? The whole point of the anchor is to remain fixed relative to the physical world, so clearly it should stay with the chair. Another example is the spatial mesh. That's the mesh generated to provide a virtual version of the physical environment for context, ray-casting, etc. We definitely want the spatial mesh to remain fixed to the physical world. Further examples range from hand meshes to eye gaze vectors. All share the common trait that if the coordinates of the camera are adjusted (transformed), then the coordinates of those objects should receive the same adjustment. So conceptually, all of those objects that move in coordination with the camera, are also attached to the SessionOrigin. When the SessionOrigin is moved relative to global objects like the red sphere, all of those objects are brought along with it. It's important to stress that this is independent of the motion of the camera due to head tracking. The tracker moves the camera relative to the SessionOrigin. A slightly more mathematical explanation Unity's global coordinate system is somewhat arbitrarily located by default in an AR application. Aside from aligning the gravity vector (Y-axis) with \"up\", the position and orientation are entirely determined by where the tracker places the camera at startup. While that may be fine for many applications, a wide range of possibilities are opened up by being able to remove that arbitrariness of the global coordinate space. Looking back at the previous example, imagine that it is significant for the application that the virtual red sphere be positioned relative to the physical chair as shown. We can accomplish that by adjusting the SessionOrigin. If we want the sphere at (0,0,10) to be 1 meter along the X-axis from the chair, then we want the chair to be at (-1,0,10). If we determine the camera to be 2 meters back from the chair directly along the negative Z-axis when the camera is at the origin, then the chair is currently at (0,0,2). (Remember, physical objects have no innate coordinates, only coordinates implied by proximity to the camera and virtual objects). However, if we set the SessionOrigin transform to (-1,0,8), now the camera's position is (-1,0,8). The chair, 2 meters directly ahead, is at (-1,0,10). And the red sphere, at (0,0,10), will appear 1 meter right of the chair as desired. So we have effectively used the SessionOrigin transform to reposition Unity's global space so that the red sphere, and all other global objects, just happen to appear in the correct position relative to the physical world. This simple but powerful mechanism for aligning Unity's global coordinate space to the physical world can be leveraged to support complex layout, persistence of coordinate spaces, coordinate spaces shared across devices, and more. See also Unity blog introducing the SessionOrigin AR Foundation description of Session Origin"
  },
  "DocGen/Documentation/Concepts/Advanced/SpacePins.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/SpacePins.html",
    "title": "Space Pins | World Locking Tools for Unity Documentation",
    "keywords": "Space Pins The problems to solve The scale error While the traditional spatial anchor approach to aligning Holograms with real world features works great on a small scale, it struggles as the scale grows to encompass more than a meter or so. Scale error in head tracking space means that even if a spatial anchor keeps one end of a virtual object, sized only a few meters long, perfectly aligned with a real world feature, the other end is likely to be misaligned with a corresponding real world feature. This misalignment is because the distance traveled through head tracked space tends to differ from the distance traveled through physical space with an error bound of +-10%. The actual error is often less (it depends on many environment and device characteristics), but will generally be significant, and grow without bounds as the scale of the project grows. Put another way, if a user wearing a HoloLens walks 10 meters in the real world, the distance traveled in virtual space, as reported by the head tracker, will be between 9 meters and 11 meters. If the user walks 50 meters, the error grows to +-5 meters. The farther the user walks, the greater the error grows. Thus, a 10-meter beam (in modeling space) with one end point perfectly aligned to the zero end of a tape measure in real space will have the other end registered to the tape measure at somewhere between 9 and 11 meters. For the same reasons, multiple objects, each world locked using spatial anchors, will be different distances apart in virtual space than in real space. The arbitrary coordinate system There is an another concern. The Unity coordinate system in HoloLens is indeterminate. It is based solely on the head pose at the start of the application. This arbitrariness is not an issue for many tasks. If the goal is to cast a ray into the spatial mapping of the room and place a Hologram at the hit position, then the numerical values of the hit position are irrelevant. Likewise, when popping up UX elements around the user, the absolute coordinates to place a UX element don't matter, only the coordinates relative to the user. However, more involved scenarios can be complicated by the unpredictable coordinate system. Loading a large collection of objects, for example a user's desktop or an entire office room, into virtual space with a fixed relation to physical space, requires some compensating transform to align the modeling space objects with the head-based coordinate frame. That compensation is often done by attaching all objects to a single Unity transform, and adjusting that single transform to position and orient the virtual objects in alignment with the real world. Equivalently, a single transform in the camera's hierarchy can be used to realign the camera so that when the user is seeing a real world reference point, a virtual object with the desired modeling coordinates will appear overlaid on that feature. The solution The Space Pinning feature addresses both of these issues at once. It does so by leveraging both the world-locked nature of the World Locking Tools global space, and the arbitrariness of that space. Aligning Unity space with the real world World Locking Tools at its core provides a stable world locked coordinate system. A virtual object placed into World Locked Space registered with a real world feature will remain registered with that real world feature over time. But there are an infinite number of spaces that satisfy that goal. In fact, given one world-locked space, transforming it by any arbitrary position and rotation produces another equally valid world-locked space. The Space Pin feature applies another constraint that removes the indeterminate nature of the world-locking transform. That constraint is that when \"near\" a Space Pin, the pose of that Space Pin in world-locked space will be the same as the pose of the Space Pin in modeling space. Consider a cube in a Unity scene modeled at global coordinates of (0, 0, 1). When the scene is loaded into HoloLens, the cube will appear 1 meter in front of the initial head pose. Depending on the initial head pose, that might be anywhere in the physical room. The Space Pin allows that cube to be locked to a real world feature in the room, for example, the corner of a specific desk. Unlike locking the cube with a spatial anchor, the Space Pin moves the entirety of Unity space such that the cube is aligned with the desk corner. So, for example, other desktop items modeled relative to the cube in Unity will be dispersed properly across the real desktop. Addressing the scale error While a single Space Pin removes the indeterminacy of the relation between virtual coordinate and the real world, it doesn't address scale error. That is, while it may have moved the origin to a physical world aligned position and orientation, walking 10 meters in the real world might still only move the user 9 meters in virtual space. For this, multiple Space Pins provide the complete solution. When the user is near any specific Space Pin, the world will be aligned according to that Space Pin. The other Space Pins will be misaligned, but being more distant, that generally proves to be acceptable, and often imperceptible. As the user moves between Space Pins, a smooth interpolation minimizes the scale error at any given point in space. With an adequate density of Space Pins as reference points, misalignment of real world and virtual features is reduced to the order of head tracker error. While the required density of Space Pins depends on both the tracking quality the environment supports and the precision requirements of the application, some numbers here might help set expectations. In an office environment, with adequate lighting and visible features to track, a spacing of 10 meters between Space Pins reduces error from an accumulation of 10-20 cm over 10 meters, down to millimeter errors (max error l.t. 0.5 cm, 0.0 cm error at endpoints). Persistence The Space Pin feature works in tandem with the rest of World Locking Tools' persistence. There are both manual calls for invoking saving and loading from script, and flags for automated saving and loading per session. When enabled, the AutoSave/AutoLoad feature on the World Locking Tools Manager will allow the full spatial alignment of the virtual world to the real world to be restored on subsequent sessions. In practice, persistence means that a single or small number of preliminary sessions may be used to establish an adequate scan of the physical environment, and alignment of that physical environment with Unity's modeling coordinate space. Subsequent sessions will then load the virtual environment correctly aligned with the real world without further user action required. Interpolation and extrapolation Interpolation and extrapolation are both techniques for estimating data values where no direct measurement has been made. The space pins, as discussed so far, are locations where measurements have been made. The virtual coordinates are the desired coordinates, and the physical coordinates are measured coordinates we want those virtual coordinates to appear at. The system performs interpolation, but not extrapolation, as discussed below. In general, interpolation is safer and more stable than extrapolation. The piecewise linear interpolation provided will fulfill most applications' needs. Extrapolation is less safe, and its ideal implementation generally requires knowledge at the application level. It is therefore left for the application to handle extrapolation as described below. Without the application adding extrapolation pins, outside the bounds of the pins the space is pinned exclusively by the value at the nearest boundary. If there are only two pins, A and B, then as the user moves from A to B the pinning blends between the alignment specified by A and that specified by B (interpolation). But when the user passes B then the pinning locks to exactly that specified by B (constant extension). Interpolation In the 2D region between pins, the spatial localization is linearly interpolated. If the space pins are accurately placed, and the tracking error is evenly distributed over the region, then the correction applied in between the space pins will be exactly correct. It should be stressed here that the assumption of equal error distribution is exactly not correct. However, as an approximation, the linear model provides excellent correction results. Extrapolation The system provides no built-in extrapolation service, using constant value extension outside the convex hull of space pins. This approximation is equivalent to assuming, incorrectly of course, that there is no scale error outside the application provided space pins. However, if the application has knowledge about the error distribution, or is satisfied with an estimate, it can create any extrapolation desired by adding more space pins in the periphery. Extrapolation example Consider a scene with four space pins, placed in a square with edges 4 meters long. Now, let's say that the actual space the user will be moving around in is 12 meters x 12 meters, with the physical markers corresponding to the four pins surrounding the center of the space. If the application is satisfied with a constant error approximation, then it has all the information it needs to add four or more space pins to provide coverage over the entire 12x12m space. We'll label the pins at the corners of the 4x4 square by their cardinal directions, NE, NW, SW, and SE. We'll also label the virtual positions at each point virtualNE etc., and the physical positions at each point physicalNE etc. One strategy would be to add outer cardinal points creating a 12 meter x 12 meter square surrounding the inner square, by adding four more cardinal points, outerNE, outerNW, outerSW, and outerSE. The virtual and physical positions of each of these is simple to compute. Taking outerNE for example: virtualOuterNE = virtualNE + (virtualNE - virtualSW); physicalOuterNE = physicalNE + (physicalNE - virtualSW); Creating an extrapolation space of 20x20 meters only changes the scale of the delta applied: scale = (outerSize - innerSize) / innerSize / 2; virtualOuterNE = virtualNE + (virtualNE - virtualSW) * scale; physicalOuterNE = physicalNE + (physicalNE - virtualSW) * scale; With an outerSize of 20 m, and an innerSize of 4 m, the scale would be 2. An alternate strategy might be to add eight more points in addition to the corners as shown below. Computing the new pin locations from the existing ones is exactly as above. Be cautioned that, while it is true that adding more pins generally improves stability, it does not necessarily improve accuracy. Aligning a subset of the scene The discussion so far pertains to the global AlignmentManager, owned and managed by the WorldLockingManager.GetInstance(). As previously described, this pins the entire global Unity coordinate space to physical features at strategic reference points. However, there are times when applying the same concept to a subset of the scene. For example, consider a scenario in which annotations for two automobiles are to be loaded. The exact placement of the two physical automobiles can't be known ahead of time, as it might vary according to layout of different dealerships. However, once one of the physical vehicles has been deployed, the positions of all component parts relative to that deployment pose is known. In this scenario, then, Space Pins can be used to pin the virtual chassis and annotations for each of the vehicles independently. The entire virtual representation of each of the vehicles can be setup in Unity, and then mapped onto the physical vehicle at runtime. This alignment might be manual using MRTK UX or automated using QR codes or any other strategy. Regardless of how the data of the correspondence between virtual and physical reference points is determined, once fed to the WLT via the Space Pins API, WLT will keep the virtual and physical objects aligned in a perceptually optimized manner. In the case of aligning the global coordinate space, the alignment happens by manipulating the Adjustment node (generally the parent of the parent of the camera). That node should be considered reserved for the WLT's use. Any other tampering with that transform will result in undefined behavior. Likewise, when aligning a subtree, the alignment needs to own a transform, at the (sub)root of the subtree to be aligned. Any external tampering with that transform will result in undefined behavior. Before the independent spaces are pinned, they will be dragged along as the global space is pinned. However, once an independent space is pinned, it is considered pinned to the physical world, and so subsequent modifications to the pinning of the global space to the physical world will not affect it. See also Space Pin Sample Ray Pins Sample Also see Attachment points Fragments Refit operations"
  },
  "DocGen/Documentation/Concepts/AdvancedConcepts.html": {
    "href": "DocGen/Documentation/Concepts/AdvancedConcepts.html",
    "title": "Advanced capabilities of World Locking Tools | World Locking Tools for Unity Documentation",
    "keywords": "Advanced capabilities of World Locking Tools Some definition of terms might be helpful before diving deeper into World Locking Tools' more advanced usage. These concepts are discussed more thoroughly in subsequent sections of this documentation, including actions necessary for a developer wanting to manually leverage these capabilities. Persistence is the saving of World Locking Tools state from earlier sessions to enhance subsequent sessions, by leveraging the state collected and computed in the earlier sessions, rather than requiring it to be collected or computed again. Space Pins are a discrete and sparse set of points at which the World Locked Space may be mapped to modeling coordinates. In addition to allowing objects modeled in Unity's coordinate space to be aligned with the real world, they provide a solution to the tracker's \"scale problem\". Attachment points are special markers in the world which remain optimally registered to the physical world through infrequent adjustment events. A fragment is a collection of things which exist in known relation with each other in the same coordinate space. In contrast, there is generally no meaningful spatial relationship between different fragments. These are elsewhere referred to as \"tracker islands\". Refit operations are infrequent adjustment events, at times when additional sensor data enables an improved registration of virtual objects with the physical world, but only at the cost of moving them within world locked space. There are two types of refit operations. Merge operations are the repositioning of the entire contents of a fragment uniformly into a common coordinate space with another fragment. Refreeze operations are the repositioning of individual objects within a fragment to account for movement of the supporting anchors. See also Coordinate spaces SessionOrigin Persistence Space Pins Attachment points Fragments Refit operations"
  },
  "DocGen/Documentation/Concepts/BasicConcepts.html": {
    "href": "DocGen/Documentation/Concepts/BasicConcepts.html",
    "title": "The basic idea | World Locking Tools for Unity Documentation",
    "keywords": "The basic idea Inside-out head tracking systems are an amazing new technology. At their strengths, they are almost magical. But they have their weaknesses too. Inside-out head tracking systems, like those in the HoloLens, are good at telling where the head is relative to nearby physical features. Equivalently, they are good at telling where real-world features are relative to the head. But they are not as good at telling where the head is relative to where the head was. When the head moves from point A to point B, the tracking system will generally be slightly wrong about how far the head has traveled. That means the tracking system will be incorrect about the distance between points A and B. This effect is frequently and confusingly called \"the scale problem\". Then when the head travels from point B back to point A, it will again be wrong about the distance traveled. It will be impressively close to correct, but noticeably incorrect. This effect is also referred to as \"drift\". These problems are discussed more in this FAQ . The point is that the World Locking Tools can fix these problems. In the latter case, of drift, the World Locking Tools can recognize that the head is back near point A, from the physical features around point A, and correct the head's coordinates. In the former case, of the scale problem, the World Locking Tools can take input from the application to know where point B is relative to point A, and correct that distance traveled as well. To understand further how the World Locking Tools resolves these issues, some extra terminology will be helpful. Spongy and world locked spaces Spongy space At the core of World Locking Tools is an optimization engine. It takes as inputs a graph of currently active spatial anchors in the world, along with the current head tracking information. This input is commonly referred to, within this and related documentation and code, as the Spongy state . The spongy state is so named because it is constantly in flux. The spatial anchors are always in motion relative to each other, and within their native spongy coordinate space, as incoming sensor data refines their state. This spongy space is the only coordinate system previously available in which the mixed reality application developer could work. World locked space From the spongy state, the World Locking Tools engine computes a stable space, which optimally aligns the spongy space with the physical world. This stable space is referred to as World locked space , and its full state as the frozen state . It is important to realize that both spongy space and world locked space are rigid cartesian coordinate systems, and in fact differ from each other by only a rotation and offset. However, the transform from spongy space to world locked space changes each frame, as new sensor data is processed. The difference between the two spaces is that, while incoming sensor data is free to refine (that is, move) spatial anchors relative to each other and the head in spongy space, world locked space is chosen to minimize such movements. This difference allows scene objects placed in world locked space to appear fixed in the physical world without being attached to individual spatial anchors. Each frame the engine computes the world locked space in which the underlying anchors are most stable. That is, the world locked space in which virtual objects stay optimally aligned with real world features. This transform is applied to the scene each frame by adjusting the local transform of a parent of the camera in the scene graph. Since the camera defines the original spongy space, inserting this \"world-locked from spongy\" transform into the camera's hierarchy establishes the root space of the scene to be world locked space. Persistence The Frozen State can optionally be persisted across sessions. There are manual controls for both saving the current state and for loading from a saved state. Additionally, flags on the World Locking Tools Manager enable or disable automatic periodic saving of Frozen State, and automatic loading of the last saved state at startup. Using these features allows the scanning and stabilization of a real space to persist over multiple sessions. Additionally, if the Space Pin feature is used to align modeling space to the real space, that alignment can be persisted. In that case, after an initial alignment session to set up the Space Pins to align the modeled scene to a physical space, subsequent sessions can automatically load the modeled scene into the physical space with virtual and real features aligned. For more information, see Persistence and Space Pin feature . Camera movement implications A subtle but important thing to note here is that, by applying the correction transform to the camera, the native Unity \"stationary frame of reference\" has been converted into the optimal world locked frame of reference. Since no objects in the scene were moved, this correction will not interfere with physics simulation or other dynamics calculations. However, the camera being moved within the stationary frame of reference does have implications. Specifically, any subsystems, which assume that the head transform is the only transform between the stationary frame of reference and the camera space, will be incorrect. This error is usually not a problem, as such capabilities as teleport already rely on the ability to place a transform between the camera and root space. Also, the MRTK already factors in the need for such transforms, so for users of MRTK services this will \"just work\". For users requiring direct access to lower-level systems that are unable to take advantage of MRTK, samples are provided for building adapters. A few such examples are listed below: A world anchor adapter Tap event adapting Spatial mapping adapter See also Advanced topics How-to articles Samples"
  },
  "DocGen/Documentation/GettingStartedWithWorldLocking.html": {
    "href": "DocGen/Documentation/GettingStartedWithWorldLocking.html",
    "title": "Getting started with World Locking Tools | World Locking Tools for Unity Documentation",
    "keywords": "Getting started in World Locking Tools Getting started in World Locking Tools can be as simple as dragging a prefab into a Unity scene. However, understanding the work the Unity layer of World Locking Tools performs, and the underlying FrozenWorld engine, can be helpful and educational. Goals of this documentation The first goal is to establish an understanding of what World Locking Tools is trying to do. This insight can help in setting expectations for what problems World Locking Tools can solve, and what problems are out of its scope. The number-crunching optimization at the core of World Locking Tools is performed in an engine implemented as an efficient C-style DLL. While a C# shim is provided for directly interfacing to the World Locking Tools engine from Unity scripting, it's hoped that low-level interaction with the engine will be rarely if ever needed. It's important to understand that World Locking Tools' Unity layer acts as a proxy application, performing the tasks that the vast majority of applications built on Unity would need to perform in managing the FrozenWorld engine. Sharing this engine harness makes sense, avoiding each application developer being responsible for implementing essentially the same control structure. But for an application is in the minority and having special requirements, World Locking Tools' Unity layer acts as a sample scaffolding for building a custom harness for the engine. Understanding what the provided scaffolding is doing is necessary to modify it, or to implement a variation of it. It will be shown that a good deal of customization is available, even without modifying code. Understanding what World Locking Tools is doing, and the customizable properties, is helpful for fine-tuning World Locking Tools for a specific application. Finally, an understanding of World Locking Tools can be helpful when things go wrong, in narrowing which system is faulty, providing useful bug reports, and establishing workarounds. Guide structure These guides are arranged to both build an understanding of World Locking Tools at a conceptual level, and provide practical step-by-step instructions on putting World Locking Tools to use in real world MR applications. Before getting started Quick start Initial setup Concepts The basic system Advanced topics How-to articles Samples Additionally, the API documentation provides a reference on programmatic interfaces into World Locking Tools. It should be stressed that in most cases, there will be no need to code directly to the World Locking Tools interfaces, and scene setup and property settings in the inspector are all that are required. The exception is with attachment points , which are covered later both conceptually and in the programming reference ."
  },
  "DocGen/Documentation/HowTos.html": {
    "href": "DocGen/Documentation/HowTos.html",
    "title": "How-to articles | World Locking Tools for Unity Documentation",
    "keywords": "How-To articles To complement the concept articles giving motivation and understanding of the design and use of World Locking Tools, and the API documentation detailing the implementation, these how-to articles provide a hands-on walk-through of common steps in developing applications with World Locking Tools. See also Initial Setup Tools and visualizations World Locking Tools Contexts Sample Applications"
  },
  "DocGen/Documentation/HowTos/CodingConventions.html": {
    "href": "DocGen/Documentation/HowTos/CodingConventions.html",
    "title": "Coding guidelines | World Locking Tools for Unity Documentation",
    "keywords": "Coding guidelines This document outlines the recommended coding guidelines for World Locking Tools for Unity. Most of these suggestions follow the recommended standards from MSDN . Script license information headers All scripts posted to World Locking Tools for Unity should have the standard License header attached, exactly as shown below: // Copyright (c) Microsoft Corporation. All rights reserved. // Licensed under the MIT License. See LICENSE in the project root for license information. Any script files submitted without the license header will be rejected. Function / Method summary headers All public classes, structs, enums, functions, properties, fields posted should be described as to their purpose and use, exactly as shown below: /// <summary> /// The Controller definition defines the Controller as defined by the SDK / Unity. /// </summary> public struct Controller { /// <summary> /// The ID assigned to the Controller /// </summary> public string ID; } This rule ensures documentation is properly generated and disseminated for all classes, methods, and properties. Any script files submitted without proper summary tags will be rejected. Namespace rules All classes and extensions should be scoped by namespace, chosen appropriately from the following namespaces. Microsoft.MixedReality.WorldLocking.Core - Foundation code fulfilling the basic service of World Locking Tools. Microsoft.MixedReality.WorldLocking.Tools - Optional features supplementing development on top of World Locking Tools. Examples are diagnostic visualizations, and baseline implementations of application event handlers. Microsoft.MixedReality.WorldLocking.Examples - Specific implementations demonstrating how to use World Locking Tools features, and the benefits gained. Related features within one of the above namespaces may be grouped by extending to a new sub-namespace. Do namespace Microsoft.MixedReality.WorldLocking.Examples.Placement { // Interface, class or data type definition. } Omitting the namespace for an interface, class or data type will cause your change to be blocked. Spaces vs Tabs Be sure to use four spaces instead of tabs when contributing to this project. Additionally, ensure that spaces are added for conditional / loop functions like if / while / for Don't private Foo () // < - space between Foo and () { if(Bar==null) // <- no space between if and () { DoThing(); } while(true) // <- no space between while and () { Do(); } } Do private Foo() { if (Bar==null) { DoThing(); } while (true) { Do(); } } Spacing Do not add additional spaces between square brackets and parenthesis: Don't private Foo() { int[ ] var = new int [ 9 ]; Vector2 vector = new Vector2 ( 0f, 10f ); } Do private Foo() { int[] var = new int[9]; Vector2 vector = new Vector2(0f, 10f); } Naming Conventions Always use PascalCase for public / protected / virtual properties, and camelCase for private properties and fields. The only exception to this is for data structures that require the fields to be serialized by the JsonUtility . Don't public string myProperty; // <- Starts with a lower case letter private string MyProperty; // <- Starts with an uppercase case letter Do public string MyProperty; protected string MyProperty; private string myProperty; Access Modifiers Always declare an access modifier for all fields, properties, and methods. All Unity API Methods should be private by default, unless you need to override them in a derived class. In this case protected should be used. Fields should always be private , with public or protected property accessors. Don't // protected field should be private protected int myVariable = 0; // property should have protected setter public int MyVariable { get { return myVariable; } } // No public / private access modifiers void Foo() { } void Bar() { } Do public int MyVariable { get; protected set; } = 0; private void Foo() { } public void Bar() { } protected virtual void FooBar() { } Use Braces Always use braces after each statement block, and place them on the next line. Don't private Foo() { if (Bar==null) // <- missing braces surrounding if action DoThing(); else DoTheOtherThing(); } Don't private Foo() { // <- Open bracket on same line if (Bar==null) DoThing(); <- if action on same line with no surrounding brackets else DoTheOtherThing(); } Do private Foo() { if (Bar==true) { DoThing(); } else { DoTheOtherThing(); } } Public classes, structs, and enums should all go in their own files. If the class, struct, or enum can be made private, then it's okay to be included in the same file. This inclusion avoids compilations issues with Unity and ensures that proper code abstraction occurs. It also reduces conflicts and breaking changes when code needs to change. Don't public class MyClass { public struct MyStruct() { } public enum MyEnumType() { } public class MyNestedClass() { } } Do // Private references for use inside the class only public class MyClass { private struct MyStruct() { } private enum MyEnumType() { } private class MyNestedClass() { } } Do MyStruct.cs // Public Struct / Enum definitions for use in your class. Try to make them generic for reuse. public struct MyStruct { public string Var1; public string Var2; } MyEnumType.cs public enum MuEnumType { Value1, Value2 // <- note, no \",\" on last value to denote end of list. } MyClass.cs public class MyClass { private MyStruct myStructreference; private MyEnumType myEnumReference; } Order Enums for appropriate extension. It is critical that if an Enum is likely to be extended in the future, to order defaults at the top of the Enum. This ordering ensures Enum indexes are not affected with new additions. Don't public enum SDKType { WindowsMR, OpenVR, OpenXR, None, <- default value not at start Other <- anonymous value left to end of enum } Do /// <summary> /// The SDKType lists the VR SDK's that are supported by the MRTK /// Initially, this lists proposed SDK's, not all may be implemented at this time (please see ReleaseNotes for more details) /// </summary> public enum SDKType { /// <summary> /// No specified type or Standalone / non-VR type /// </summary> None = 0, /// <summary> /// Undefined SDK. /// </summary> Other, /// <summary> /// The Windows 10 Mixed reality SDK provided by the Universal Windows Platform (UWP), for Immersive MR headsets and HoloLens. /// </summary> WindowsMR, /// <summary> /// The OpenVR platform provided by Unity (does not support the downloadable SteamVR SDK). /// </summary> OpenVR, /// <summary> /// The OpenXR platform. SDK to be determined once released. /// </summary> OpenXR } End Enum names with \"Type\" Enum names should clearly indicate their nature by using the Type suffix. Don't public enum Ordering { First, Second, Third } public enum OrderingEnum { First, Second, Third } Do public enum OrderingType { First = 0, Second, Third } Review Enum use for Bitfields If there is a possibility for an enum to require multiple states as a value, for example, Handedness = Left & Right. Then the Enum needs to be decorated with BitFlags to enable it to be used correctly The Handedness.cs file has a concrete implementation for this Don't public enum Handedness { None, Left, Right } Do [flags] public enum HandednessType { None = 0 << 0, Left = 1 << 0, Right = 1 << 1, Both = Left | Right } Best Practices, including Unity recommendations Some of the target platforms of this project require to take performance into consideration. With this in mind, always be careful when allocating memory in frequently called code in tight update loops or algorithms. Encapsulation Always use private fields and public properties if access to the field is needed from outside the class or struct. Be sure to co-locate the private field and the public property. This location makes it easier to see, at a glance, what backs the property and that the field is modifiable by script. If you need to have the ability to edit your field in the inspector, it's best practice to follow the rules for Encapsulation and serialize your backing field. The only exception to this is for data structures that require the fields to be serialized by the JsonUtility , where a data class is required to have all public fields for the serialization to work. Don't public float MyValue; Do // private field, only accessible within script (field is not serialized in Unity) private float myValue; Do // Enable private field to be configurable only in editor (field is correctly serialized in Unity) [SerializeField] private float myValue; Don't private float myValue1; private float myValue2; public float MyValue1 { get{ return myValue1; } set{ myValue1 = value } } public float MyValue2 { get{ return myValue2; } set{ myValue2 = value } } Do // Enable field to be configurable in the editor and available externally to other scripts (field is correctly serialized in Unity) [SerializeField] [ToolTip(\"If using a tooltip, the text should match the public property's summary documentation, if appropriate.\")] private float myValue; // <- Notice we co-located the backing field above our corresponding property. /// <summary> /// If using a tooltip, the text should match the public property's summary documentation, if appropriate. /// </summary> public float MyValue { get{ return myValue; } set{ myValue = value } } Use for instead of foreach when possible In some cases a foreach is required, for example, when looping over an IEnumerable. But for performance benefit, avoid foreach when you can. Don't foreach(var item in items) Do int length = items.length; // cache reference to list/array length for(int i=0; i < length; i++) Cache values and serialize them in the scene/prefab whenever possible. With the HoloLens in mind, it's best to optimize for performance and cache references in the scene or prefab to limit runtime memory allocations. Don't void Update() { gameObject.GetComponent<Renderer>().Foo(Bar); } Do [SerializeField] // To enable setting the reference in the inspector. private Renderer myRenderer; private void Awake() { // If you didn't set it in the inspector, then we cache it on awake. if (myRenderer == null) { myRenderer = gameObject.GetComponent<Renderer>(); } } private void Update() { myRenderer.Foo(Bar); } Cache references to materials, do not call the \".material\" each time. Unity will create a new material each time you use \".material\", which will cause a memory leak if not cleaned up properly. Don't public class MyClass { void Update() { Material myMaterial = GetComponent<Renderer>().material; myMaterial.SetColor(\"_Color\", Color.White); } } Do // Private references for use inside the class only public class MyClass { private Material cachedMaterial; private void Awake() { cachedMaterial = GetComponent<Renderer>().material; } void Update() { cachedMaterial.SetColor(\"_Color\", Color.White); } private void OnDestroy() { Destroy(cachedMaterial); } } Alternatively, use Unity's \"SharedMaterial\" property which does not create a new material each time it is referenced. Use platform dependent compilation to ensure the Toolkit won't break the build on another platform Use WINDOWS_UWP in order to use UWP-specific, non-Unity APIs. This define will prevent them from trying to run in the Editor or on unsupported platforms. This define is equivalent to UNITY_WSA && !UNITY_EDITOR and should be used in favor of. Use UNITY_WSA to use UWP-specific Unity APIs, such as the UnityEngine.XR.WSA namespace. This will run in the Editor when the platform is set to UWP, and in built UWP apps. This chart can help you decide which #if to use, depending on your use cases and the build settings you expect. UWP IL2CPP UWP .NET Editor UNITY_EDITOR False False True UNITY_WSA True True True WINDOWS_UWP True True False UNITY_WSA && !UNITY_EDITOR True True False ENABLE_WINMD_SUPPORT True True False NETFX_CORE False True False Prefer DateTime.UtcNow over DateTime.Now DateTime.UtcNow is faster than DateTime.Now. In previous performance investigations we've found that using DateTime.Now adds significant overhead especially when used in the Update() loop. Others have hit the same issue . Prefer using DateTime.UtcNow unless you actually need the localized times (a legitimate reason may be you wanting to show the current time in the user's time zone). If you are dealing with relative times (that is, the delta between some last update and now), it's best to use DateTime.UtcNow to avoid the overhead of doing timezone conversions."
  },
  "DocGen/Documentation/HowTos/Contributing.html": {
    "href": "DocGen/Documentation/HowTos/Contributing.html",
    "title": "Contributing to the World Locking Tools for Unity project | World Locking Tools for Unity Documentation",
    "keywords": "Contributing to the World Locking Tools for Unity project The most valuable way to contribute to the World Locking Tools project at this time is by filing issues. Any and all feedback on better aligning the World Locking Tools for Unity project with your project's needs is extremely valuable. While any feedback you post is valuable, here are some tips on making yours more actionable. Use labels appropriately Both when initially submitting an issue, and when following up on an issue as a contributor, proper use of labels is extremely helpful on coordinating with other contributors. Try to differentiate accurately between what is a bug, what is a feature request, and what is a broader suggestion going forward. All are valuable, but they are more valuable once identified as such. Likewise, if an issue seems unactionable in its current form, applying the appropriate label (for example, \"unclear\") can help get it improved to where it is actionable. Specific comments in the issue itself are, of course, extremely valuable. But the proper label may lead others to see a comment that might otherwise go unnoticed. Reporting a bug Issues may be submitted from the issues portal on GitHub. Taking the time to report a problem or make a suggestion that others will benefit from as well is always appreciated. Every bug report has its own context, but in general, the more of the following that are included the more quickly an issue can get resolved. Log files from the device Log files from the device can be immeasurably helpful in investigating issues, especially in conjunction with screen captures suggested below. They may be obtained using the Windows Device Portal while connected to your device, under System > File explorer > User Folders \\ LocalAppData \\ WorldLockingTools The Unity app log file UnityPlayer.log is located in the TempState sub-folder. This is a plain text file. The World Locking Tools diagnostics recording The diagnostics file is located in the LocalState sub-folder. The file's name is auto-generated according to the following pattern: FrozenWorld-<device name>-<capture date and time>.hkfw It is a binary file which needs specialized software to examine. Note that to capture a diagnostics recording requires enabling Diagnostics Recording on the World Locking Tools Manager component in your scene. See the diagnostics documentation for details. Repro steps Specify how readily the issue happens. The ideal is having a bug that occurs 100% of the time following a certain set of step. But even for a bug that you've only seen happen once, the more detailed you can relate the steps leading up to the issue, the better. Repro steps should follow the following general form: Starting from this normal stable state... Then I did this (or noticed this unusual thing)... Then the system started showing this incorrect behavior... Screen captures Screen captures will help identify the full context the issue occurred in. In particular, having World Locking Tools diagnostics displayed on screen can help correlate your experience to the information in the logs. Screen captures can either be snapshot images, or video captures. Device info What type of device? Running what OS-version? Build environment Unity version Visual Studio version Proposing a feature When you find that World Locking Tools almost does what you need, the chances are that someone else is suffering the same limitation. We are just as interested in fixing gaps in our documentation and examples as in providing new capabilities. In proposing a new feature, it's most valuable to make clear what it is you are trying to get done. While ideas on how to implement it can also be helpful, proposals that make clear the added value are more likely to gain traction. Make the problem the feature solves obvious, preferably with what you could accomplish with it in a real world scenario. Make sure to attach the \"enhancement\" label to the submitted proposal issue. Contributing code This is an open-source project, so of course anyone can make a fork to develop on at any time. If someone is generous enough to share back work, then it is greatly appreciated, whether it gets folded back into the main repository or not. During this initial rollout period, we will have limited resources to review and accept pull requests into the main repository. It is advisable to avoid investing much time into a fork under the assumption that it will be merged back to the main repository. One way to mitigate the risk is to submit an issue proposing what is intended (labeled \"enhancement\") before investing much time in an implementation. This is also considerate toward other contributors that might be looking at the same problem area. See also Coding Conventions Release Process"
  },
  "DocGen/Documentation/HowTos/InitialSetup.html": {
    "href": "DocGen/Documentation/HowTos/InitialSetup.html",
    "title": "Initial setup of World Locking Tools | World Locking Tools for Unity Documentation",
    "keywords": "Initial setup of World Locking Tools Slimmest possible setup The tutorial here steps through the minimal setup to get up and running with everything in your application world-locked, without any further action (for example, spatial anchors) required. It is in the Samples repo sibling to this repo. Quick start guide A less conceptually detailed and more pragmatic approach to integrating WLT into a project can be found here. Where appropriate, it references back into these more thorough pages. While it's really a matter of personal preference which approach is more appropriate, a quick read of the Before getting started page can be a time saver on where to devote energies in this documentation. Supported environments World Locking Tools for Unity currently targets UWP applications for the HoloLens family of devices. Both the original HoloLens (x86) and HoloLens 2 (ARM64) are supported. Experimental support for other platforms is available through Unity's AR Subsystems . The World Locking Tools continuous integration (CI) build validates with Unity2018.4.6f1 with Visual Studio 2017. However, extensive WLT development has also been done using the gamut of Unity2018 versions, and a range of Unity2019. Both Visual Studio 2017 and Visual Studio 2019 have been used in the development of the tools. If you experience any compatibility issues with other versions of Unity and/or Visual Studio, we would love to hear about it! The best way to report any problems is through the issues portal on GitHub. Assumed background It is assumed that people looking to integrate the World Locking Tools solution into their projects are already familiar with the basics of building and deploying applications for the HoloLens family of devices. If not, there are some great references at the end of this article. The World Locking Tools layers World Locking Tools is broken into four layers. With the arrows pointing toward the layer depended on, the straightforward dependency graph looks like this: The dashed lines indicate optional dependencies. While the Examples layer uses the MixedRealityToolkit (MRTK), none of the other layers have any external dependencies, and the full functionality is available compatible with but independent of MRTK. Further notes on the Applications dependencies follow below. The layers may be summarized as follows: Plugin An imperative interface allowing direct communication with the Engine DLL. Common issues such as argument marshaling are accomplished here, and some composing of multiple functions frequently used in combination into composite directives. It remains a low-level C# interface to the underlying C++ DLL. Its direct use is available, but not needed nor advisable. Core The Core is an encapsulation of all steps necessary for gaining the benefits of World Locking Tools' stable world-locked space, packaged into a declarative interface. A working application would be expected to ship using only functionality from the Core. Tools The Tools are largely diagnostic in nature. Visualizations of World Locking Tools processes are included in forms easy to add to any project which uses World Locking Tools. Other convenient utilities are included, but are expected to be helpful in getting started toward coding up custom solutions, rather than to be final solutions as the Core offers. Examples The Examples layer attempts to present samples of setting up common scenarios when using World Locking Tools, and best practices in World Locking Tools' integration into various scenarios. Any necessary MRTK dependencies for UX and object manipulation are restricted to the scripts and prefabs at the Examples layer. This leaves the lower layers free of any external dependencies. Scripts and assets in the Examples layer are not expected to be integrated directly into shipping products, although there is no prohibition against it. Rather, their construction favors simplicity and clarity over reusability and efficiency. The Application In general, the Application will need take only a dependency on World Locking Tools Core. During development, many visualizations and other helpers for understanding unexpected behavior are available in the Tools layer. These helpers would ideally be stripped out of a finished application, or at least disabled. Of course, they are free for other uses as well, either in their current form or modified. See the license for details. For advanced use, and experimentation of World Locking Tools' full capabilities, the Plugin layer offers low-level imperative access to the Engine DLL. If access to the Plugin layer becomes necessary, it may point to a deficiency in the API surface offered in the Core layer. The World Locking Tools team is always looking to fill such gaps. Consider contributing such insights to the team. See contributing . A warning note on installation path length Some versions of MRTK have an issue with long installation paths. The full path length of deep subfolders in the MRTK installation can exceed the Windows path limit (260 characters). If a build error of the following form appears: DirectoryNotFoundException: Could not find a part of the path \"D:\\MyOverTwentyEightCharacterLongLengthInstallPath\\MixedReality-WorldLockingTools-Unity\\Assets\\MRTK\\MixedRealityToolkit.Providers\\WindowsMixedReality\\DotNetAdapter\\Plugins\\net46\\Microsoft.Windows.MixedReality.DotNetWinRT\\Editor\\Microsoft.Windows.MixedReality.DotNetWinRT.Editor.asmdef\" but the file is actually there on the drive, then the issue is likely the path length. The MRTK team is aware of this and is working to improve on it (note: I believe they have made great improvements here and it is no longer an issue). In the meantime, the workaround is to shorten the path prefix by a combination of the following: Install the Unity project into a shorter length path root, for example, \"D:\\Proj\" If cloning the repo, clone the root of the World Locking Tools into something shorter than the default \"\\MixedReality-WorldLockingTools-Unity\", for example: git clone https://github.com/microsoft/MixedReality-WorldLockingTools-Unity.git d:\\MyGit\\wlt This path limit is generally not an issue with the World Locking Tools themselves, as they don't utilize a folder structure this is as deep. Adding World Locking Tools to a Unity project Note The following describes manual installation of World Locking Tools and dependencies. A much more streamlined installation process is available via the Mixed Reality Feature Tool . Installation via the Feature Tool is described here . If the Feature Tool installs WLT, you can skip the following and proceed to adding WLT to your scene World Locking Tools relies on NuGet for Unity for distribution. To begin, make sure NuGet for Unity is installed into the Unity project. It is available from the NuGet for Unity github releases . If the target Unity project is the World Locking Tools project (or a derivative of it), then all necessary and optional resources are already included. If adding World Locking Tools to an existing project, it is advisable to start with a project that has been verified to build and deploy to a HoloLens device. This will help separate issues with getting an app to run on HoloLens in the first place, which can be complicated, from issues with the World Locking Tools. Then proceed to the NuGet setup and World Locking Tools Assets sections below. FrozenWorld Engine installation The Frozen World Engine DLL may be obtained from NuGet either using the excellent NuGet For Unity utility, or manually. Using NuGet For Unity Make sure the nuget.org feed is in sources. Check this in Unity > Edit > Preferences > NuGet for Unity. If not, either : Use the Add New Source GUI in Unity > Edit > Preferences > NuGet For Unity to add the same share. Replace \"New Source\" with a name of your choosing (for example, \"NuGet\"). Replace \"source_path\" with \"http://www.nuget.org/api/v2/\". After confirming the nuget.org feed, in Unity > NuGet > Manage NuGet Packages, find and install the latest version of Microsoft.MixedReality.FrozenWorld.Engine. (Search for \"FrozenWorld\".) To update to a later version, open the Unity > NuGet > Manage NuGet Packages again, and find the FrozenWorld.Engine package and select Update. Note: You may have to the Updates tab to find the version you are looking for. Manual Frozen World Engine DLL installation Use a text editor to add a packageSources line to Assets/NuGet.config, for example: <packageSources> <add key=\"NuGet\" value=\"http://www.nuget.org/api/v2/\" /> </packageSources> If you don't already have a file Assets/NuGet.config, you can copy it from the World Locking Tools github repo. Using a text editor, add the Frozen World Engine DLL package to Assets/packages.config, for example: <?xml version=\"1.0\" encoding=\"utf-8\"?> <packages> <package id=\"Microsoft.MixedReality.Unity.FrozenWorld.Engine\" version=\"1.0.0\" /> </packages> Again, if you don't already have a file Assets/packages.config, you can get the file from the World Locking Tools github repo, or simply copy the above into a text file called \"Assets/packages.config\". Having setup NuGet.config and packages.config, install by: Obtain the latest nuget.exe from NuGet downloads . Make sure nuget.exe is in your path (here I'll assume it was copied into Assets). Open a PowerShell command window and change directory to the Assets folder. Run the following command: .\\nuget.exe restore To upgrade to a later version: Update the FrozenWorld.Engine version number in the packages.config file above to the desired version (for example, version=\"1.0.0\" becomes version=\"1.0.1\"). Delete anything in the Assets/Packages folder starting with \"Microsoft.MixedReality.Unity.FrozenWorld.Engine\". Rerun nuget.exe as above. World Locking Tools Assets Either import the required World Locking Tools .unitypackage files into the project (preferred method), or copy them in. They may be moved into a sub-folder within Assets to get them out of the way for application development. The latest stable .unitypackage files can be found in World Locking Tools for Unity Releases . The WorldLocking.Core and Engine layer will definitely be required, so a minimal install package would be WorldLockingCoreEngine.unitypackage. To determine what other layers might be required, see the discussion of World Locking Tools layers and their dependencies above. Each layer is contained in a single Unity package. Since some of the World Locking Tools Examples use features from MRTK, a compatible MRTK snapshot is included with the Examples unitypackage . For the latest MRTK release, look here . Adding World Locking Tools to a Unity scene Note The steps listed below are all automated in the WLT Configure scene utility, which can be found in the menu Mixed Reality Toolkit > Utilities > World Locking Tools. Within a Unity project containing the FrozenWorld engine (from nuget.org), import any desired World Locking Tools Assets layers (but at least WorldLocking.Core), and optionally MRTK. Then create a new scene (or open an existing scene). Note Add an extra node at the root of the camera hierarchy. This node will be used to adjust the head tracked camera into world locked space. (If using MRTK, this new GameObject would be the parent of the MixedRealityPlayspace.) The core experience Drag a WorldLockingManager prefab from Assets/WorldLocking.Core/Prefabs into your scene. Its place in the scene doesn't matter, but it should not be in the camera tree. See a sample scene for a suggested configuration. There are settings available on the WorldLockingManager prefab, but leaving them to their default values is recommended to get started. See World Locking Tools Context for explanations of the options presented. [Optional] MRTK World Locking Tools is complementary with but orthogonal to MRTK. The use of MRTK along with World Locking Tools is entirely optional. That said, the World Locking Tools samples are built using MRTK, and MRTK is generally extremely valuable in developing the types of MR applications that benefit most from World Locking Tools. If using MRTK, rather than using the snapshot included with the examples, it's recommended to add the latest versions of at least the following packages: MixedReality.Toolkit MixedReality.Toolkit.Providers MixedReality.Toolkit.Services MixedReality.Toolkit.SDK [Optional] Visualizing spongy and world locked anchors This requires the addition of WorldLocking.Tools to the project's Assets. If you want to visualize your anchors, drag AnchorGraphVisual prefab from Assets/WorldLocking.Tools/Prefabs into your scene. Check-boxes to toggle aspects of the visualization in the inspector are on the WorldLockingManager . As diagnostics, the WorldLocking.Tools visualizations are not heavily optimized, and will reduce performance long before the core World Locking Tools processing time becomes relevant. [Optional] A simple dashboard for parameter control within Mixed Reality A simple HUD is available, which may be used to control the WorldLockingManager at runtime from inside MR. These are supplied in the Examples package. While they may be used as is, they are intended as patterns when building similar features into an applications own display system and UX. Drag in the WorldLocking.Examples/Prefabs/Dashboard prefab, and point its Anchor Visualizer field to the Visualizer in the previous section. Migrating an existing scene to World Locking Tools The biggest change when moving to World Locking Tools is that there is no longer a requirement for using spatial anchors to world-lock virtual objects. Spatial anchors have traditionally been the only tool available to world-lock individual objects. But when using World Locking Tools, the coordinate space those virtual objects exist in is already world-locked. No further locking is needed. Not only are spatial anchors unnecessary, they won't work correctly, as they fail to take into account additional transforms up the camera hierarchy (such as the MRTK \"Playspace\" transform). Therefore, any and all spatial anchors should be removed from the scene, and any scripts adding spatial anchors should discontinue doing so. The spatial anchors don't need to be replaced by anything; World Locking Tools will anchor their targets to the real world. If it is desirable to compare world-locking with and without World Locking Tools, then instead of removing WorldAnchors, they may be replaced with the ToggleWorldAnchor supplied in WorldLocking.Tools. ToggleWorldAnchor works exactly the same as a WorldAnchor, with the important difference that when the World Locking Tools Manager is active, it conveniently disables itself and gets out of the way. When the World Locking Tools Manager is disabled, it behaves as a normal WorldAnchor. If for some other reason WorldAnchors are still required in the scene (for example, for network sharing), they can be used with an adapter, supplied as WorldAnchorAdapter . The WorldAnchorAdapter transforms the raw position of a GameObject positioned by a WorldAnchor, into the world locked Unity global space, and then applies the transform to a target object. To use it, rather than adding a WorldAnchor directly to an object, the WorldAnchor should be applied to a proxy object (usually an otherwise empty GameObject), and then on Update() the WorldAnchorAdapter reads the pose of the WorldAnchor, transforms it correctly, and applies it to the target. Setup complete Having followed the above steps, the project deployed to device will run adjusted by World Locking Tools to maintain an optimally stable world-locked space. Any fixed objects placed in the scene will remain visually consistent both relative to each other and with the physical world. Available example applications Sample scenes , including both scripts and assets are provided to demonstrate more complex use of World Locking Tools' capabilities. For example, the WorldLockedPhysicsSample provides a simple environment in which physically simulated objects can be created and removed, interacting with each other and with the environment (the spatial mapping). For a more focused look at the Space Pinning feature, the SpacePin provides a much simplified example of aligning a large scale virtual object to real world features. The RayPins expands on the capabilities introduced by the SpacePin example, allowing pinning of the virtual world to the physical world with ray tests against the spatial mesh. References for getting started If unfamiliar with the basics of creating, building, and deploying AR apps to the HoloLens family of devices, here are some references that might help get your started. Unity Development Overview - Unity for MR/AR development. MR Basics 100 - Walk through getting started developing for HoloLens HoloLens 2 Tutorials - Walk through getting started developing for HoloLens 2. Coordinate Systems Coordinate space implications in AR development. Note that World Locking Tools solve the issues discussed here . Having trouble? See troubleshooting guide ."
  },
  "DocGen/Documentation/HowTos/QuickStart.html": {
    "href": "DocGen/Documentation/HowTos/QuickStart.html",
    "title": "Quick start guide | World Locking Tools for Unity Documentation",
    "keywords": "Quick start guide This set of articles tries to plunge the developer new to World Locking Tools into typical workflows. There is a lot available in World Locking Tools for Unity, but a lot of value can be harnessed with very little developer work. These articles try to guide the developer toward getting the functionality the developer wants with minimal effort, and without getting side-tracked by other available features which might not be currently relevant. It is suggested that you proceed through these in the order presented here. Before you start - A quick description of what to expect. Most basic setup - Minimal work to get 99% of WLT's value. Loss of tracking - Elegant handling of exceptional conditions. Across sessions - Getting a seamless experience across sessions. Pinning it down - Putting the coordinate space where you want it."
  },
  "DocGen/Documentation/HowTos/ReleaseProcess.html": {
    "href": "DocGen/Documentation/HowTos/ReleaseProcess.html",
    "title": "Developing new code and documentation | World Locking Tools for Unity Documentation",
    "keywords": "Developing new code and documentation Depending on access level, new code and documentation may be developed in a new feature branch, or in a fork. In general, working from a separate fork is preferred, and is sometimes the only alternative. Best practices in git/GitHub development are outside the scope of this documentation, but further reading may be found here . New code Submitting a pull request (PR) Any pull request should include a manual run through the CI build pipeline. The pipeline is triggered by adding a comment to the PR. The following command will trigger a full build: /azp run If it's known that the changes are entirely restricted to either code or documentation, then only that side of the build may be run. For example, to check only code changes: /azp run wlt_ci Or to check only documentation changes: /azp run wlt_docs However, keep in mind that even changes restricted to code (.cs) files may trigger documentation changes. It's always safer to run the full build. Run the appropriate version after any significant changes to a PR, and before final completion of the PR. Remember, those tools are in place to protect contributors from breaking the build. Using them is to your own benefit, and the benefit of others working in the same space. Code review All PRs must be reviewed by another developer before they may be completed. When performing code reviews, maintain a friendly and collaborative atmosphere. It's always worth a little extra time to find a way to express a suggestion or correction that leaves the other side feeling positive about the changes. Publishing a new release After thorough testing and stabilization, a new safe version of the product may be published. The product is made available through two channels: Via the open-source GitHub repo, tagged for verified release commits. Via published .unitypackage files. Both channels are available on the WLTU's GitHub releases page . Building the unity packages NOTE: The exact UI of the process described here is subject to frequent change. If what you see on your screen doesn't match the screenshots here, that's probably okay. Just look for the relevant keywords and follow through. First, go to the build pipeline page . Be sure that \"wlt_ci\" is selected. Select the build that matches the commit that will be the basis for the release. That selection will lead to the following screen, from which the build artifacts may be accessed.* Select the unity packages. Then download as zip. After installing and testing the packages, they may be integrated into a new release. Creating the release Update the Version field in code Update the WorldLockingManager.Version field to properly reflect the new version. Create a release branch For example, create a branch named \"release/v0.3.6-alpha\". While redundant with the tag, this branch will facilitate hot-fixes to the release, which wouldn't be suitable for the main development branch \"master\". Publish the release Go to the World Locking Tools for Unity releases page . Click the \"Create a new release\" button. Specify a tag. The tag should be of the form vX.Y.Z[-prerelease-modifier]. The X, Y, and Z of this tag are three integers that should match the version as specified in the WorldLockingManager.Version field . These numbers should also match the release branch name. Specify the release branch created above as the target. Fill in the title and description fields appropriately. Drag the .unitypackage files created above into the rectangle labeled \"Attach binaries by dropping them here or selecting them\". The large Examples package, which also contains a snapshot of its MRTK dependency, may take considerable time to upload. It's safest to not leave that page until the upload has completed successfully. When the .unitypackage files have successfully uploaded, click the Publish Release button. Verify that everything looks correct on the releases page."
  },
  "DocGen/Documentation/HowTos/SampleApplications.html": {
    "href": "DocGen/Documentation/HowTos/SampleApplications.html",
    "title": "Example applications | World Locking Tools for Unity Documentation",
    "keywords": "Example applications This project ships with several sample applications. These are working apps demonstrating World Locking Tools' capabilities, and scenarios which World Locking Tools enables. They also attempt to show best practices in coding against the World Locking Tools APIs. Supplementary samples can be found in the World Locking Tools Samples sibling repository, which has its own documentation . That repo contains more projects illustrating the use of World Locking Tools in both minimal settings, and in more advanced usage. In particular, more advanced samples are free to incorporate external libraries, which would be inappropriate to include in the base configuration here, to show how World Locking Tools working in cooperation with other technologies can produce results beyond what either can achieve alone. See also World Locked Physics Sample Space Pin Sample Ray Pin Sample World Locking Tools with Azure Spatial Anchors Sample"
  },
  "DocGen/Documentation/HowTos/Samples/RayPins.html": {
    "href": "DocGen/Documentation/HowTos/Samples/RayPins.html",
    "title": "Ray Pins Example | World Locking Tools for Unity Documentation",
    "keywords": "Ray Pins Example Accompanying video See the application in action in this accompanying video for a bit of context. Related samples The Space Pins sample demonstrates setting up Space Pins by manually manipulating marker objects into position using MRTK affordances. More abstract discussion about the Space Pin feature is also relevant background for this sample. Rather than manual manipulation of objects, this sample uses ray cast tests onto the spatial reconstruction meshes to set the world alignment. Significantly, this sample also creates all required World Locking Tools components from script, rather than needing assets setup in the editor. Scene contents There are eight Space Pin virtual marker objects in the RayPins scene. Four are floor level, at the northeast, southeast, northwest, and southwest corners of a square four meters per side. Another four pins are one meter up, suggesting they are points on walls six meters apart. Building the sample The sample requires the SpatialPerception capability. The Microphone capability is also required for voice commands. Running the sample Physical setup Find a physical space with some clearance. Place markers on the floor and walls at the same separations as the virtual markers in the scene. It's not necessary to have a physical marker for every virtual marker. It is helpful to either label the physical markers with the name of the corresponding virtual marker (for example, \"NW\"), or draw a map with their placement labeled. App setup Build and deploy the RayPins scene to device. Running the app Startup On startup, the coordinate system is based on the head position, and the virtual grid and markers placement is arbitrary. First marker On the radio selection, pick one of the markers for which there is a corresponding physical marker in the room. Click on the physical marker in the room. The scene will shift to align the selected virtual marker to the ray hit physical marker. If the alignment is unsatisfactory, for example because of a slip at the moment of selection, simply repeat selecting, with the appropriate radio button still selected, until satisfactory alignment is achieved. Second marker Move to another physical marker in the room, and select its virtual marker in the radio selection. Click on that physical marker. The grid and markers now rotate to align with both markers aligned. More markers When the user is near either of the first two pins placed, alignment should be quite close between the physical and virtual markers. For other markers, however, there may be significant misalignments between physical and virtual. These may arise from a number of sources, but primarily from inexact placement of physical markers, or from tracker error. Repeat the radio selection and ray hit placement of virtual markers for any further physical markers placed in the room. After this placement process, any such marker should show good alignment when near it. Verification A physical tape measure may be used to verify the interpolated alignment between markers. The grid lines are spaced one meter apart, and the lines are one centimeter wide. Persistence Since AutoSave and AutoLoad are enabled on the WorldLockingContext in the RayPins scene, after aligning the content to a physical room and exiting the app, on running the application again the virtual grid and markers will resume their alignment with the physical room. To clear the alignment and start over, either select the Reset radio button, or uninstall and reinstall the application."
  },
  "DocGen/Documentation/HowTos/Samples/SpacePin.html": {
    "href": "DocGen/Documentation/HowTos/Samples/SpacePin.html",
    "title": "Space Pin Sample | World Locking Tools for Unity Documentation",
    "keywords": "Space Pin Sample The functionality demonstrated in the Space Pin example is also available in the main World Locked Physics Sample scene. However, the Space Pin scene offers a simplified and more focused view of the Space Pin feature . It is intended to be closer to the inner workings of a real world application, which needs to align a large object or objects with real world features. It therefore lacks many of the options and runtime UX of the more general World Locked Physics Sample . Default settings The World Locking Tools Manager settings applied may be examined in the Unity Inspector by selecting the WorldLocking > WorldLockingManager node. In particular, World Locking Tools' AutoSave and AutoLoad features are enabled. Therefore, after aligning the spheres and measuring beam to real world features, as described below, then subsequent session on startup will resume that alignment automatically. To reset the sample to a clean state, uninstall it and re-deploy. There are, of course, APIs to reset to a clean slate from script, but these are omitted here for clarity. See IAlignmentManager.ClearAlignmentAnchors() . Also, the demo enables automatic refit operations. See below . Physical space setup This sample contains 4 markers. To fully explore the sample, place physical markers in a space corresponding to the layout of the virtual markers. NOTE: The layout of the virtual markers in the Unity scene may be altered to fit any physical space. There is nothing special about the default layout. However, seeing the benefits of the Space Pinning feature requires a considerable spread of the markers, with separations of at least a few meters. The layout of the physical markers in the room should match the layout of the virtual markers in the Unity scene, as shown in this diagram: Running the Sample Startup On startup for the first session, the origin of the Unity coordinate space will be at the head pose at startup. Looking to the left and forward 6 meters will reveal a cyan sphere, with a cyan cube above it. Looking to the right and back will show a red sphere and cube, 10 meters away. Moving forward from the origin and looking back reveals a white sphere and cube. Eight meters beyond it is a yellow sphere and cube. There are also beams of alternating colors running beneath the spheres. Their purpose will become clear during the walkthrough. Aligning the world Move to any one of the colored spheres. This walk-through will start with the red sphere. Walk to the red sphere. The sphere may be grabbed from a distance using hand-rays in HL2, or gaze and pinch with HL1. On HL2, it may also be grabbed in hand. Look around and find the marker placed in the physical room corresponding to the red sphere. Grab the virtual red sphere by one of the above methods and drag it to the red sphere's marker. Further adjust the sphere to align with the physical marker as well as possible. The other spheres have now moved as well. However, their orientation is unchanged. That is, the virtual world has been translated to put the red sphere on its marker, but the orientation of the world has not yet been affected. Move to another sphere. For this walk-through the white sphere will be next. Repeat the above procedure, moving the virtual white sphere to align with its physical marker. Now the virtual space has been rotated as well as translated, so that the red, white, and cyan spheres are still in a line, with the yellow sphere on a perpendicular offset from the white sphere. Verify that when near the white sphere, it is aligned with its physical marker. Walk to the red sphere and verify that it is aligned with its physical marker. Now walk to a remaining sphere. This walk-through will proceed to the cyan sphere. While the cyan sphere is in line with the red and white spheres, it is not correctly positioned at its marker. The exact vector and magnitude of the error are device and even situation dependent, ut it is likely that it is near correctly on the red-white sphere line, but short of the physical marker. Drag the cyan sphere to its correct alignment with the physical marker. Verify, by walking to each and examining them, that each of the three placed markers is now correctly aligned when in each one's proximity. If desired, repeat this process for the final sphere. Alternate manipulation mode The above walk-through is based on the default configuration in the application, in which the orientation of the virtual space is implied by the relative positioning of the markers. In an alternate mode, the orientation may be explicitly set by grabbing the spheres and rotating them about the Y-axis. The default manipulation mode described above is generally much easier, because positioning of objects in virtual space tends to be much more precise than rotating them to a specific orientation. Similarly, when using QR codes for automatic alignment, the position returned for a QR code marker tends to be much more reliable than the orientation. However, some applications may have advance and specific knowledge of the desired orientation of space, which they may leverage using this second method. To enable the explicit orientation method in the demo, simply disable the active Space Pin Orientable Manipulation components on the marker spheres in: Content > Manipulation > Markers > CyanSphere/RedSphere/YellowSphere/GreySphere. and enable the currently disabled Space Pin Manipulation components. The suggested walk-through is then: Position one of the spheres aligned with its physical marker, and orient it so that the other spheres are in the correct direction from it. The other spheres will now be at incorrect distances, but along approximately the correct vector. Move to the other spheres in turn, and reposition each to align with its physical marker. No further orientation changes should be required. Examining the results If a measuring tool, such as a tape measure, is available, this alignment can be further examined. If the spheres were placed correctly, there should be zero error at each of the spheres. The T-beam running beneath the spheres alternates colors at every meter. By measuring the deviation of the color changes in the beams with the meter marks in the measuring device, the error in the areas between Space Pins may be seen. Refit operations Automatic refit operations will most probably manifest as follows: After positioning one or more of the spheres, the virtual objects are aligned as expected. Subsequently, tracking is lost. Tracking resumes after moving to another physical area. The alignment from the first spheres is lost and has no effect (because they are in a different fragment ). After moving about the new section of space (possibly positioning another sphere), the head moves back to the original space. A refit operation silently and automatically combines the original and new fragments. The alignment from the first spheres becomes effective again (because they are all in the same fragment now)."
  },
  "DocGen/Documentation/HowTos/Samples/WLT_ASA_Sample.html": {
    "href": "DocGen/Documentation/HowTos/Samples/WLT_ASA_Sample.html",
    "title": "Setting up and running the WLT+ASA samples | World Locking Tools for Unity Documentation",
    "keywords": "Setting up and running the WLT+ASA samples Summary World Locking Tools for Unity (WLT) provides a stable coordinate system based on local tracking. When combined with Azure Spatial Anchors (ASA), that stable coordinate system can be persisted across sessions, and shared across devices. This video might give you an idea what to expect when running the sample. What is in this sample? This sample provides assets and scripts to: Configure Unity's global coordinate system with respect to the physical environment. Publish that coordinate system configuration to Azure using Azure Spatial Anchors. Retrieve the data from Azure to restore the coordinate system in later sessions or on other devices. Structure of this document Setup - How to install and deploy the sample application. Notes on running the application, along with suggested steps. Architectural description of the supporting scripts. Setup and tested versions This sample has been developed and tested using: Unity 2020.3.8f1 Azure Spatial Anchors (ASA) v2.9.0 - v2.10.2. Mixed Reality Toolkit v2.7.2 World Locking Tools for Unity v1.4.1 FrozenWorldEngine v1.1.1 You can install WLT and this sample either from WLT releases .unitypackage or from the Mixed Reality Feature Tool. If installing from the FeatureTool, you must not only install the WLT Examples dependency (automatic), but also Import the Examples into your project. See Installing WLT from MR Feature Tool for details. Install the Frozen World Engine DLL into the project The first step is to install the Frozen World Engine DLL, v1.1.1. Instructions here , using either NuGet for Unity, or command-line nuget.exe. Install ASA Creating spatial anchor resources This Quick Start Guide goes through the steps to create an Azure account and the necessary spatial anchors resources. The Account ID, Account Domain, and Account Key will be necessary to run the sample. You will add them into the proper fields on the \"Spatial Anchor Manager\" script, on the SpacePinBinder object in the scene. Other authentication methods are supported, but the Account ID/Domain/Key is the easiest when getting started. Install the SDK Next, install Azure Spatial Anchors v2.9.0 using one of the methods described in these instructions . I used the MR Feature Tool method. Additional setup for Coarse Relocation When using Coarse Relocation, additional setup is required when deploying to Android or HoloLens2. What is Coarse Relocation? Coarse Relocation is a technology that allows you to search for previously created cloud anchors within your current vicinity. Details on Course Relocation can be found in the Course Relocation section of the Azure Spatial Anchors documentation . This sample demonstrates finding cloud anchors either by Coarse Relocation, or explicitly by cloud anchor ID (GUID). If Coarse Relocation is enabled, the following additional setup steps are required. If you aren't interested in Coarse Relocation, you can disable it in the \"Publisher ASA\" component on the SpacePinBinder object. Additional setup steps for HoloLens2 To enable Coarse Relocation on HoloLens2, you must add a permission to the Package.appxmanifest file generated into ARM/WorldLockingTools/Package.appxmanifest (assuming you selected the folder ARM as your build target). If this project is your own, substitute the appropriate name for WorldLockingTools in that path. Add the following line into the Capabilities section: <DeviceCapability Name=\"wiFiControl\"/> For more information, see this post on github . If you miss this step, the Publisher \"Readiness\" will never reach the \"Ready\" state, your framerate will be extremely low, and your UnityPlayer.log (if generated) will be full of exceptions of the form: InvalidOperationException: CoarseReloc: WiFi access has been declined. Request CV: . Response CV: . You will need to add that capability to your Package.appxmanifest each time the solution is built from clean. But subsequent builds from Unity will preserve the capability. In Project Settings/XR Plugin Management, make sure that Windows Mixed Reality is the selected Plugin-Provider under the UWP tab (OpenXR is also supported for WLT with ASA). The MRTK profile XAmple XRSDK ToolkitConfigurationProfile in XAmpleApp/CustomProfiles is suitable for running on HoloLens2. Additional setup steps for Android To enable Coarse Relocation on Android, follow these instructions to configure the Assets/Plugins/Android/mainTemplate.gradle file. Also, in the Assets/Plugins/Android/AndroidManifest.xml, a lot of permissions must be enabled in order to allow access to Wi-Fi on Android. Again, if incorporating elements of this project into your own project, you need to follow these steps as well in order to use Coarse Relocation. More details on required permissions to access Wi-Fi on Android are in this post , and the post it links to. Samples of the modified mainTemplate.gradle and AndroidManifest.xml are included in the WLT-ASA Sample Project , which is configured specifically for using WLT and ASA together. They can be copied directly into your project, after enabling \"Custom Main Manifest\" and \"Custom Main Gradle Template\" in the Player Publishing Settings as described. When you hit Build & Run, if your build fails with a Shader error in the MRTK_Standard material, just try Build & Run again. It works second try for me. There is some info on that in the MRTK issues, but as far as I can tell all the info there is incorrect. In Project Settings/XR Plugin Management, make sure that ARCore is the selected Plugin-Provider under the Android tab. The MRTK profile XAmple AR ToolkitConfigurationProfile is suitable for running on mobile. Don't forget to run the script Mixed Reality/Utilities/UnityAR/Update Scripting Defines after switching to Android or iOS. What the buttons do Toggle Pins - When the SpacePins are not active, their manipulation handles may be hidden. Publish - Save the current configuration, enabling its retrieval in later session or on other devices. Load Oracle - Use previously stored bindings to restore a spatial configuration. Clear Oracle - Delete all backing resources, especially Azure spatial anchors, and clear the bindings oracle. Search - Find all Azure spatial anchors in the immediate vicinity, and restore the spatial configuration from them. Purge - Find all Azure spatial anchors in the immediate vicinity, and clear them. Reset Pins - Undo any Space Pin manipulations. Does not clear any Azure spatial anchors. The menu on mobile is slightly different in form, but button positions and meanings are the same. Walkthrough - Publish from HoloLens2 Place the scene using SpacePins When you start up the sample, the coordinate system is position and oriented based on the head tracker pose at startup. Which is to say, it is fairly arbitrary. The first thing to do is to adjust the coordinate system to a desired reference state. The sofa in the PinTestSofa scene is 2.18 meters long, 0.78 m high, and 1.0 m deep. The SpacePin handles on each end of the top back of the sofa are, therefore, 2.18 m apart, and 0.78 m off the ground. I recommend measuring and placing temporary markers 2.18 m apart, at some convenient height. Alternatively, you can adjust the scene to fit your physical space. Having built and deployed the application to a HoloLens2 device, wait until the status on the floating menu says Ready (hint - the status line will go from red to white when ready). One at a time, grab each of the SpacePin handles (the white wireframe spheres) and drag it into position relative to your reference markers. After releasing each of the markers into position, the scene should have shifted to restore the back of the sofa relative to the SpacePin. The objects in the scene aren't being moved, the entire coordinate space is adjusted so that the original coordinates of the SpacePins are at the location in the physical world that you dragged them to. Publish the coordinate space Having established the space that you want, you can now Publish that space to make it available in later sessions and on other devices. If using Coarse Relocation, it's a good idea to clear out any previously created cloud anchors at this point. Hit the \"Purge from Search\" button and wait for that to complete. Now, on the floating menu, hit the \"Publish\" button and wait for it to complete. Walkthrough - Consume from HoloLens2 using Coarse Relocation Start the application again on a different HoloLens2 device, or on the same device after closing the previous session. When the status shows as Ready, press the \"Load from Search\" button. When the operation completes, the Unity global coordinate system will have realigned to your physical environment as it was in the previous (Published) session. Walkthrough - Consume from HoloLens2 using IBindingOracle (SpacePinBinderFile) When the bindings are published on a device, or when they are restored from search, they are recorded into an IBindingOracle. This sample includes the most basic Oracle, one that simply writes the bindings to a text file. Restart the application to a new session. If this is the same HoloLens2 as the Publish was performed from, then there is a binding file left from the publish. If this is a different HoloLens2, but a Search was successfully performed in a previous session, then the binding file will be left from that. Hit the \"Load from File\" button to load the previously recorded bindings and restore that coordinate space. Walkthrough - Consume from Android using Coarse Relocation The UX looks slightly different on Android, but works exactly the same. The main difference is that a little more scanning of the environment at startup is required relative to HoloLens2, before ASA is ready to proceed. When the system shows as Ready, you can hit the blue button (3rd from right) to search for the previously published bindings and restore the coordinate system. Walkthrough - Consume from Android using IBindingOracle (SpacePinBinderFile) Having successfully completed a Load from Search, a bindings file has been left on the device. In later sessions you can just hit Load from File to restore the coordinate system. Alternatively, you could just copy the bindings text file from the publishing device to the consuming device. The default location of the bindings text file is: HoloLens2: User Folders/LocalAppData/WLT-ASA/LocalState/BinderFile.txt Android: Internal shared storage/Android/data/com.WorldLockingTools.WLTASA/files/BinderFile.txt See also WLT+ASA software overview Azure Spatial Anchors Quick Start World Locking Tools for Unity"
  },
  "DocGen/Documentation/HowTos/Samples/WLT_ASA_Software.html": {
    "href": "DocGen/Documentation/HowTos/Samples/WLT_ASA_Software.html",
    "title": "WLT+ASA Overview of supporting software | World Locking Tools for Unity Documentation",
    "keywords": "WLT+ASA: Overview of supporting software IBinder - binding SpacePins to Azure Spatial Anchors The IBinder interface is at the center, implemented here by the SpacePinBinder class . The SpacePinBinder is a Unity Monobehaviour, and may be configured either from Unity's Inspector or from script. Each IBinder is named , so a single IBindingOracle can manage bindings for multiple IBinder s. IPublisher - reading and writing spatial anchors to the cloud The IPublisher interface handles publishing spatial anchors to the cloud, and then retrieving them in later sessions or on other devices. IPublisher is implemented here with the PublisherASA class . Pose data in the current physical space is captured and retrieved using Azure Spatial Anchors. When a spatial anchor is published, a cloud anchor ID is obtained. This ID may be used in later sessions or on other devices to retrieve the cloud anchor's pose in the current coordinate system, along with any properties stored with it. The system always adds a property identifying the cloud anchor's associated SpacePin. It should be noted that the IPublisher , and the PublisherASA, don't know anything about SpacePins. IPublisher doesn't know or care what will be done with the cloud anchor data. It provides a simplified awaitable interface for publishing and retrieving cloud anchors. Read versus Find If a cloud anchor's ID is known, the cloud anchor may be retrieved by its ID. This method is the most robust way to retrieve a cloud anchor. The method is Read . However, there are interesting scenarios in which the IDs for the cloud anchors within an area aren't known by a device, but if they cloud anchors could be retrieved, their spatial data and properties would combine to provide enough information to make them useful. Find searches the area around a device for cloud anchors, and returns any that it was able to identify. This process is known as coarse relocation . IBindingOracle - sharing cloud anchor IDs The IBindingOracle interface provides a means of persisting and sharing bindings between SpacePins and specific cloud anchors. Specifically, it persists space-pin-ID/cloud-anchor-ID pairs, along with the name of the IBinder . The oracle's interface is extremely simple. Given an IBinder , it can either Put the IBinder 's bindings, or it can Get them. Put stores them, and Get retrieves them. The mechanism of storage and retrieval is left to the implementation of the concrete class implementing the IBindingOracle interface. This sample implements possibly the simplest possible IBindingOracle, in the form of the SpacePinBinderFile class . On Put, it writes the IBinder 's bindings to a text file. On Get, it reads them from the text file (if available) and feeds them into the IBinder . ILocalPeg - blob marking a position in physical space The ILocalPeg interface is an abstraction of a device local anchor. In a more perfect world, the required ILocalPegs would be internally managed by the IPublisher . However, device local anchors work much better when created while the device is in the vicinity of the anchor's pose. The IPublisher only knows where the device local anchors should be placed when they are needed, not at the optimal time of creating them. The SpacePinASA does know when the best time to create its local anchor is. When the manipulation of the SpacePin ends and its pose set, the SpacePinASA requests the IPublisher to create an opaque local peg at the desired pose. The SpacePinBinder then pulls the ILocalPeg off the SpacePinASA, and passes it to the IPublisher to be used in creating a cloud spatial anchor . See also WLT+ASA Samples Setup and Walkthrough Space Pins Concepts Space Pins Sample"
  },
  "DocGen/Documentation/HowTos/Samples/WorldLockedPhysicsSample.html": {
    "href": "DocGen/Documentation/HowTos/Samples/WorldLockedPhysicsSample.html",
    "title": "World Locked Physics Sample | World Locking Tools for Unity Documentation",
    "keywords": "World Locked Physics Sample. The Physics Beam Sample offers a few virtual physics experiences that are enabled by World Locking Tools' world locked coordinate system. Back story On HoloLens, the relationship between a spatial anchor and the head or other spatial anchors may change at any time, because of incoming sensor data, or even reprocessing of existing data. Unity's spatial anchors react to changes in the underlying spatial anchor's pose by dragging the attached GameObject along with it. This movement causes difficulties for physics simulation: Because the spatial anchored GameObject's pose is explicitly set by the spatial anchor each frame, it can't be set by simulation (for example, momentum). Because the spatial anchor is frequently updating its GameObject's pose, it will not appear to be at rest relative to other still RigidBodies. Because of implicit shifts of Unity's coordinate system, as spatial anchors adjust the coordinates of static Holograms to keep them fixed relative to the real world, physics computations such as routes and trajectories will be off. For example, a projectile perfectly aimed at a Hologram will still miss if the Hologram is repositioned by its spatial anchor in between the trajectory computation and it reaching the target. When the relationships between measured spatial anchors and the visible virtual objects locked to them becomes inconsistent, then rather than adjusting the virtual objects as Unity's spatial anchors do, World Locking Tools adjusts the head transform to minimize perceived artifacts from those inconsistencies. This allows the virtual objects to appear consistent in a stable coordinate space, eliminating the above issues. Building the sample The sample requires the SpatialPerception capability. The Microphone capability is also required for voice commands. This sample requires that the following layers be added to the project's Tags & Layers: Pillared SpatialMapping Running the demo The controls HUD This basic HUD isn't specific to this Physics Beam Sample, but only allows runtime control of World Locking Tools' behavior to explore its capabilities. It's available as a drop-in for development on any application using World Locking Tools, as described in World Locking Tools' Initial Setup . Diagnostic statistics are displayed by default, but can be disabled from the Control HUD. The modes radio buttons At any given time, the sample can be in any one of the following modes: Idle - The physics sample isn't currently processing input. The HUD and radio button menu, of course, continue processing inputs. Throw Dart - A trajectory is computed, based on basic physics laws, and displayed. The displayed arc shows the path a projectile fired (via select gesture) will follow. The thrown dart will follow a ballistic trajectory, bouncing off of any collision surfaces, including Spatial Reconstruction (SR) meshes, that it impacts. These Darts are \"removable\", as described below. Add Pillars - On a select gesture, a ray is cast into the world in the indicated direction. If it finds a collidable surface, a vertical pillar is added to the scene there. Every Pillar added is collidable, and can serve as a beam support, as described below. However, there are two flavors of Pillars added: If the pillar is set upon a \"removable\" surface, then the pillar is physically simulated (for example, can be knocked over). Else the pillar collidable, but static. Effectively, this rule means if a pillar is added on the SR mesh, it will be static, but otherwise it will be dynamic. Pillars are \"removable\". Add Beam - On first select, a ray is cast into the scene to find the first endpoint of the beam. After that, as the selection ray is moved through the scene, a line is drawn from the first endpoint to the current endpoint. The second select gesture will create a beam stretching between the first and current endpoints. Balancing the Beam with endpoints on Pillars clearly requires a space in which the endpoint Pillars will remain fixed relative to each other. Beams are \"removable\". Remove Objects - On select, if the ray cast object is \"removable\", then it's removed from the scene. Any objects being supported by the removed object will then fall. See also class PhysicsBeamSample ."
  },
  "DocGen/Documentation/HowTos/Tools.html": {
    "href": "DocGen/Documentation/HowTos/Tools.html",
    "title": "Tools and visualizers | World Locking Tools for Unity Documentation",
    "keywords": "Tools and visualizers The tools and visualizers in the Microsoft.MixedReality.WorldLocking.Tools namespace are intended to help during development. They may also be a starting point for advanced direct interaction with the World Locking Tools (WLT) system. While they aren't intended for direct usage as is within an application, the application developer is free to choose to do so. The WorldLocking.Core is intended to work as-is in any appropriate application scenario. However, the Tools may make assumptions about the application. These assumptions may make them inappropriate in some situations. Before incorporating any of the tools directly within your shipping application, then, consider creating a version of that tool customized for your own requirements and resources. Tools Adjusters Adjusters are components that handle refit events . In particular, they create Attachment Points . In the event of a refit operation, the AttachmentPoint serves as a notification callback. The Adjuster handles that event appropriately. See further conceptual discussion of AttachmentPoints . The exact right reaction to a refit event will vary for different types of objects, and is very application-specific. For example, if the object's Fragment is currently inactive, then should the object be displayed? For some applications, since the proper placement of the object cannot be determined, it should be hidden. For other applications, it might be better to display the object in a temporarily incorrect pose than to suffer the confusion of its disappearance. And even for applications which should hide the object, there are various ways to perform the hiding (for example, disabling versus moving far away). The AdjusterFixed and AdjusterMoving components handle two common scenarios minimally. The AdjusterFixed component assumes that its target is generally non-moving. If the World Locking Tools sends an adjustment pose due to a refit event, it is intended to keep the AdjusterFixed's object stationary in the world. In contrast, the AdjusterMoving component assumes that its target is mobile through the Unity coordinate space. It keeps the World Locking Tools system appraised of its target's location, so that in the event of a refit operation, the system can give the most accurate correction to keep the target's position relative to the physical world constant at that moment. Adapters The Adapter components are intended for illustration only. If you find yourself using one of the Adapters, you should probably rethink how you are trying to use World Locking Tools. In particular, MRTK already has built-in adapters, so no further coordinate system transform is required on the part of the application. There may be times, especially if not using MRTK, when conversion from native resources, which will report in Spongy Space coordinates, to Frozen Space. In those cases, the application developer may find one of the Adapters included here to be a good reference. WorldAnchorAdapter - An WorldAnchor will adjust an object's pose in Spongy space to remain fixed in physical space. This is redundant with the world-locked space provided by World Locking Tools, and so the object will drift in Frozen Space. This adapter allows a WorldAnchor to maintain the pose of an object in Frozen Space. This is unnecessary except for diagnostics. All objects in Unity's global coordinate space are world-locked by World Locking Tools. ToggleWorldAnchor - Similar to the WorldAnchorAdapter, but can be toggled. Also automatically converts to regular WorldAnchor behavior when the WorldLockingManager is disabled. Useful only for diagnostics. FrozenSpatialMapping - An adapter manage and correctly render the results from a SurfaceObserver . The MRTK Spatial Awareness system provides all of this functionality and more, and requires no adapter to work with World Locking Tools. FrozenTapToAdd - Directly interfacing with Unity's Input system requires conversion of incoming coordinate data as shown here. This is unnecessary with MRTK's input system. Visualizers Anchor Graph Visualization The AnchorGraphVisual and its associated prefab are the core of the supplied visualizations. The component pieces are as follows: Axes - The current poses for the origins of Spongy Space (green) and Frozen Space (blue) are shown as standard 3 arrow axis identifiers. Spongy Anchors - These are the native underlying anchors which have been created to feed the Frozen World Engine optimization. Each is represented by a ring, along with a text tag identifying it. Also, more information is conveyed by color and size. An active tracked anchor will be green. A tracked anchor with zero relevance will be red. An unsupported anchor will be yellow. The larger the ring, the greater the relevance for that anchor. Frozen Anchors - These are the corresponding reference points in Frozen Space. In the absence of tracker error, these will be exactly aligned with the Spongy Anchors. Spongy-Frozen Edges - These connect the Spongy Anchors to their corresponding Frozen Anchors. Since in the absence of tracker error, these would be coincident, not seeing these edges means everything is working perfectly. In any case, these edges should not be longer than a few centimeters. They are red on the frozen end. The color fades to blue on the spongy end. Anchor Edges - These thin blue lines show the connections between Spongy Anchors in the anchor graph. Enabling the display of the anchor graph that World Locking Tools generates as the user moves about the physical environment requires only dropping the WorldLockingTools > Prefabs > AnchorGraphVisual prefab into the scene. It is customarily added as a sibling to the WorldLockingContext, but its exact placement in the hierarchy is unimportant. However, it should not be placed in the camera hierarchy. The spatial anchors which WLT creates and uses internally are created at the camera position. Because it is disconcerting to be walking through a field of anchor visualizations at eye level, the system defaults to displaying them 1 meter down from their true position. To see the anchor visualizations at the actual anchor positions, set the Anchor Graph Visual component's Vertical Displacement parameter to zero. Additional output The World Locking Examples includes text diagnostics. Most of these are relevant only to developers of the World Locking Tools, rather than clients of its abilities. However, they are available for read and, as shown in the StatusToText script, for real-time display. For postmortem analysis, the Diagnostics section of the WorldLockingContext can be very useful in reporting Frozen World Engine failures. See Reporting a bug for further information."
  },
  "DocGen/Documentation/HowTos/Troubleshooting.html": {
    "href": "DocGen/Documentation/HowTos/Troubleshooting.html",
    "title": "Trouble shooting | World Locking Tools for Unity Documentation",
    "keywords": "Trouble shooting Annoying issues will be noted here. World Locking issues Low frame rate World Locking Tools should have no discernable impact on your framerate. (An exception is that the visualizations will eventually drag down your framerate after many anchors have been created, but the visualizers are just for diagnostics, not for shipping with your application.) If you see a framerate drop after adding World Locking Tools to your application, check your Unity logs. That usually means an exception is being repeatedly generated. Missing dll's etc. This has been seen from the Frozen World Engine dll. Go to NuGet for Unity: NuGet > Manage NuGet Packages > Installed uninstall and re-install the latest FrozenWorld.Engine package. See NuGet Setup . Alternately, install using the MR Feature Tool and have dependencies installation handled for you. Missing 'FrozenWorld' namespace Errors like the following (usually a lot): Assets\\WorldLocking.Engine\\Plugin.cs(10,37): error CS0234: The type or namespace name 'FrozenWorld' does not exist in the namespace 'Microsoft.MixedReality' (are you missing an assembly reference?) It is missing the FrozenWorld.Engine DLL. See NuGet Setup . Alternately, install using the MR Feature Tool and have dependencies installation handled for you. It's not working Check the Unity logs for errors and exceptions. Check that your scene camera is attached to at least one other object. See the setup in WorldLocking.Examples.WorldLockingPhysicsSample for example. If you are doing dynamic camera manipulation, you may need to keep the WorldLockingManager informed of the current camera. See WorldLockingManager.AdjustmentFrame and WorldLockingManager.CameraParent . More general Unity/AR problems \"DirectoryNotFoundException: Could not find a part of the path\" The path has grown too long. See fuller explanation here . \"A remote operation is taking longer than expected\" message box then failure to deploy Check your USB connection. A bad cable, a bad port, missing IPOverUSB, can all cause this. But it's probably somewhere on the communication path from your PC to your device. Missing Windows SDK components Mismatch between Visual Studio version indicated in Unity versus Visual Studio version you're trying to build with. Check: Unity > File > Build Settings > Visual Studio Version Especially dangerous is if that's set to Latest Installed and you have multiple versions of Visual Studio installed. On HoloLens, application starts up as a slate, rather than an AR experience If targeting the Unity's built-in VR support, also known as Legacy XR, then check: Unity > Project Settings > Player > XR Settings You must have Virtual Reality Supported checked, and the Windows Mixed Reality in Virtual Reality SDKs. If using Unity's AR Subsystems / XR SDK, then check that you've followed all the steps here . Likely culprits are missing one of the required packages, or if using MRTK, that the appropriate profile has not been setup on the MixedRealityToolkit object. When building for ARM on HoloLens2, app stops at startup. ARM64 works fine Known issue . The fix is either disable Graphics Jobs under Project Settings > Player > Other Settings > Graphics Jobs or just build for ARM64."
  },
  "DocGen/Documentation/HowTos/UsingWLT/AlignMyCoordinates.html": {
    "href": "DocGen/Documentation/HowTos/UsingWLT/AlignMyCoordinates.html",
    "title": "Align my coordinates | World Locking Tools for Unity Documentation",
    "keywords": "Align my coordinates A brief summary of World Locking Tools capabilities presented so far is in order. With drag and drop ease , WLT will provide a coordinate space which is stationary relative to the physical world. That space can be made optionally persistent , so that physical features around a point in space in this session are the same as the physical features around the point in previous sessions. The application can opt in to callbacks allowing it to adjust to larger scale tracking corrections . The Adjuster scripts can be used as is or as examples for this. Having gotten all of those benefits, your application might have a further requirement, to align the coordinate system with physical space at a small number of discrete points. The usual reason for this is that there is a large virtual feature (or system of objects) in your application which needs to match up at physical features. Because of distortions in tracker space caused by tracker error, this is actually impossible. But an approximation can be made by matching virtual to physical points on a perceptually driven priority. In essence, the pin closest to you matches corresponding point in the physical world best. In order to do that, the system needs more information from your application. The SpacePin component is the managing object for AlignmentAnchors. The correspondences are made in the form of pairs of virtual and physical poses. Motivation for SpacePins and their usage are detailed elsewhere in this documentation. There are also samples of their usage both in this repo and in the sibling Samples repo . See also Before You Start Most Basic Setup Loss of Tracking Across Sessions"
  },
  "DocGen/Documentation/HowTos/UsingWLT/BeforeGettingStarted.html": {
    "href": "DocGen/Documentation/HowTos/UsingWLT/BeforeGettingStarted.html",
    "title": "Before getting started | World Locking Tools for Unity Documentation",
    "keywords": "Before getting started The World Locking Tools for Unity offers a very powerful API for fine control over the services it offers. On first look it can be quite overwhelming. A reasonable question might be: How much code should I expect to write to use WLT? The answer, which may surprise you, is \"None.\" WLT has been carefully structured to handle the vast majority of usage cases with a simple drag and drop interface. Some slight modifications to your scene, as described here , and your application is world-locked and anchor free. Customizing behavior through code There are a small number of cases where you might want to do additional coding against the WLT APIs. First, you might want to customize your customers' experiences, especially in extraordinary circumstances, such as loss of tracking. Some such bespoke behavior is described in the Handling exceptional conditions section. Secondly, you might want to do your WLT setup at runtime. Any configuration of WLT which can be done in the Unity Inspector can be done by script calls. Likewise, any WLT object or component that can be added to the scene and deployed at build time, can instead be added to the scene at runtime from script. The final case is where additional input is required from your application in order to perform a service for you. For example, in order to align your coordinate system with physical world features in a desired way, you must give an indication of how you want the coordinate system aligned. This additional input comes in the form of pairs of virtual and tracking space poses. Start off easy WLT strives to maintain this pattern throughout. To get the most commonly desired functionality requires no coding and minimal setup. Default behavior is implemented as available components. Customizing the default behavior requires only enough code to override the provided behavior with the behavior you want. Additional features require only enough interaction with your application to indicate your intentions. There is a lot of API surface in WLT. Those are growth opportunities for farther down the road, so that WLT never boxes you in. But start off simple. You may find WLT does everything you require from it without a line of code. First, read and understand this conceptual documentation. At appropriate places you will find links to the API documentation, as a reference for exact calling syntax. Direct links to the overall API documentation are included below. See also Most Basic Setup Loss of Tracking Across Sessions Pinning It Down API Documentation WLT Core WLT Tools WLT with ASA"
  },
  "DocGen/Documentation/HowTos/UsingWLT/JustWorldLock.html": {
    "href": "DocGen/Documentation/HowTos/UsingWLT/JustWorldLock.html",
    "title": "Just world-lock everything | World Locking Tools for Unity Documentation",
    "keywords": "Just world-lock everything Achieving baseline world-locked behavior for your application requires no code and very little setup. Before getting to the setup, which is described below, let's look at that baseline behavior in more detail. Basic locking of the global Unity coordinate system to the physical world Integrating WLT into your application provides a number of features straight out of the box, with no additional code or interaction with your app. Simply put, with WLT, a point in Unity's global coordinate system will maintain its position relative to physical world features. That means that if you place a hologram in your global space, it will stay where it is in the physical world. No application use of anchors is needed. Furthermore, if WLT's persistence feature is enabled, then that same point in Unity's global coordinate space will have the same relationship to physical features in subsequent runs of the application. Do you want to save where a hologram is in the physical world and have it appear there the next time you run your application? Just save its global pose, and restore it next run. In addition to the simplicity provided, there are a number of advantages to using WLT rather than anchors for world-locking your scene. How to set it up Automated setup For the most automated setup experience, install the latest WLT Core from the MR Feature Tool , then run the WLT Configure scene utility from the Mixed Reality Toolkit Utilities menu. The Configure scene utility can be rerun at any time. For example, it should be rerun if the AR target has been changed from Legacy to XR SDK. If the scene is already properly configured, running the utility has no effect. During early development, adding the visualizers can be helpful to ensure WLT is setup and working properly. They can be removed for production performance, or if for any reason are no longer needed, using the Remove visualizers utility. More details on the visualizers can be found in the Tools documentation . Manual setup Setup for gaining the advantages of baseline WLT behavior is very simple, and can be broken into four (4) steps. The first two steps can be skipped if installing from the MR Feature Tool . Import the Frozen World Engine NuGet package into your project. Import the World Locking Tools unity package into your project. Drop the WorldLockingManager prefab into your scene. Add an \"adjustment\" game object to your camera hierarchy. A walk-through of this basic setup con be found in the World Locking Tools Samples , a sibling repository devoted to more specialized examples of WLT use. See also Before You Start Loss of Tracking Across Sessions Pinning It Down"
  },
  "DocGen/Documentation/HowTos/UsingWLT/LossOfTracking.html": {
    "href": "DocGen/Documentation/HowTos/UsingWLT/LossOfTracking.html",
    "title": "Handling exceptional conditions | World Locking Tools for Unity Documentation",
    "keywords": "Handling exceptional conditions For the most part, WLT can detect and fix tracking errors quietly without the application's involvement. But some exceptional conditions lead to errors which the application might want to adjust to. Loss of tracking is an example of such a condition. Tracking might be lost at any time, for any of a number of reasons. The sensors might be covered, the lighting might be inadequate, or there might not be any visible features around the camera for it to track. Fuller discussions of these exceptional conditions on a conceptual level , including WLT's features aimed at mitigating them , are contained elsewhere in this documentation. Here, we'll dig into how the application developer can (optionally) take advantage of those features to customize the application's behavior during these exceptional conditions. AttachmentPoints As discussed more fully here , an attachment point is the contract between WLT and the application, for notification that exceptional conditions have occurred, along with appropriate data which the application may use to respond. Adjuster components An implementation of such application responses is available in the form of the \"adjuster\" components. The primary of those is the AdjusterFixed component. The AdjusterFixed can be used as-is, but understanding what it does can be instructive, especially for a developer wanting to further customize the behavior. It is important to recognize that the Adjuster components serve two roles: They manage the underlying AttachmentPoint. They provide implementations of the application's responses to exceptional conditions. AttachmentPoint management Examining the Start() and OnDestroy() members captures most of the management of the AttachmentPoint required. On Start() , the underlying AttachmentPoint is created, giving the AdjusterFixed's member functions as callbacks (see below). In OnDestroy() , these callback connections are severed and the AttachmentPoint released. Condition handling callbacks The two callbacks implement the application's desired behavior during these exceptional conditions. Handling tracking state In HandleStateAdjust() , the AdjusterFixed component disables objects contained in a fragment which isn't currently being tracked. protected virtual void HandleAdjustState(AttachmentPointStateType state) { bool visible = state == AttachmentPointStateType.Normal; if (visible != gameObject.activeSelf) { gameObject.SetActive(visible); } } While this simple behavior is perfect for many applications, it is easy to imagine cases when it would not be sufficient. The object should be hidden, but not disabled (should continue updating). An alternate method of hiding the object is preferred (e.g. moving it beyond the far clipping plane). Rather than hiding the object, it should be rendered with a different material (e.g. X-ray material). Rather than hiding the object, an alternate object should be rendered. Etc. Fortunately, the application developer is free to implement any of these behaviors, or other behaviors only limited by imagination. The simplest means of specifying custom behavior is to implement a custom component deriving from AdjusterFixed. The AttachmentPoint management can then be inherited, and the handlers overridden to create the custom behavior. Handling repositioning As described in the conceptual documentation , the WLT system may decide that an object can be best held in its position in the physical world by repositioning it in frozen space. It will inform the application of that situation via the AttachmentPoint mechanism. The application is, of course, free to ignore such adjustments. However, the behavior provided by the AdjusterFixed (and AdjusterMoving) component is to apply that repositioning transform immediately. protected virtual void HandleAdjustLocation(Pose adjustment) { Pose pose = gameObject.transform.GetGlobalPose(); pose = adjustment.Multiply(pose); gameObject.transform.SetGlobalPose(pose); } That is almost always what the application wants. The question might be asked, then, of why anyone would want to override the AdjusterFixed's HandlePositionAdjust() function. The answer, of course, is that the application might want to perform other actions in addition to correcting the position. A temporary material effect might help notify the user that a change has been made. The repositioning might be spread out over a few seconds. Or if a repositioning is too drastic, the application might prefer to discard the object, rather than moving it. AdjusterFixed vs AdjusterMoving A closer look at the AdjusterMoving component shows it to be nearly identical to the AdjusterFixed component it derives from. The difference between the two is that the AdjusterMoving assumes that its target is constantly being moved around the environment. Therefore, each update it notifies the WLT system of its new Pose. The cost of the AdjusterMoving comes mostly from the addition of an Update() function, rather than the work done within the function. However, for an object that is \"mostly\" stationary, and is only moved infrequently from script, it can be advantageous to use an AdjusterFixed component, and call AdjusterFixed.UpdatePosition() after each time the object is moved. Customize the behavior, but only if you want to Again, the pattern here is hopefully consistent throughout the World Locking Tools. WLT provides simple but generally useful baseline behavior. It is hoped that this implementation will either: Satisfy the needs of your application. Provide a baseline implementation for you to enhance. Give a sample implementation from which you can go wild. See also Before You Start Most Basic Setup Across Sessions Pinning It Down"
  },
  "DocGen/Documentation/HowTos/UsingWLT/PersistenceTricks.html": {
    "href": "DocGen/Documentation/HowTos/UsingWLT/PersistenceTricks.html",
    "title": "Persistence tricks | World Locking Tools for Unity Documentation",
    "keywords": "Persistence tricks Persistence is available where supported by the underlying platform. Currently, this is limited to the HoloLens family of devices, using Unity's built-in VR support (Legacy XR). Basic persistence Basic persistence for World Locking Tools comes enabled by default. This enabling comes in two parts. The relevant checkboxes here are the \"Auto Load\" and \"Auto Save\", which are checked. You might notice they are greyed out. That's because they are part of the \"Use Defaults\" choice. Disabling \"Use Defaults\" enables the selection of arbitrary combinations of the Automation options. Further reading is available on these settings , and on manipulating them from script . AutoSave The AutoSave option directs WLT to make frequent and regular state saves while running the application. At any time, the application may be terminated with minimal loss of state. AutoLoad The AutoLoad option directs WLT to load any previously saved state at startup. This effectively allows the application to resume a new session where it left off (w.r.t. WLT) from the last session. Full persistence With both AutoSave and AutoLoad enabled, WLT operates seamlessly across sessions. While the position and orientation of global space are arbitrary on the first run (since there is no previous state saved, it uses the head pose at startup as the origin), subsequent runs will share that same coordinate frame. This leads to interesting behavior when the application starts a new session in a space disconnected from the previous session's space. See the persistence by location section below for details. Note The AutoSave and AutoLoad settings also apply to global SpacePins. See below for details. Application control over persistence The default full persistence is suitable for a broad range of applications. Some applications, however, might want finer control over the process. It may seem odd that enabling WLT automatic persistence is broken into two properties, the AutoSave and the AutoLoad. Examining cases where the two are used independently might provide insights into the overall persistence system. AutoSave but not AutoLoad With this configuration, WLT is set to periodically save its state. However, it will not automatically load any persisted state at startup. Rather, the system will start in a fresh state, as if it is the first time being run on this device. Only after an explicit request to Load() will it restore the previous session's state. This allows the application to decide whether or not restoring previous session state would be appropriate, and even to modify the data being restored if necessary. The general WLT save state is in the file \" LocalState /frozenWorldState.hkfw\". Once created by WLT, that file can be copied to another location and restored back at the application's discretion. The save file for alignment (SpacePin) data defaults to \" LocalState /Persistence/Alignment.fwb\". However, that can be overridden by the application via the alignment manager's SaveFileName . The decision to load the previous session's state with this configuration needs to be made at startup. Once running the previous session's saved state will be overwritten with this session's state. For a more flexible setup, see Manual save and load below. Manual save but AutoLoad In this configuration, WLT will load any available state from a previous session at startup. It will not, however, automatically save state. This allows the application to decide if and when state is worth saving, with a call to Save() . AutoLoad only tells WLT to load any available state at startup. The application is free to restore any saved state at any time with an explicit call to Load(). Manual save and load The application may choose to keep total control over the save and load process. State will then only be saved with an explicit call from the application to Save() , and only loaded with an explicit call to Load() . The state loaded by the call to Load() might have been saved earlier in this session, or in a previous session. Disabling persistence As explained above, persistence is always available to the application from script. Automated persistence may be enabled and disabled from script or through the WorldLockingContext in the Inspector. If automated persistence is disabled, WLT will make no attempt to save or load state without explicit requests from the application. Of course, since the AutoLoad directive only affects whether to load or not at startup, changing the value from script after startup has no effect. A caution during development As noted above, the location of the save files for global WLT and alignment are global to the application. In particular, the alignment nodes, also known as SpacePins, are persisted by name (see below ). If an application saves state with a set of SpacePins from one scene, and then loads state with a set of SpacePins from another scene, and both sets of SpacePins share common names, then the behavior is undefined. There are multiple ways around this issue. If possible, the best is to simply avoid reusing SpacePin names within a project. If after re-deployment, you see unexpected scene sliding behavior, try deleting WLT save state. Likewise, when radically changing the application, the overly cautious might want to either delete their WLT save files from device, or simply uninstall the application before installing the new version. Persistence by location The scenario There is an interesting class of applications which are run in multiple physical locations. The application might be run in Room A, the device closed, relocated, and then the application restarted in Room B. Room B might be down the hall from Room A, or might be on another continent. The application and the device have no way of knowing. For simplicity, let's say that the application is configured for manual WLT persistence. A walkthrough Consider these unconnected rooms A and B. The application is started in Room A. After establishing a contiguous frozen coordinate space within the room, the entire room maps to fragment 1. A persistent hologram Object X is placed in the room. Then the application saves state, and is quit. The device is powered off, taken to Room B, and started again. The device recognizes this to not be Room A, so WLT assigns a new fragment ID to its contents, say ID == 29. Why 29? Because it isn't 1. Fragment IDs are arbitrary in value, other than one fragment's ID will not be FragmentId.Invalid, or FragmentId.Unknown, or the same as any other known fragment. Now there are two fragments, and no way to merge them (since there is no information available on their relative locations). The interested application developer might ask: I placed a persistent Object X in Room A, what happens when Object X is loaded when the application starts in Room B? The answer is that the behavior is left to the application developer to determine. The current fragment ID when the Object X is placed in Room A is available, and can be persisted. The application can then decide at startup whether to show Object X or not based on whether the current fragment is the same as when it was created or not. Here, the developer decides (and implements) that Object X will only be loaded if the current fragment ID is one, and Object Y, from Room B, will only be loaded if the current fragment is 29. The persistence of the fragment ID associated with a space is saved as part of the persistence of World Locking Tools. However, the persistence of the fragment ID associated with an object, as well as actions to take based on it, are left to the application. Along with the object's associated fragment ID, its Pose in global space can be saved. Then if the fragment ID matches, after the object is loaded its Pose can be restored, returning it to its position in the physical world during the last session. With World Locking Tools persistence, a Pose remains fixed across sessions relative to the physical world features around it. Persistence of SpacePins SpacePins can be thought of as application-side wrappers for AlignmentAnchors. Whereas SpacePins (and derived classes) are Unity components, AlignmentAnchors are purely conceptual; there is no class or type corresponding to an AlignmentAnchor. Therefore, in this discussion, SpacePins and AlignmentAnchors will be used interchangeably, with a general preference for SpacePins. However, it might otherwise be confusing that an AlignmentManager can persist SpacePins, when it has no notion of SpacePins. That is because the AlignmentManager manages the conceptual AlignmentAnchor, which embodies the essence of a SpacePin, and from which a SpacePin can be reconstituted. There are more application level controls for the persistence of SpacePins than with the general WLT persistence system, because SpacePins are inherently more driven by application input than rest of the World Locking Tools. It is important to remember that SpacePins (and AlignmentAnchors) are persisted by name. This is a slightly stronger requirement than the general one that no two active SpacePins in the same IAlignmentManager have the same name. If persisting SpacePins, then no two SpacePins in the same database can have the same name, whether active or not. Alignment manager databases Each IAlignmentManager has a database of SpacePins by name, as implied by its implementation of RestoreAlignmentAnchor(string uniqueName, Pose virtualPose) . The global alignment database There is one global IAlignmentManager, owned by the WorldLockingManager.GetInstance(). As mentioned, its default save file location is determined by the property SaveFileName . Notice that the SaveFileName is a property on class AlignmentManager, not the interface IAlignmentManager. An IAlignmentManager implementation might implement persistence without any concept of files or filenames. The SaveFileName is an artifact of the way AlignmentManager implements persistence, and so is restricted to the AlignmentManager. Local alignment databases There can be any number of sub-space alignment managers, one for each AlignSubtree , appearing as the field AlignSubtree.alignmentManager. Additionally, the application can create its own AlignmentManager instances, or even its own classes derived from IAlignmentManager. Each AlignSubtree component's AlignmentManager has its own save file location, which defaults to the GameObject's name, with the extension \".fwb\". For example, if the AlignSubtree component is on a GameObject named \"MyRoot\", then the save file would be named \"MyRoot.fwb\". A forward slash '/' can be used to place it in a sub-folder. It would probably be bad for two AlignSubtree components to use the same save file location. But really It is heavily recommended that, in the long run, it is simpler and more robust to give SpacePins/AlignmentAnchors globally unique names, than to try to manage the lighter locally unique requirement. But do what you like. See also Before You Start Most Basic Setup Loss of Tracking Pinning It Down"
  },
  "DocGen/Documentation/HowTos/WLT_ASA.html": {
    "href": "DocGen/Documentation/HowTos/WLT_ASA.html",
    "title": "World Locking Tools combined with Azure Spatial Anchors | World Locking Tools for Unity Documentation",
    "keywords": "World Locking Tools (WLT) combined with Azure Spatial Anchors (ASA) Azure Spatial Anchors (ASA), provide a powerful cross-platform method for persistence across sessions and sharing across devices of spatial coordinates of physical features. World Locking Tools (WLT), on the other hand, leverage a device's local tracking system to stabilize Unity's global coordinate space relative to the physical environment. Combining the two gives stationary coordinate space(s) which are maintained across sessions, and sharable between different devices. Supported configurations WLT supports: Unity 2018.4, Unity 2019.4, Unity 2020.3 HoloLens, HoloLens2, Android, and iOS Unity Legacy XR, XR SDK, or OpenXR Azure Spatial Anchors v2.9.0-v2.10.2 Use of ASA v2.9+ imposes these additional restrictions: Unity 2020.3 or later XR SDK or OpenXR At the time of this writing, ASA only targets ARM64 (not ARM32) on HoloLens2. Check the latest ASA documentation . Setup for using ASA with WLT Before deploying and running the samples leveraging ASA with WLT, some external software and configuration is necessary. In particular, enabling coarse relocation requires some non-intuitive setup. These additional steps are detailed in the WLT+ASA Sample documentation . Additionally, notes on the software bridging the two systems , ASA and WLT, may prove helpful in understanding what's going on. See also WLT+ASA software overview WLT_ASA Samples Walkthrough Azure Spatial Anchors Quick Start World Locking Tools for Unity"
  },
  "DocGen/Documentation/HowTos/WLTviaMRFeatureTool.html": {
    "href": "DocGen/Documentation/HowTos/WLTviaMRFeatureTool.html",
    "title": "Using the Mixed Reality Feature Tool to install World Locking Tools | World Locking Tools for Unity Documentation",
    "keywords": "Using the Mixed Reality Feature Tool to install World Locking Tools The MR Feature Tool The Mixed Reality Feature Tool can be an extremely useful way to get the World Locking Tools, as well as other valuable Mixed Reality packages for Unity. More information on the MR Feature Tool can be found in its online documentation , but it is extremely easy to use. Installing WLT via MR Feature Tool To get the full WLT functionality, simply select the latest version of \"World Locking Tools\" from the MR Feature Tool. Then proceed to adding WLT to a scene , or the quick start guide . If getting the samples (which also requires MRTK), it is not necessary to first install the dependencies. Simply select the Samples package and the minimal set of required dependencies will also be installed. But see below . Note TL;DR version - If installing from the MR Feature Tool, you must install into a folder whose path length is 11 characters long or less, including the drive. This is explained in greater detail at the end of this article . So e:\\stuff\\T1 will work, but e:\\stuff\\T12 won't. Samples in the MR Feature Tool (writable packages) As mentioned above, the MR Feature Tool and UPM install packages as read-only resources. For samples, that is inconvenient, because much of the value of samples is in supplying volatile assets which can be modified for experimentation. To enable this, samples installed by the MR Feature Tool (or UPM) follow a slightly different path. Installing them is a two part process. The first part proceeds just as installing the read-only packages. However, after that installation, the samples will not yet appear in Assets or Packages. To finish importing the samples into your project: Open the Unity Package Manager If the Package Manager is set to \"Unity Registry\", change it to \"In Project\" Find the Samples you want to finish installing. Here we are targeting \"World Locking Samples v1.2.4\". Hit the \"Import into project\" button. The examples will now appear under a Samples folder in Assets, as shown here. They can be relocated to suit your project's organization. Differences between installation methods There are some subtle considerations when deciding which installation method to use. MR Feature Tool (UPM packages) A major driver for the MR Feature Tool is package dependencies. A package in the MR Feature Tool can specify other packages which need to be installed in order for it to work properly. The Feature Tool can then acquire and install, not just the package you are requesting, but all of its dependencies as well. After the Feature Tool has processed your requested installation, there are no other installations you need to track down. The biggest difference between resources acquired through the MR Feature Tool (or UPM) versus resources acquired from .unitypackage files, is that the former are installed write-only, whereas the latter are dropped in just like your own resources. Note that when acquiring WLT via the Feature Tool, the Frozen World Engine DLL is brought in as a dependency. No manual installation via NuGet is necessary. WLT releases (.unitypackage files) WLT publishes periodic releases, which are considered very stable snapshots. These are available on the World Locking Tools Releases page. As mentioned above, the result of importing these .unitypackage files into your project is the same as if you copied in the source (see below). The scripts and assets are writeable, and can be rearranged to fit your structure. The dependency chain is very simple, but it is the responsibility of the installing client (you) to install the dependencies as well as the package you want. The simple dependency graph is linear. In the following list, each item depends on every item above it, but on no item below it: Frozen World Engine DLL (from NuGet, see installation instructions ) World Locking Core Engine World Locking Tools World Locking Samples (also depends on MRTK, but MRTK is included in .unitypackage) From GitHub code (copy in source) Another option for acquiring WLT is to get the source directly from GitHub (either via git or as a zipfile) and copy it into your project. This is equivalent to installing from the .unitypackages above. To get the source matching a release, find the appropriate branch . For example, the source for release v1.2.4 is in branch release/v1.2.4 . About the installation path length limit When installing from Mixed Reality Feature Tool Windows imposes a maximum path length of 260 characters . The Frozen World Engine package has some very long internal paths. The Mixed Reality Feature Tool (or Unity's UPM, depending whom you want to blame), adds some very long strings in the middle. You will know if you have passed the MAX_PATH limit if you see errors in the Unity Console complaining about not being able to find part of a path. Again, the installation path e:\\stuff\\T1 will work, but e:\\stuff\\T12 will be too long. Ironically, the first file to hit the limit isn't even used on Windows, it's for the iOS build (iOS doesn't have the MAX_PATH limit). WLT will build and run fine without it. However, the existence of the file will interfere with the running of some important MRTK scripts, and probably destabilize Unity in other subtle ways. When installing from .unitypackage files or from github Without the UPM/MRFeatureTool inserting characters into the installation paths, there is a bit more breathing room. However, the internal path hierarchy within the Frozen World Engine is still quite deep. When installing from unitypackage files or from github, the installation folder should be about 100 characters long or less. There are more investigations and discussions in this WLT issue ."
  },
  "DocGen/Documentation/HowTos/WorldLockingContext.html": {
    "href": "DocGen/Documentation/HowTos/WorldLockingContext.html",
    "title": "World Locking Tools Context and Manager settings | World Locking Tools for Unity Documentation",
    "keywords": "World Locking Tools Context and Manager settings The World Locking Tools Context allows parametric customization of the World Locking Tools Manager in the Unity Inspector. While the WorldLockingContext component presents a UI for the WorldLockingManager, it is important to understand that they are not the same thing, and in some situations it may be important to understand their relationship. The Manager is a singleton The WorldLockingManager is a singleton created on demand and persisting through the lifetime of the application. If no calls are made to the WorldLockingManager, it will never be instantiated. Once instantiated, it will remain live until the application is shut down. It is never destroyed and re-instantiated. The WorldLockingManager is not a Unity object, it is a generic C# class. Its Update is driven by a proxy Unity component, an instance of the private WorldLockingManager.UpdateProxy class. It is otherwise independent from Unity's creation/update/destruction cycles. The Context is a Unity component The WorldLockingContext is a Unity component which is added to an object in the scene in the usual manner. It's fields appear in the Unity Inspector as would any other regular Unity component's fields. While it is not an error to have multiple active WorldLockingContexts in a single scene, it is probably not desired, as the behavior would be undefined, dependent on the unknown order of object loads. The settings on a context are applied when the WorldLockingContext is loaded . Specifically, the context pushes its settings onto the World Locking Tools Manager in its OnEnable call, and any time its scene becomes the active scene. The latter is applied as part of the Unity.SceneManager.activeSceneChanged callback, if and only if the new active scene is the scene the context belongs to. All settings may be applied from script At any point in the runtime, the application may apply custom settings to the WorldLockingManager via script. If any teardown and rebuilding of resources is required to effect a change in settings, that reconstruction will take place immediately on the settings change. While there are some convenience members to get individual property values from the WorldLockingManager, for example AutoSave , setting of parameters always happens in aggregate. For example, code to toggle the AutoMerge and AutoRefreeze features might look like this: /// Get a copy of the current settings var settings = WorldLockingManager.GetInstance().Settings; /// Modify the copy settings.AutoMerge = !settings.AutoMerge; settings.AutoRefreeze = !settings.AutoRefreeze; /// Update the current settings to the values in the copy. WorldLockingManager.GetInstance().Settings = settings; Likewise for the diagnostics settings. Note that changing multiple settings at once in this way only incurs the cost of a single rebuild (if any is required). Settings precedence Rules for the settings currently applied to the WorldLockingManager are very simple: If no scene containing a context has been loaded, and no settings have been explicitly set from script, the WorldLockingManager has default settings. A setting will retain its value until it is overridden by a WorldLockingContext loading with a scene, or an explicit change invoked from the application in script. Caution should be used when mixing World Locking Tools Manager settings from contexts and settings from scripts. Since the context always applies its settings on load, a script manually applying setting during load, particularly from its OnEnable callback, will likely run into race conditions and indeterminate behavior. Available settings The available settings for controlling World Locking Tools behavior are broken into groups as follows. Automation settings Automation settings control the runtime behavior of the World Locking Tools Manager. The fields available for modification and their implications are documented within the ManagerSettings class. They are focused on enabling or disabling automated periodic actions by the manager. Any disabled automated action can be performed manually instead. Linkage settings Linkage settings are used to explicitly define the scene GameObjects whose transforms will be used to apply World Locking Tools' corrections. The \"Use Existing\" field allows the linked objects to be set once in the scene with the camera rig (with \"Use Existing\" false), and not overridden by loading subsequent content scenes (with \"Use Existing\" true). Conversely, setting \"Use Existing\" to false allows allows multiple scenes each with a different camera rig to bind to the appropriate places in the camera's hierarchy. When creating and managing the camera hierarchy from script, the \"Use Existing\" field should be set to true on all Contexts,and the linkages updated explicitly from the camera managing scripts. When the required transforms are not supplied, either left null or all Contexts have \"Use Existing\", then the system issues a warning and tries to infer good choices. It is recommended, but not required, to explicitly set the appropriate transforms, rather than having the system guess. There are two additional options here that control how the camera transform correction will be applied. The first checkbox, for \"Apply Adjustment\", defaults to enabled. This tells the system to apply the computed camera correction each frame to the \"Adjustment Frame\" GameObject . Disabling this is a very advanced feature, and should only be tried after all other issues are resolved, and a deep understanding of World Locking Tools has been achieved. In short, it tells the system that the camera correction is not to be applied to the camera, but will be applied by other means. Typically, this is through an AlignSubtree component, but doesn't need to be. The second checkbox, for \"No Pitch And Roll\", tells the system to zero out any pitch and roll computed in the transform from Playspace to Locked Space. (See this discussion of WLT coordinate spaces ). This has no effect on the rotation applied by the SpacePin system, but only affects the world locking camera correction transform computed by the Frozen World Engine. Anchor Management settings The Anchor Management settings all the explicit selection of the anchor tracking system. This selection is currently done only at startup, and once selected cannot be changed. Other settings here allow for control over the density of the underlying internal anchor graph. These may be changed at any time, although their effect may take some time to propagate through the internal graph. When covering very large areas, one might want to lower the density of the internal anchor graph to sacrifice accuracy for performance. Increasing the MinNewAnchorDistance does just that. By increasing the minimum distance required before adding a new internal anchor, the spacing between the anchors increases, and so the density of anchors decreases. It should be noted that in order to pass the edge creation test, the MaxAnchorEdgeLength must be larger than the MinNewAnchorDistance. In practice, a MaxAnchorEdgeLength 10-20% larger then the MinNewAnchorDistance works well. The MaxLocalAnchors parameter, rather than modifying density, directly limits the number of internal anchors. Currently, when the anchor count is over the limit, anchors most distant from the camera are recycled to bring the number down. However, other algorithms are interesting and being investigated, so an application should not depend on this particular implementation. More details are documenting within the AnchorSettings struct. Diagnostics settings The Diagnostics settings control the gather of diagnostics for analysis of behavior and debugging. They should normally be left with \"Use Defaults\" set, which, among other things, disables the collection of diagnostics. The diagnostics collection is a great performance drag, so should be avoided unless needed. During development, when unexpected and undesirable behavior is being seen, the diagnostics data collected by disabling Use Defaults and enabling DiagnosticsSettings.Enabled will enable the collection of data which can be instrumental in understanding and fixing that behavior. The fields available for modification are described within the DiagnosticsSettings class. Default settings Both the manager and diagnostics settings each contain a \"Use Defaults\" checkbox in the settings. The \"Use Defaults\" property is also available from script. When the \"Use Defaults\" property is true, the current default settings are used. If default values for a property change in a new release, the \"Use Defaults\" property instructs the system to use the new property value. Setting the \"Use Defaults\" property to true at any time will reset all values to their current default values. To lock the values at a snapshot of the default values at a given time, enable the \"Use Defaults\" property to reset all fields to the current defaults, then unset the checkbox to prevent them from being changed with an update. It is suggested to leave the \"Use Defaults\" set to true, except during development for experimentation and debugging. See also WorldLockingManager WorldLockingContext ManagerSettings LinkageSettings DiagnosticsSettings"
  },
  "DocGen/Documentation/HowTos/XRSDK.html": {
    "href": "DocGen/Documentation/HowTos/XRSDK.html",
    "title": "Cross Platform using Unity's XR SDK Plugin system | World Locking Tools for Unity Documentation",
    "keywords": "Cross Platform using Unity's XR SDK Plugin system Initial development of the World Locking Tools targeted the HoloLens family of devices via Unity's XR.WSA (VR/AR Windows Store App) APIs. This is part of what has become commonly known as Unity's Legacy XR interface, or Unity's built-in VR support. Unity has since introduced its XR Plugin architecture , whose goal is to provide cross platform abstractions giving developers access to common features across available VR and AR devices. During this transition phase, WLT has supported both the Legacy XR interface for HoloLens, and the AR Subsystems / XR Plugin Management for cross-platform. It should be noted that the Legacy XR interface is deprecated since Unity 2019, and is no longer supported as of Unity 2020. WLT currently supports AR Subsystems versioned 2.X.Y for Unity 2019.4 (LTS) and XR Plugin Management versioned 4.0.7 and later for Unity 2020.3 (LTS) . Further version support will be rolled out in subsequent releases. Switching WLT to target XR SDK Targeting WLT for XR SDK is exceedingly simple. First, configure your project to use the XR Plugin system. If using MRTK , follow these instructions . There are additional tips and notes later in this article. If not using MRTK , then follow these slightly more complicated instructions . In either case, you will end up with Unity's XR Plug-in Management system installed and enabled, and with an XR Plug-in provider appropriate for your platform installed and selected. Once the necessary resources have been installed, change the Anchor Subsystem type in the World Locking Context in your scene. Automatic selection Running the script Mixed Reality => World Locking Tools => Configure scene will select the correct Anchor Subsystem based on how your project and scene are configured. It is safe to run the Configure scene script repeatedly. If the scene is already properly configured, it will make no changes. Manual selection Go to the WorldLockingManager GameObject in your initial (or global) scene. In the inspector, find the WorldLockingContext . Open Anchor Management settings. Make sure the \"Use Defaults\" checkbox is unchecked. Change the Anchor Subsystem type to XRSDK . If your project and scene are setup to use AR Foundation , then select the AR Foundation Anchor Subsystem instead. The Azure Spatial Anchors samples show a proper configuration for using AR Foundation (currently an ASA requirement). Using MRTK with WLT on XR SDK MRTK , in addition to the incredible value it provides for abstracting user interactions in VR and AR, simplifies targeting devices via the XR SDK greatly. The following are notes that might prove helpful when setting up MRTK to target specific devices. These all assume that the WLT Anchor Management Anchor Subsystem has been set appropriately as described in the previous section. Be sure to run the Mixed Reality Toolkit => Utilities => UnityAR => Update Scripting Defines when changing plugin targets. Setup for Windows XR Plugin (HoloLens) See full instructions at Getting started with MRTK and XR SDK . If working in the WLT project, you can use the WLT provided “WLT HL2 MRTKProfile” on HoloLens2, or the \"WLT AR MRTKProfile\" on mobile devices, to start. WLT using Windows XR Plugin has been tested on Unity 2019.4 and Unity 2020.3, using the following versions: XR Plugin Management: v3.2.16 (expected to work with v3.X.Y, X >= 2) Windows XR Plugin: v2.4.1 (prior to v2.4.1 anchors were broken. Expected to work v2.4.Y, Y>=1, v2.X.Y, X>=1). Mixed Reality OpenXR Plugin: v1.2.0 (earlier versions worked, with minor issues. The latest MR OpenXR Plugin is highly recommended.) You only need one of either the Windows MR Plugin or the Mixed Reality OpenXR Plugin . Setup for ARCore XR Plugin (Android) To get an Android XR Plugin driving an MRTK AR application, follow the instructions at How to configure MRTK for iOS and Android NOTE: You need ALL of: XR Plugin Management (tested v3.2.16, expected v3.X.Y, X>=2). AR Subsystems (tested v2.1.3, expected v2.X.Y, X>1). AR Core XR Plugin (tested v2.1.12, expected v2.X.Y, X>1). AR Foundation (tested v2.1.10, expected v2.X.Y, X>1). I suggest using the WLT provided “WLT AR MRTKProfile” to start. NOTE: If you hit a build error about manifest-merger failed , then follow the appropriate instructions here: https://developers.google.com/ar/develop/unity/android-11-build Setup for other XR Plugins (ARKit, Oculus, etc.) Setup for other platforms might be analogous to setup for ARCore, but have not been tested. If you have access to such devices and a chance to try them, any feedback would help the community and be greatly appreciated."
  },
  "DocGen/Documentation/IntroFAQ.html": {
    "href": "DocGen/Documentation/IntroFAQ.html",
    "title": "Frequently asked questions | World Locking Tools for Unity Documentation",
    "keywords": "Frequently asked questions Definitions used in this documentation: Pose – a position and orientation. Hologram - a visible virtual object. Real world - the physical world. Physical world - the real world. Virtual world - synthetically generated and simulated world presented via electronic media. Virtual world marker – a pose in the virtual (modeling) coordinate system. That’s it, just a reference position and orientation. Real world marker – a pose relative to the real-world environment and camera corresponding to a virtual world marker. The real-world marker’s pose is established by some combination of sensed data. Visible features - Features of the physical world that are visually recognizable. What does World Locking Tools do? Given inconsistencies between virtual and real world markers, World Locking Tools provides a stable coordinate system and camera adjustment that minimizes the visible inconsistencies. Put another way, it world-locks the entire scene with a shared pool of anchors, rather than locking each group of objects with the group's own individual anchor. Why are the virtual and real world markers inconsistent? Among the many amazing technologies behind Microsoft Mixed Reality, the ability to track the headset's pose in the physical world in real time, without the aid of external devices, is especially amazing. The head tracking system is remarkably accurate at determining the head's pose relative to known virtual reference points in the physical environment. For this discussion, those virtual reference points will be called \"visible features\". On leaving a position known relative to surrounding visible features, for instance if the user walks around the room, and then returning to that same position, the system will recognize many of those same visible features. It can also determine the poses of those visible features relative to the current head pose, and do so with surprising accuracy. Now the tracker system knows where these features and the head are relative to each other, but it doesn't know in absolute terms what the coordinates are for either head or features. As the physical world has no absolute coordinate system, there is no right answer. So the tracking system assigns coordinates that are consistent with recent history, but may be inconsistent over all history. That is, on returning to the exact same pose, the head may now have different coordinates than when it left. This is a form of sensor drift. But if the new head virtual pose coordinates have shifted toward positive X, for example, then all hologram objects that are stationary in that virtual coordinate system are now shifted toward negative X relative to the head. That means that to the observer wearing the head tracker, they will be shifted relative to the real world as compared with their placement previous to the walk. Can Unity handle this? Yes, with limitations. Unity provides an excellent mechanism for dealing with this, known as spatial anchors. If the virtual space has shifted relative to physical space, by keeping track of underlying visible features, a spatial anchor knows to shift itself in virtual space to remain locked in physical space. Anything attached to the spatial anchor will likewise be dragged through Unity's virtual space to remain stationary in physical space. The limitations are related to the fact that visible features become unreliable when they are far from the head tracker's cameras. This is not surprising. Visible features that aren't visible make poor reference points. A spatial anchor's useful range is therefore limited to 3 meters. Depending on the accuracy requirements of the application, the usable range might be less. That seems pretty good, what's the problem? It's beyond good, it's simply amazing. But there are situations, important situations, where spatial anchors do not provide a satisfactory solution. First, each spatial anchor moves through Unity's virtual coordinate space independently attempting to remain stationary in the physical world. This means that objects anchored independently will move relative to each other as they try to remain in their physical positions. For an application trying to maintain a precise layout, this can be a large problem. Second, with its limited range, a single spatial anchor will not provide good results for single objects which are larger than the usable range of that spatial anchor. While the points on the object near the spatial anchor will remain well world-locked, because of the lever arm effect, points farther and farther from the spatial anchor will suffer ever increasing errors. This leaves an object, or a collection of objects, larger than a meter or so without a robust world-locking solution. What else can go wrong? On returning to a previously occupied pose, World Locking Tools has enough information to restore the virtual coordinate system back where it was relative to the physical world. This keeps holograms that are stationary in the virtual world also stationary in the physical world. But drift may occur on a one way trip, as well as a round trip. As a concrete example, consider measuring 10 meters between two QR codes placed in a physical room, and therefore modeling two boxes in the virtual room as 10 meters apart. But at runtime, because of drift of the head pose in the virtual space, walking the 10 meters between the QR codes moves 11 meters through virtual space. The application may opt into a feature of World Locking Tools to address this by providing information calibrating distance in virtual space to distance in physical space. The behavior that World Locking Tools provides is that, standing over the first QR code and looking down will see the first box. As the 10 meters are walked through the physical world, the extra meter in virtual space is quietly absorbed, leaving the head moved 10 meters in virtual space as well. So on reaching the second physical QR code and looking down, the second virtual box will be there as expected. Note that corresponding adjustments will be made to all of the anchors which don’t have ground truth data, as they are passed on the path between the two QR codes. That adjustment is, of course, applied smoothly to minimize its perception. What if the real-world markers aren’t stable? Furthermore, if the real-world markers are being dynamically updated, World Locking Tools can adjust its spatial frame and camera adjustment to optimally match the current configuration. For example, on HoloLens if the real-world markers are spatial anchors, then they will drift over time. They will also move on re-establishment (e.g. loop closure), and in other circumstances. As their poses are updating, World Locking Tools compensates by adjusting the camera as before to minimize the perceived inconsistencies between the sensed spatial anchors and their virtual counterparts. Note that this compensation for updates in anchor positions can happen even in the absence of ground truth data about the markers. The implied ground truth data is that the current relationships between real-world markers is (more) correct. What if the inconsistencies get really bad? World Locking Tools can detect several scenarios in which the inconsistencies between real and virtual markers are large and can be improved upon. For example, more information may be obtained which establishes the spatial relationship between two previously isolated pools of markers. Or loop closure might suggest a shift of markers along the route to allow the endpoints to meet. In these cases, World Locking Tools notifies the client of the potential fix, and on the client's bequest performs the fix and notifies the client of adjustments it should make in its objects which track virtual markers. Until the client requests such a fix (if ever), World Locking Tools continues to minimize the perceived inconsistencies."
  },
  "DocGen/Documentation/NOTICE.html": {
    "href": "DocGen/Documentation/NOTICE.html",
    "title": "NOTICES AND INFORMATON | World Locking Tools for Unity Documentation",
    "keywords": "NOTICES AND INFORMATION Do Not Translate or Localize This software incorporates material from third parties. Microsoft makes certain open source code available at http://3rdpartysource.microsoft.com , or you may send a check or money order for US $5.00, including the product name, the open source component name, and version number, to: Source Code Compliance Team Microsoft Corporation One Microsoft Way Redmond, WA 98052 USA Notwithstanding any other terms, you may reverse engineer this software to the extent required to debug changes to any libraries licensed under the GNU Lesser General Public License. Oculus Controller Images Copyright (c) Facebook Technologies, LLC and its affiliates. All rights reserved. Art Attribution License 1.0 You may use these images solely for referring to the corresponding product in your video game or VR experience (including manuals for users). Otherwise, you may not use these images, or any trademarks, logos or other intellectual property owned by Facebook Technologies, LLC formerly known as Oculus VR, LLC (“Oculus”), including but not limited to use on merchandise or other product such as clothing, hats, or mugs. Do not use the Oculus images in a way that implies a partnership, sponsorship or endorsement; or features Oculus on materials associated with pornography, illegal activities, or other materials that violate Oculus Terms. THE IMAGES ARE PROVIDED TO YOU ON AN “AS IS” BASIS AND YOU ARE SOLELY RESPONSIBLE FOR YOUR USE OF THE IMAGES. OCULUS DISCLAIMS ALL WARRANTIES REGARDING THE IMAGES, INCLUDING WARRANTIES OF NON-INFRINGEMENT. OCULUS SHALL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR PUNITIVE DAMAGES ARISING FROM OR RELATED TO YOUR USE OF THE IMAGES. For the avoidance of doubt, this license shall not apply to the Oculus name, trademark or service mark, logo or design OpenVR Copyright (c) 2015 Valve Corporation. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Unity 3D Async Await Util Copyright (c) 2016 Modest Tree Media Inc Licensed under the MIT License. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Visual Profiler Copyright (c) Microsoft Corporation. All rights reserved. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.Examples.ActionCube.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.Examples.ActionCube.html",
    "title": "Class ActionCube | World Locking Tools for Unity Documentation",
    "keywords": "Class ActionCube Simple object for interaction. Not to be taken seriously. Inheritance Object ActionCube ActionPublish Namespace : Microsoft.MixedReality.WorldLocking.ASA.Examples Assembly : cs.temp.dll.dll Syntax public class ActionCube : MonoBehaviour Methods ChangeColorForSeconds(Single, Color) Declaration protected async Task<bool> ChangeColorForSeconds(float seconds, Color color) Parameters Type Name Description Single seconds Color color Returns Type Description Task < Boolean > DoThing() Declaration protected virtual async void DoThing() OnSelect() Declaration public void OnSelect() RestoreColors() Declaration protected void RestoreColors() SetColors(Color) Declaration protected void SetColors(Color color) Parameters Type Name Description Color color"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.Examples.ActionPublish.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.Examples.ActionPublish.html",
    "title": "Class ActionPublish | World Locking Tools for Unity Documentation",
    "keywords": "Class ActionPublish Script for implementing button actions. Simple passthrough to perform publisher actions on interaction events. Inheritance Object ActionCube ActionPublish Inherited Members ActionCube.DoThing() ActionCube.ChangeColorForSeconds(Single, Color) ActionCube.SetColors(Color) ActionCube.RestoreColors() ActionCube.OnSelect() Namespace : Microsoft.MixedReality.WorldLocking.ASA.Examples Assembly : cs.temp.dll.dll Syntax public class ActionPublish : ActionCube Fields finishSeconds Declaration public float finishSeconds Field Value Type Description Single notReadyColor Declaration public Color notReadyColor Field Value Type Description Color spacePinBinder Declaration public SpacePinBinder spacePinBinder Field Value Type Description SpacePinBinder spacePinBinderFile Declaration public SpacePinBinderFile spacePinBinderFile Field Value Type Description SpacePinBinderFile statusLine Declaration public TextMeshPro statusLine Field Value Type Description TextMeshPro workingColor Declaration public Color workingColor Field Value Type Description Color Methods DoClear() Declaration public async void DoClear() DoDownload() Declaration public async void DoDownload() DoPublish() Declaration public async void DoPublish() DoPurge() Declaration public async void DoPurge() DoReset() Declaration public async void DoReset() DoSearch() Declaration public async void DoSearch() DoTogglePin() Declaration public async void DoTogglePin()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.Examples.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.Examples.html",
    "title": "Namespace Microsoft.MixedReality.WorldLocking.ASA.Examples | World Locking Tools for Unity Documentation",
    "keywords": "Namespace Microsoft.MixedReality.WorldLocking.ASA.Examples Classes ActionCube Simple object for interaction. Not to be taken seriously. ActionPublish Script for implementing button actions. Simple passthrough to perform publisher actions on interaction events. PlatformMenuSelector Simple script to select between equivalent menus at build time based on platform. ScreenSpacer Adjust a menu based on whether camera is in portrait or landscape mode. SpacePinASAManipulation Component that adds MRTK object manipulation capabilities on top of the auto-orienting SpacePinOrientable. Startup Perform one off actions at startup."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.Examples.PlatformMenuSelector.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.Examples.PlatformMenuSelector.html",
    "title": "Class PlatformMenuSelector | World Locking Tools for Unity Documentation",
    "keywords": "Class PlatformMenuSelector Simple script to select between equivalent menus at build time based on platform. Inheritance Object PlatformMenuSelector Namespace : Microsoft.MixedReality.WorldLocking.ASA.Examples Assembly : cs.temp.dll.dll Syntax public class PlatformMenuSelector : MonoBehaviour"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.Examples.ScreenSpacer.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.Examples.ScreenSpacer.html",
    "title": "Class ScreenSpacer | World Locking Tools for Unity Documentation",
    "keywords": "Class ScreenSpacer Adjust a menu based on whether camera is in portrait or landscape mode. Inheritance Object ScreenSpacer Namespace : Microsoft.MixedReality.WorldLocking.ASA.Examples Assembly : cs.temp.dll.dll Syntax public class ScreenSpacer : MonoBehaviour Properties Target Declaration public Transform Target { get; set; } Property Value Type Description Transform"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.Examples.SpacePinASAManipulation.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.Examples.SpacePinASAManipulation.html",
    "title": "Class SpacePinASAManipulation | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePinASAManipulation Component that adds MRTK object manipulation capabilities on top of the auto-orienting SpacePinOrientable. Inheritance Object SpacePinASA SpacePinASAManipulation Inherited Members SpacePinASA.LocalPeg SpacePinASA.Publisher SpacePinASA.SpacePinId SpacePinASA.Properties SpacePinASA.IsReadyForPublish SpacePinASA.SetLocalPeg(ILocalPeg) SpacePinASA.ConfigureLocalPeg() Namespace : Microsoft.MixedReality.WorldLocking.ASA.Examples Assembly : cs.temp.dll.dll Syntax public class SpacePinASAManipulation : SpacePinASA Properties AllowRotation Whether to show the MRTK rotation gizmos. Declaration public bool AllowRotation { get; set; } Property Value Type Description Boolean Remarks Rotating the SpacePinOrientableManipulation object only has any effect when the first pin is manipulated. Once the second object is manipulated, and ever after, the orientation is implied by the alignment of the pin objects, and actual orientation of the objects is ignored. Prefab_FeelerRay Proxy renderable to show axis alignment during manipulations. Declaration public GameObject Prefab_FeelerRay { get; set; } Property Value Type Description GameObject Methods OnDestroy() Shutdown the manipulation controls. Declaration protected override void OnDestroy() Start() Start(), and set up MRTK manipulation controls. Declaration protected override void Start()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.Examples.Startup.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.Examples.Startup.html",
    "title": "Class Startup | World Locking Tools for Unity Documentation",
    "keywords": "Class Startup Perform one off actions at startup. Inheritance Object Startup Namespace : Microsoft.MixedReality.WorldLocking.ASA.Examples Assembly : cs.temp.dll.dll Syntax public class Startup : MonoBehaviour"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.html",
    "title": "Namespace Microsoft.MixedReality.WorldLocking.ASA | World Locking Tools for Unity Documentation",
    "keywords": "Namespace Microsoft.MixedReality.WorldLocking.ASA Classes LocalPegAndProperties A local peg, with an associated properties dictionary. PublisherASA Implementation of IPublisher using ASA to push anchors to and retrieve them from the cloud. ReadinessStatus Class wrapping the readiness state, along with the progress to readiness to create cloud anchors SpacePinASA SpacePinASA.KeyValPair SpacePinBinder Implementation of the IBinder interface, managing the relationship between space pins and cloud anchors. SpacePinBinderFile Simple implementation of an IBindingOracle interface, which puts and gets binding from file locally. Structs SpacePinCloudBinding A binding between a space pin and a cloud anchor, by their respective id's. Interfaces IBinder Interface for a binding layer between space pins and cloud anchors. IBindingOracle Interface for a magical oracle that communicates IBinder bindings across space and time. ILocalPeg A data blob with enough information to be saved to the cloud and reconstructed from the cloud in a later session or on a different device. IPublisher The IPublisher abstracts the process of publishing and downloading cloud anchors. Enums PublisherReadiness Readiness states."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.IBinder.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.IBinder.html",
    "title": "Interface IBinder | World Locking Tools for Unity Documentation",
    "keywords": "Interface IBinder Interface for a binding layer between space pins and cloud anchors. Namespace : Microsoft.MixedReality.WorldLocking.ASA Assembly : cs.temp.dll.dll Syntax public interface IBinder Remarks This abstraction isn't so much for multiple implementations, as for providing a clean API. The IBinder is responsible for managing the mapping between the cloud anchors, which persist and transmit pose data, and the space pins, which use that data to create shared spaces. Properties IsReady If the binder is ready to execute tasks. Declaration bool IsReady { get; } Property Value Type Description Boolean Remarks Reasons not be be ready include initialization not complete, or already busy on another task. Name The name of this binder. Declaration string Name { get; } Property Value Type Description String PublisherStatus The current status of the publisher. Declaration ReadinessStatus PublisherStatus { get; } Property Value Type Description ReadinessStatus Methods Clear() Delete all known (bound) cloud anchors from the cloud, and erase their bindings. Declaration Task<bool> Clear() Returns Type Description Task < Boolean > True on success. Remarks Bound space pins are unaffected, but will no longer be bound. CreateBinding(String, String) Set the cloud anchor id associated with this space pin. Declaration bool CreateBinding(string spacePinId, string cloudAnchorId) Parameters Type Name Description String spacePinId Name of the space pin to be bound to this cloud id. String cloudAnchorId Cloud id to be bound to the space pin. Returns Type Description Boolean False if space pin is unknown. Space pin must be registered before being bound. Remarks A space pin must be bound to a cloud anchor id before it can be downloaded. Download() Pull down cloud anchors for all known bindings, and apply them to the bound space pins. Declaration Task<bool> Download() Returns Type Description Task < Boolean > True on success. GetBindings() Known bindings between space pins and cloud anchors. Declaration IReadOnlyList<SpacePinCloudBinding> GetBindings() Returns Type Description IReadOnlyList < SpacePinCloudBinding > Publish() Publish all active space pins to the cloud. Declaration Task<bool> Publish() Returns Type Description Task < Boolean > True on success. Remarks Space pins which are previously published in this session, i.e. that have a binding to a cloud anchor, will have that cloud anchor deleted first, and a new binding created to the newly published cloud anchor. To be publishable, a SpacePin must have an ILocalPeg created from CreateLocalPeg(String, Pose) . The SpacePinASA manages this automatically. Purge() Find all cloud anchors in the area, delete them, and release their bindings. Declaration Task<bool> Purge() Returns Type Description Task < Boolean > True on success. RemoveBinding(String) Erase a binding between a space pin and its corresponding cloud anchor. Declaration bool RemoveBinding(string spacePinId) Parameters Type Name Description String spacePinId Space pin to unbind. Returns Type Description Boolean True if found and unbound. Remarks Neither the space pin nor the cloud anchor are affected by this, but will be independent of one another after. Search() Search for cloud anchors in the area, download them, and apply to associated space pins. Declaration Task<bool> Search() Returns Type Description Task < Boolean > True on success"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.IBindingOracle.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.IBindingOracle.html",
    "title": "Interface IBindingOracle | World Locking Tools for Unity Documentation",
    "keywords": "Interface IBindingOracle Interface for a magical oracle that communicates IBinder bindings across space and time. Namespace : Microsoft.MixedReality.WorldLocking.ASA Assembly : cs.temp.dll.dll Syntax public interface IBindingOracle Remarks Note that the IBindingOracle only transmits bindings, which are string pairs of SpacePinId and CloudAnchorId. It does not cause the binder to do anything with those bindings. Properties Name The name of this oracle. Declaration string Name { get; } Property Value Type Description String Methods Get(IBinder) Retrieve bindings from the ethereal plane. Declaration bool Get(IBinder binder) Parameters Type Name Description IBinder binder The binder to add the bindings to. Returns Type Description Boolean True on success. Put(IBinder) Broadcast the bindings. Declaration bool Put(IBinder binder) Parameters Type Name Description IBinder binder The binder whose bindings should be broadcast. Returns Type Description Boolean True on success."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.ILocalPeg.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.ILocalPeg.html",
    "title": "Interface ILocalPeg | World Locking Tools for Unity Documentation",
    "keywords": "Interface ILocalPeg A data blob with enough information to be saved to the cloud and reconstructed from the cloud in a later session or on a different device. Namespace : Microsoft.MixedReality.WorldLocking.ASA Assembly : cs.temp.dll.dll Syntax public interface ILocalPeg Remarks In a better world, this construct would be hidden in the internals of the IPublisher interface. Unfortunately, the IPublisher doesn't know when the best time to create a local peg is, and so has to leave that to the application. See CreateLocalPeg(String, Pose) . In general, a local peg will be of better quality if it is created when the tracker is near the local peg's location, and the area has been adequately scanned. Properties GlobalPose The current global pose for the blob. Declaration Pose GlobalPose { get; } Property Value Type Description Pose IsReadyForPublish Is there enough information to publish this anchor to the cloud? Declaration bool IsReadyForPublish { get; } Property Value Type Description Boolean Name The name for this peg. Declaration string Name { get; } Property Value Type Description String"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.IPublisher.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.IPublisher.html",
    "title": "Interface IPublisher | World Locking Tools for Unity Documentation",
    "keywords": "Interface IPublisher The IPublisher abstracts the process of publishing and downloading cloud anchors. Namespace : Microsoft.MixedReality.WorldLocking.ASA Assembly : cs.temp.dll.dll Syntax public interface IPublisher Properties Status Get the current status, including progress to readiness to create. Declaration ReadinessStatus Status { get; } Property Value Type Description ReadinessStatus Remarks The publisher processes requests when its ReadinessStatus.readiness == Readiness.Ready. If that is not the current status, methods will return an error, unless otherwise noted. Methods Create(LocalPegAndProperties) Create a cloud anchor corresponding to the input local peg and its properties. Declaration Task<string> Create(LocalPegAndProperties pegAndProps) Parameters Type Name Description LocalPegAndProperties pegAndProps Peg and properties to be captured to the cloud. Returns Type Description Task < String > Awaitable identifier for the cloud anchor. CreateLocalPeg(String, Pose) Create a local position holder blob. Declaration Task<ILocalPeg> CreateLocalPeg(string id, Pose lockedPose) Parameters Type Name Description String id Unique name to give the local peg. Pose lockedPose The position in WLT.LockedSpace to capture Returns Type Description Task < ILocalPeg > Awaitable created blob. Remarks This can be called anytime, regardless of the ReadinessStatus. See ILocalPeg for more details. Delete(String) Delete the indicated cloud anchor from the cloud database. Declaration Task Delete(string cloudAnchorId) Parameters Type Name Description String cloudAnchorId Cloud anchor to destroy. Returns Type Description Task Awaitable task. Find(Single) Search the area around the device for cloud anchors. Declaration Task<Dictionary<string, LocalPegAndProperties>> Find(float radiusFromDevice) Parameters Type Name Description Single radiusFromDevice Distance (roughly) from device to search. Returns Type Description Task < Dictionary < String , LocalPegAndProperties >> Awaitable dictionary of cloud anchor ids and corresponding local peg and properties. Modify(String, LocalPegAndProperties) Delete a cloud anchor, and create a new one based on input local peg and its properties. Declaration Task<string> Modify(string cloudAnchorId, LocalPegAndProperties pegAndProps) Parameters Type Name Description String cloudAnchorId Cloud anchor to delete. LocalPegAndProperties pegAndProps Local anchor and properties to create new cloud anchor from. Returns Type Description Task < String > Awaitable identifier for the new cloud anchor. PurgeArea(Single) Search the area around the device, and destroy any anchors found. Declaration Task PurgeArea(float radius) Parameters Type Name Description Single radius Distance (roughly) from device to search. Returns Type Description Task Awaitable task. Read(IReadOnlyCollection<String>) Download a list of cloud anchors by id. Declaration Task<Dictionary<string, LocalPegAndProperties>> Read(IReadOnlyCollection<string> cloudAnchorIds) Parameters Type Name Description IReadOnlyCollection < String > cloudAnchorIds List of ids to download. Returns Type Description Task < Dictionary < String , LocalPegAndProperties >> Dictionary of LocalPegAndProperties by cloudAnchorId. Remarks If any cloud anchor ids have already been downloaded this session, and are still retained, those cached records will be refreshed and returned. Read(String) Download a cloud anchor with the given identifier. Declaration Task<LocalPegAndProperties> Read(string cloudAnchorId) Parameters Type Name Description String cloudAnchorId Identifier for the desired cloud anchor. Returns Type Description Task < LocalPegAndProperties > Awaitable local peg and its properties that were used to create the cloud anchor are reconstructed and returned. ReleaseLocalPeg(ILocalPeg) Free up the resources from an ILocalPeg. Declaration void ReleaseLocalPeg(ILocalPeg peg) Parameters Type Name Description ILocalPeg peg The peg to clean up. Remarks Param \"peg\" will be invalid after this call."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.LocalPegAndProperties.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.LocalPegAndProperties.html",
    "title": "Class LocalPegAndProperties | World Locking Tools for Unity Documentation",
    "keywords": "Class LocalPegAndProperties A local peg, with an associated properties dictionary. Inheritance Object LocalPegAndProperties Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.ASA Assembly : cs.temp.dll.dll Syntax public class LocalPegAndProperties Constructors LocalPegAndProperties(ILocalPeg, IDictionary<String, String>) Declaration public LocalPegAndProperties(ILocalPeg lp, IDictionary<string, string> props) Parameters Type Name Description ILocalPeg lp IDictionary < String , String > props Fields localPeg Declaration public readonly ILocalPeg localPeg Field Value Type Description ILocalPeg properties Declaration public readonly IDictionary<string, string> properties Field Value Type Description IDictionary < String , String >"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.PublisherASA.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.PublisherASA.html",
    "title": "Class PublisherASA | World Locking Tools for Unity Documentation",
    "keywords": "Class PublisherASA Implementation of IPublisher using ASA to push anchors to and retrieve them from the cloud. Inheritance Object PublisherASA Implements IPublisher Namespace : Microsoft.MixedReality.WorldLocking.ASA Assembly : cs.temp.dll.dll Syntax public class PublisherASA : MonoBehaviour, IPublisher Remarks PublisherASA is a Monobehaviour to allow exposing properties in the inspector. Properties AnchorsParent Transform to attach created anchors to. Should have identity global pose. Declaration public Transform AnchorsParent { get; set; } Property Value Type Description Transform AnchorsPrefab Object to instantiate wherever native anchors are created to visualize their placement. Declaration public GameObject AnchorsPrefab { get; set; } Property Value Type Description GameObject Remarks These are intended for debugging and development. BeaconUuids Beacon ids to use in coarse reloctaion. Declaration public List<string> BeaconUuids { get; } Property Value Type Description List < String > CoarseRelocationEnabled Enable coarse relocation. Declaration public bool CoarseRelocationEnabled { get; set; } Property Value Type Description Boolean Remarks This must be set before calling Setup to have any effect. CoarseRelocPublishEnabled Whether relocation data will be included in published cloud anchors. Declaration public bool CoarseRelocPublishEnabled { get; set; } Property Value Type Description Boolean Remarks With this enabled, extra initialization will be done, and the readiness state will be less reliable. If cloud anchor ids will be explicitly shared via file or network communications, this should be disabled. CoarseRelocUseBluetooth Whether use of bluetooth beacons is to be used in coarse relocation. Declaration public bool CoarseRelocUseBluetooth { get; } Property Value Type Description Boolean Remarks To enable use of bluetooth beacons, add some beacon uuids to BeaconUuids. CoarseRelocUseGPS Augment cloud anchors with GPS data to allow them to be found via course relocation. Declaration public bool CoarseRelocUseGPS { get; set; } Property Value Type Description Boolean CoarseRelocUseWifi Augment cloud anchors with wifi data to allow them to be found via course relocation. Declaration public bool CoarseRelocUseWifi { get; set; } Property Value Type Description Boolean MaxSearchSeconds Maximum number of seconds to search without finding any anchors before giving up. Declaration public float MaxSearchSeconds { get; set; } Property Value Type Description Single MaxWaitForMoreAnchorsSeconds Max number seconds to wait for more anchors, after having found some. Declaration public float MaxWaitForMoreAnchorsSeconds { get; set; } Property Value Type Description Single MinRecommendedForCreateProgress The minimum value of the recommended-for-create-progress float before allowing creation of cloud anchors. Declaration public float MinRecommendedForCreateProgress { get; set; } Property Value Type Description Single Status Declaration public ReadinessStatus Status { get; } Property Value Type Description ReadinessStatus Methods Create(LocalPegAndProperties) Declaration public async Task<string> Create(LocalPegAndProperties pegAndProps) Parameters Type Name Description LocalPegAndProperties pegAndProps Returns Type Description Task < String > CreateLocalPeg(String, Pose) Declaration public async Task<ILocalPeg> CreateLocalPeg(string id, Pose lockedPose) Parameters Type Name Description String id Pose lockedPose Returns Type Description Task < ILocalPeg > Delete(String) Declaration public async Task Delete(string cloudAnchorId) Parameters Type Name Description String cloudAnchorId Returns Type Description Task Find(Single) Declaration public async Task<Dictionary<string, LocalPegAndProperties>> Find(float radiusFromDevice) Parameters Type Name Description Single radiusFromDevice Returns Type Description Task < Dictionary < String , LocalPegAndProperties >> Modify(String, LocalPegAndProperties) Declaration public async Task<string> Modify(string cloudAnchorId, LocalPegAndProperties peg) Parameters Type Name Description String cloudAnchorId LocalPegAndProperties peg Returns Type Description Task < String > PurgeArea(Single) Declaration public async Task PurgeArea(float radius) Parameters Type Name Description Single radius Returns Type Description Task Read(IReadOnlyCollection<String>) Declaration public async Task<Dictionary<string, LocalPegAndProperties>> Read(IReadOnlyCollection<string> cloudAnchorIds) Parameters Type Name Description IReadOnlyCollection < String > cloudAnchorIds Returns Type Description Task < Dictionary < String , LocalPegAndProperties >> Read(String) Declaration public async Task<LocalPegAndProperties> Read(string cloudAnchorId) Parameters Type Name Description String cloudAnchorId Returns Type Description Task < LocalPegAndProperties > ReleaseLocalPeg(ILocalPeg) Declaration public void ReleaseLocalPeg(ILocalPeg peg) Parameters Type Name Description ILocalPeg peg Setup() Initialization. Declaration public async void Setup() Remarks Note that this is asynchronous. Status.readiness will be Readiness.Ready when setup is complete. Implements IPublisher"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.PublisherReadiness.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.PublisherReadiness.html",
    "title": "Enum PublisherReadiness | World Locking Tools for Unity Documentation",
    "keywords": "Enum PublisherReadiness Readiness states. Namespace : Microsoft.MixedReality.WorldLocking.ASA Assembly : cs.temp.dll.dll Syntax public enum PublisherReadiness Remarks The publisher is only able to process requested tasks when its state is \"Ready\". Fields Name Description Busy NoManager NotReadyToCreate NotReadyToLocate NotSetup Ready Starting"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.ReadinessStatus.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.ReadinessStatus.html",
    "title": "Class ReadinessStatus | World Locking Tools for Unity Documentation",
    "keywords": "Class ReadinessStatus Class wrapping the readiness state, along with the progress to readiness to create cloud anchors Inheritance Object ReadinessStatus Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.ASA Assembly : cs.temp.dll.dll Syntax public class ReadinessStatus Remarks The floating point progress indicators are a bleed-through of the internal implementation, but are very useful to the application/user when establishing tracking. Constructors ReadinessStatus() Default constructor. Declaration public ReadinessStatus() ReadinessStatus(PublisherReadiness) Constructor setting readiness, leaving progress indicators at defaults. Declaration public ReadinessStatus(PublisherReadiness r) Parameters Type Name Description PublisherReadiness r ReadinessStatus(PublisherReadiness, Single, Single) Full constructor. Declaration public ReadinessStatus(PublisherReadiness r, float recommended, float ready) Parameters Type Name Description PublisherReadiness r Readiness to set. Single recommended Recommended for create progress value. Single ready Ready for create progress value. Fields readiness Readiness state. Declaration public PublisherReadiness readiness Field Value Type Description PublisherReadiness readyForCreate Progress to ready for create. Ready (but not necessarily recommended) when readyForCreate >= 1.0f; Declaration public float readyForCreate Field Value Type Description Single recommendedForCreate Progress to recommended for create. Recommended when recommendedForCreate >= 1.0f. Declaration public float recommendedForCreate Field Value Type Description Single"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.SpacePinASA.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.SpacePinASA.html",
    "title": "Class SpacePinASA | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePinASA Inheritance Object SpacePinASA SpacePinASAManipulation Namespace : Microsoft.MixedReality.WorldLocking.ASA Assembly : cs.temp.dll.dll Syntax public class SpacePinASA : SpacePinOrientable Properties IsReadyForPublish Ready to publish when we have a local peg and it is ready to publish. Declaration public bool IsReadyForPublish { get; } Property Value Type Description Boolean LocalPeg Accessor for local peg. Declaration public ILocalPeg LocalPeg { get; } Property Value Type Description ILocalPeg Properties Runtime access of properties. Declaration public Dictionary<string, string> Properties { get; } Property Value Type Description Dictionary < String , String > Publisher Accessor for publisher. This is managed by the binder. Declaration public IPublisher Publisher { get; set; } Property Value Type Description IPublisher SpacePinId Unique identifier for this space pin. Declaration public string SpacePinId { get; } Property Value Type Description String Methods ConfigureLocalPeg() Create a local peg based on current state (LockedPose). Declaration public async void ConfigureLocalPeg() Remarks This typically happens when the SpacePinASA is locally manipulated into a new pose. SetLocalPeg(ILocalPeg) Accept the local peg assigned by the binder after it's been downloaded from the cloud. Declaration public void SetLocalPeg(ILocalPeg peg) Parameters Type Name Description ILocalPeg peg The local peg to take."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.SpacePinASA.KeyValPair.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.SpacePinASA.KeyValPair.html",
    "title": "Class SpacePinASA.KeyValPair | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePinASA.KeyValPair Inheritance Object SpacePinASA.KeyValPair Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.ASA Assembly : cs.temp.dll.dll Syntax public class KeyValPair Fields key Declaration public string key Field Value Type Description String val Declaration public string val Field Value Type Description String"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.SpacePinBinder.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.SpacePinBinder.html",
    "title": "Class SpacePinBinder | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePinBinder Implementation of the IBinder interface, managing the relationship between space pins and cloud anchors. Inheritance Object SpacePinBinder Implements IBinder Namespace : Microsoft.MixedReality.WorldLocking.ASA Assembly : cs.temp.dll.dll Syntax public class SpacePinBinder : MonoBehaviour, IBinder Fields SpacePinIdKey The key for the key-value pair in the space pin/cloud anchor properties identifying the space pin id in the value. Declaration public static readonly string SpacePinIdKey Field Value Type Description String Properties IsReady If the binder is ready to execute tasks. Declaration public bool IsReady { get; } Property Value Type Description Boolean Remarks Reasons not be be ready include initialization not complete, or already busy on another task. Name The name of this binder. Declaration public string Name { get; } Property Value Type Description String PublisherStatus The current status of the publisher. Declaration public ReadinessStatus PublisherStatus { get; } Property Value Type Description ReadinessStatus SearchRadius Distance (roughly) to search from device when looking for cloud anchors using coarse relocation. Declaration public float SearchRadius { get; set; } Property Value Type Description Single SpacePins Declaration public IReadOnlyCollection<SpacePinASA> SpacePins { get; } Property Value Type Description IReadOnlyCollection < SpacePinASA > Methods AddSpacePin(SpacePinASA) Add a space pin to the list of managed pins. Declaration public bool AddSpacePin(SpacePinASA spacePin) Parameters Type Name Description SpacePinASA spacePin Pin to add. Returns Type Description Boolean True if not already there but added. Clear() Delete all known (bound) cloud anchors from the cloud, and erase their bindings. Declaration public async Task<bool> Clear() Returns Type Description Task < Boolean > True on success. Remarks Bound space pins are unaffected, but will no longer be bound. CreateBinding(String, String) Set the cloud anchor id associated with this space pin. Declaration public bool CreateBinding(string spacePinId, string cloudAnchorId) Parameters Type Name Description String spacePinId Name of the space pin to be bound to this cloud id. String cloudAnchorId Cloud id to be bound to the space pin. Returns Type Description Boolean False if space pin is unknown. Space pin must be registered before being bound. Remarks A space pin must be bound to a cloud anchor id before it can be downloaded. Download() Pull down cloud anchors for all known bindings, and apply them to the bound space pins. Declaration public async Task<bool> Download() Returns Type Description Task < Boolean > True on success. GetBindings() Known bindings between space pins and cloud anchors. Declaration public IReadOnlyList<SpacePinCloudBinding> GetBindings() Returns Type Description IReadOnlyList < SpacePinCloudBinding > Publish() Publish all active space pins to the cloud. Declaration public async Task<bool> Publish() Returns Type Description Task < Boolean > True on success. Remarks Space pins which are previously published in this session, i.e. that have a binding to a cloud anchor, will have that cloud anchor deleted first, and a new binding created to the newly published cloud anchor. To be publishable, a SpacePin must have an ILocalPeg created from CreateLocalPeg(String, Pose) . The SpacePinASA manages this automatically. Publish(SpacePinASA) Publish the spacePin. Declaration public async Task<bool> Publish(SpacePinASA spacePin) Parameters Type Name Description SpacePinASA spacePin SpacePinASA to publish Returns Type Description Task < Boolean > True on success. Remarks It may be this should be a private member. Purge() Find all cloud anchors in the area, delete them, and release their bindings. Declaration public async Task<bool> Purge() Returns Type Description Task < Boolean > True on success. RemoveBinding(String) Erase a binding between a space pin and its corresponding cloud anchor. Declaration public bool RemoveBinding(string spacePinId) Parameters Type Name Description String spacePinId Space pin to unbind. Returns Type Description Boolean True if found and unbound. Remarks Neither the space pin nor the cloud anchor are affected by this, but will be independent of one another after. RemoveSpacePin(String) Remove the space pin binding associated with this SpacePin. Declaration public bool RemoveSpacePin(string spacePinId) Parameters Type Name Description String spacePinId Space pin id of binding to remove. Returns Type Description Boolean True if found and removed. Remarks Any binding between this pin and a cloud anchor is also severed. Search() Search for cloud anchors in the area, download them, and apply to associated space pins. Declaration public async Task<bool> Search() Returns Type Description Task < Boolean > True on success UnPin() Declaration public void UnPin() Implements IBinder"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.SpacePinBinderFile.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.SpacePinBinderFile.html",
    "title": "Class SpacePinBinderFile | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePinBinderFile Simple implementation of an IBindingOracle interface, which puts and gets binding from file locally. Inheritance Object SpacePinBinderFile Implements IBindingOracle Namespace : Microsoft.MixedReality.WorldLocking.ASA Assembly : cs.temp.dll.dll Syntax public class SpacePinBinderFile : MonoBehaviour, IBindingOracle Remarks Note that this implements spatial persistence locally across sessions. Also, the file can be transferred from device to device, allowing shared spaces between HoloLens, Android, and iOS. A more sophisticated implementation would be very similar, but instead of saving to and loading from a local file, would save to and load from a shared location in the cloud. Properties Name Name of this oracle. Declaration public string Name { get; } Property Value Type Description String Methods Get(IBinder) Retrieve bindings from file and apply them to the input binder. Declaration public bool Get(IBinder binder) Parameters Type Name Description IBinder binder Binder to apply them to. Returns Type Description Boolean True on success. Put(IBinder) Pull bindings from the binder and save them to file. Declaration public bool Put(IBinder binder) Parameters Type Name Description IBinder binder Binder to pull from. Returns Type Description Boolean True on success. Implements IBindingOracle"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.SpacePinCloudBinding.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.ASA.SpacePinCloudBinding.html",
    "title": "Struct SpacePinCloudBinding | World Locking Tools for Unity Documentation",
    "keywords": "Struct SpacePinCloudBinding A binding between a space pin and a cloud anchor, by their respective id's. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.ASA Assembly : cs.temp.dll.dll Syntax public struct SpacePinCloudBinding Fields cloudAnchorId Declaration public string cloudAnchorId Field Value Type Description String spacePinId Declaration public string spacePinId Field Value Type Description String"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AdjustLocationDelegate.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AdjustLocationDelegate.html",
    "title": "Delegate AdjustLocationDelegate | World Locking Tools for Unity Documentation",
    "keywords": "Delegate AdjustLocationDelegate Notification that a correction in the world locked space has been computed and should be applied to this object. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate void AdjustLocationDelegate(Pose adjustment); Parameters Type Name Description Pose adjustment The adjustment to apply"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AdjustStateDelegate.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AdjustStateDelegate.html",
    "title": "Delegate AdjustStateDelegate | World Locking Tools for Unity Documentation",
    "keywords": "Delegate AdjustStateDelegate Notification from the system that the state of the fragment containing the attachment point has changed. The client can take action to hide objects in disconnected space if desired. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate void AdjustStateDelegate(AttachmentPointStateType state); Parameters Type Name Description AttachmentPointStateType state The new state of the containing fragment"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AlignmentManager.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AlignmentManager.html",
    "title": "Class AlignmentManager | World Locking Tools for Unity Documentation",
    "keywords": "Class AlignmentManager Unity level implementation of aligning Unity's coordinate system with a discrete finite set of markers in the real world. Inheritance Object AlignmentManager Implements IAlignmentManager Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class AlignmentManager : IAlignmentManager Remarks In addition to anchoring the otherwise arbitrary WorldLocked coordinate space to this set of correspondences, this addresses the tracker-scale issue, whereby due to tracker error, traversing a known distance in the real world traverses a different distance in Unity space. This means that, given a large object of length L meters in Unity space, starting at one end and walking L meters will not end up at the other end of the object, but only within +- 10% of L. Use of this service gives fairly exact correspondence at alignment points, and by interpolation gives fairly accurate correspondence within the convex set of alignment points. Note that no extrapolation is done, so outside the convex set of alignment points results, particularly with respect to scale compensation, will be less accurate. Constructors AlignmentManager(WorldLockingManager) Constructor, binds to a specific WorldLockingManager. Also registers for scene loading events. Declaration public AlignmentManager(WorldLockingManager manager) Parameters Type Name Description WorldLockingManager manager WorldLocking manager which owns this sub-manager. Properties NeedSave Declaration public bool NeedSave { get; } Property Value Type Description Boolean PinnedFromLocked The pose to insert into the camera's hierarchy above the WorldLocking Adjustment transform (if any). Declaration public Pose PinnedFromLocked { get; } Property Value Type Description Pose SaveFileName File to save to and load from. Declaration public string SaveFileName { get; set; } Property Value Type Description String Remarks May optionally contain subpath. For optimal portability, use forward slashes, e.g. \"myPath/myFile.myExt\". May NOT be an absolute path (e.g. \"/myPath.txt\" or \"c:/myPath.txt\" are NOT allowed and will be ignored.) Application can check validity of path using static AlignmentManager.IsValidSavePath(string). Defaults to \"Persistence/Alignment.fwb\". Methods AddAlignmentAnchor(String, Pose, Pose) Declaration public AnchorId AddAlignmentAnchor(string uniqueName, Pose virtualPose, Pose lockedPose) Parameters Type Name Description String uniqueName Pose virtualPose Pose lockedPose Returns Type Description AnchorId ClearAlignmentAnchors() Declaration public void ClearAlignmentAnchors() ComputePinnedPose(Pose) Do the weighted average of all active reference poses to get an alignment pose. Declaration public void ComputePinnedPose(Pose lockedHeadPose) Parameters Type Name Description Pose lockedHeadPose Dispose() Dispose of internals on shutdown. Declaration public void Dispose() Finalize() Dispose of internals on shutdown. Declaration protected void Finalize() GetAlignmentPose(AnchorId, out Pose) Declaration public bool GetAlignmentPose(AnchorId anchorId, out Pose lockedPose) Parameters Type Name Description AnchorId anchorId Pose lockedPose Returns Type Description Boolean IsValidSavePath(String) Check validity of a save/load path. Any path not passing this test will be ignored without error. Declaration public static bool IsValidSavePath(string filePath) Parameters Type Name Description String filePath The path to test. Returns Type Description Boolean True if a valid path. Load() Load the database and issue notification if loaded. Declaration public bool Load() Returns Type Description Boolean True if loaded. RegisterForLoad(PostAlignmentLoadedDelegate) Register for notification after any successful loads. Declaration public void RegisterForLoad(PostAlignmentLoadedDelegate del) Parameters Type Name Description PostAlignmentLoadedDelegate del Delegate to call after successful load. Remarks Registration holds until a corresponding call to UnregisterForLoad(PostAlignmentLoadedDelegate) . RemoveAlignmentAnchor(AnchorId) Declaration public bool RemoveAlignmentAnchor(AnchorId anchorId) Parameters Type Name Description AnchorId anchorId Returns Type Description Boolean RestoreAlignmentAnchor(String, Pose) Declaration public AnchorId RestoreAlignmentAnchor(string uniqueName, Pose virtualPose) Parameters Type Name Description String uniqueName Pose virtualPose Returns Type Description AnchorId Save() Explicitly save the database. Declaration public bool Save() Returns Type Description Boolean True if successfully saved. SendAlignmentAnchors() Declaration public void SendAlignmentAnchors() UnregisterForLoad(PostAlignmentLoadedDelegate) Un-register for post load notifications, after registration via RegisterForLoad(PostAlignmentLoadedDelegate) . Declaration public void UnregisterForLoad(PostAlignmentLoadedDelegate del) Parameters Type Name Description PostAlignmentLoadedDelegate del The delegate to unregister. Events OnTriangulationBuilt Declaration public event EventHandler<ITriangulator> OnTriangulationBuilt Event Type Type Description EventHandler < ITriangulator > Implements IAlignmentManager"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AlignSubtree.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AlignSubtree.html",
    "title": "Class AlignSubtree | World Locking Tools for Unity Documentation",
    "keywords": "Class AlignSubtree Script to use an independent AlignmentManager to align a specific subtree, independent of the rest of the scene. Inheritance Object AlignSubtree Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class AlignSubtree : MonoBehaviour Remarks The subtree aligned by this will remain world-locked by the independent global world-locking by the WorldLockingManager. This script illustrates how to create and manage an independent AlignmentManager, and apply its alignment to a specific subtree within the scene (the Sub Tree). The global AlignmentManager, owned and managed by the WorldLockingManager, applies its alignment to the global Unity coordinate space (frozen space). The desire here is to use the same Space Pin feature to pin parts of a virtual model (subtree) to the physical world, without affecting global space. To do this requires several steps: Create a new locally owned AlignmentManager (distinct from the one owned by the WorldLockingManager). See Microsoft.MixedReality.WorldLocking.Core.AlignSubtree.CheckInternalWiring . Point the desired SpacePins to use the locally owned AlignmentManager (they default to use the global one). See Microsoft.MixedReality.WorldLocking.Core.AlignSubtree.OnEnable . Use the local AlignmentManager to compute a correction pose, and apply it to the subtree. See Microsoft.MixedReality.WorldLocking.Core.AlignSubtree.Update . On point 2., there are a number of reasonable ways to harvest which SpacePins should use this local AlignmentManager, the method used here, invoking GetComponentsInChildren, is just one such way. Fields subTree The transform to align. If unset, will align this.transform. Declaration public Transform subTree Field Value Type Description Transform Remarks This transform must be identity at startup, and must not be modified by anything but this AlignSubtree component. Properties AlignmentManager Owned independent AlignmentManager. Declaration public AlignmentManager AlignmentManager { get; } Property Value Type Description AlignmentManager CollectFromTree Collect all SpacePins from this subtree to manage. Declaration public bool CollectFromTree { get; set; } Property Value Type Description Boolean Orienter Optional orienter for implicit orientation SpacePins. If null, will search for it in subtree. Declaration public IOrienter Orienter { get; set; } Property Value Type Description IOrienter SaveFileName File name for saving to and loading from. Defaults to gameObject's name. Use forward slash '/' for subfolders. Declaration public string SaveFileName { get; set; } Property Value Type Description String Remarks Any non-existent file and/or containing folders will be created if possible. Methods AddOwnedPin(SpacePin) Explicitly add a pin to the owned pins list. Declaration public bool AddOwnedPin(SpacePin pin) Parameters Type Name Description SpacePin pin THe pin to add. Returns Type Description Boolean True if added, false if it was already there. ClaimPinOwnership() This should be called whenever pins are added to the owned list. Declaration public void ClaimPinOwnership() Remarks It's only necessary to call this when adding pins to the owned list dynamically from script. It is called from OnEnable for all pins added in the inspector or collected from the scene graph subtree. ClearOwnedPins() Clear the entire list of owned space pins. Declaration public void ClearOwnedPins() Remarks This removes all pins in the list, whether added dynamically or added in the inspector. Load() Explicit command to load the alignment manager from store. Declaration public bool Load() Returns Type Description Boolean True on successful load. RemoveOwnedPin(SpacePin) Remove a specific pin from the owned pins list. Declaration public bool RemoveOwnedPin(SpacePin pin) Parameters Type Name Description SpacePin pin The pin to remove. Returns Type Description Boolean True if removed, else false (probably not found). Save() Explicit command to save the alignment manager to store. Declaration public bool Save() Returns Type Description Boolean True on successful save. Events OnAlignManagerCreated Fired when a new AlignmentManager has been created throughout CheckInternalWiring Declaration public event EventHandler<IAlignmentManager> OnAlignManagerCreated Event Type Type Description EventHandler < IAlignmentManager >"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorManager.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorManager.html",
    "title": "Class AnchorManager | World Locking Tools for Unity Documentation",
    "keywords": "Class AnchorManager Encapsulation of spongy world (raw input) state. Its primary duty is the creation and maintenance of the graph of (spongy) anchors built up over the space traversed by the camera. Inheritance Object AnchorManager AnchorManagerARCore AnchorManagerNull AnchorManagerWSA Implements IAnchorManager IDisposable Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public abstract class AnchorManager : IAnchorManager, IDisposable Remarks Anchor and Edge creation algorithm: Goal: a simple and robust algorithm that guarantees an even distribution of anchors, fully connected by edges between nearest neighbors with a minimum of redundant edges For simplicity, the algorithm should be stateless between time steps Rules two parameters define spheres MIN and MAX around current position whenever MIN does not contain any anchors, a new anchor is created when a new anchor is created is is linked by edges to all anchors within MAX the MAX radius is 20cm larger than MIN radius which would require 12 m/s beyond world record sprinting speed to cover in one frame whenever MIN contains more than one anchor, the anchor closest to current position is connected to all others within MIN Constructors AnchorManager(IPlugin, IHeadPoseTracker) Set up an anchor manager. Declaration public AnchorManager(IPlugin plugin, IHeadPoseTracker headTracker) Parameters Type Name Description IPlugin plugin The engine interface to update with the current anchor graph. IHeadPoseTracker headTracker Properties AnchorFromSpongy Declaration public virtual Pose AnchorFromSpongy { get; } Property Value Type Description Pose ErrorStatus Error string for last error, cleared at beginning of each update. Declaration public string ErrorStatus { get; } Property Value Type Description String MaxAnchorEdgeLength Maximum distance between two anchors to create an edge between them. Declaration public float MaxAnchorEdgeLength { get; set; } Property Value Type Description Single Remarks Note that the MaxAnchorEdgeLength should be longer than the MinAnchorDistance, or else anchors will not be connected into a graph as they are created. MaxLocalAnchors Maximum number of local anchors in the internal anchor graph. Declaration public int MaxLocalAnchors { get; set; } Property Value Type Description Int32 Remarks Zero or negative means unlimited anchors. MinNewAnchorDistance Minimum distance of head to nearest anchor to create a new anchor. Declaration public float MinNewAnchorDistance { get; set; } Property Value Type Description Single NumAnchors Return the current number of spongy anchors. Declaration public int NumAnchors { get; } Property Value Type Description Int32 NumEdges The number of edges connecting spongy anchors. Declaration public int NumEdges { get; } Property Value Type Description Int32 SpongyAnchors Declaration public List<AnchorManager.SpongyAnchorWithId> SpongyAnchors { get; } Property Value Type Description List < AnchorManager.SpongyAnchorWithId > SupportsPersistence Whether the underlying anchors can be locally persisted and reloaded. Declaration public abstract bool SupportsPersistence { get; } Property Value Type Description Boolean TrackingStartDelayTime Declaration protected abstract float TrackingStartDelayTime { get; } Property Value Type Description Single Methods CreateAnchor(AnchorId, Transform, Pose) Platform dependent instantiation of a local anchor at given position. Declaration protected abstract SpongyAnchor CreateAnchor(AnchorId id, Transform parent, Pose initialPose) Parameters Type Name Description AnchorId id Anchor id to give new anchor. Transform parent Object to hang anchor off of. Pose initialPose Pose for the anchor. Returns Type Description SpongyAnchor The new anchor DebugLogExtra(String) Declaration [Conditional(\"WLT_EXTRA_LOGGING\")] protected static void DebugLogExtra(string message) Parameters Type Name Description String message DebugLogSetup(String) Declaration [Conditional(\"WLT_LOG_SETUP\")] protected static void DebugLogSetup(string message) Parameters Type Name Description String message DestroyAnchor(AnchorId, SpongyAnchor) Platform dependent disposal of local anchors. Declaration protected abstract SpongyAnchor DestroyAnchor(AnchorId id, SpongyAnchor spongyAnchor) Parameters Type Name Description AnchorId id The id of the anchor to destroy. SpongyAnchor spongyAnchor Reference to the anchor to destroy. Returns Type Description SpongyAnchor Null Remarks The id is used to delete from any stored lists. If the SpongyAnchor hasn't been added to any lists (is still initializing), id can be AnchorId.Invalid. Dispose() Explicit dispose to release resources. Declaration public void Dispose() Finalize() GC release of resources. Declaration protected void Finalize() IsTracking() Declaration protected abstract bool IsTracking() Returns Type Description Boolean LoadAnchors() Load the spongy anchors from persistent storage Declaration public async Task LoadAnchors() Returns Type Description Task Remarks The set of spongy anchors loaded by this routine is defined by the frozen anchors previously loaded into the plugin. Likewise, when a spongy anchor fails to load, this routine will delete its frozen counterpart from the plugin. LoadAnchors(IPlugin, AnchorId, Transform, List<AnchorManager.SpongyAnchorWithId>) Declaration protected virtual async Task LoadAnchors(IPlugin plugin, AnchorId firstId, Transform parent, List<AnchorManager.SpongyAnchorWithId> spongyAnchors) Parameters Type Name Description IPlugin plugin AnchorId firstId Transform parent List < AnchorManager.SpongyAnchorWithId > spongyAnchors Returns Type Description Task RemoveSpongyAnchorById(AnchorId) Remove all internal references to the anchor identified. Declaration protected void RemoveSpongyAnchorById(AnchorId id) Parameters Type Name Description AnchorId id The anchor to forget. Remarks It is not an error to pass in AnchorId.Unknown or AnchorId.Invalid, although neither will have any effect. It is an error to pass in a valid id which doesn't correspond to a valid anchor. This function should be called as part of any IAnchorManager's implementation of DestroyAnchor(). Reset() Delete all spongy anchor objects and reset internal state Declaration public void Reset() SaveAnchors() Save the spongy anchors to persistent storage Declaration public async Task SaveAnchors() Returns Type Description Task SaveAnchors(List<AnchorManager.SpongyAnchorWithId>) Declaration protected virtual async Task SaveAnchors(List<AnchorManager.SpongyAnchorWithId> spongyAnchors) Parameters Type Name Description List < AnchorManager.SpongyAnchorWithId > spongyAnchors Returns Type Description Task Update() Create missing spongy anchors/edges and feed plugin with up-to-date input Declaration public virtual bool Update() Returns Type Description Boolean Boolean: Has the plugin received input to provide an adjustment? Implements IAnchorManager System.IDisposable"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorManager.SpongyAnchorWithId.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorManager.SpongyAnchorWithId.html",
    "title": "Struct AnchorManager.SpongyAnchorWithId | World Locking Tools for Unity Documentation",
    "keywords": "Struct AnchorManager.SpongyAnchorWithId Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public struct SpongyAnchorWithId Fields anchorId Declaration public AnchorId anchorId Field Value Type Description AnchorId spongyAnchor Declaration public SpongyAnchor spongyAnchor Field Value Type Description SpongyAnchor"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorManagerARCore.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorManagerARCore.html",
    "title": "Class AnchorManagerARCore | World Locking Tools for Unity Documentation",
    "keywords": "Class AnchorManagerARCore Inheritance Object AnchorManager AnchorManagerARCore Implements IAnchorManager IDisposable Inherited Members AnchorManager.MinNewAnchorDistance AnchorManager.MaxAnchorEdgeLength AnchorManager.MaxLocalAnchors AnchorManager.ErrorStatus AnchorManager.NumAnchors AnchorManager.NumEdges AnchorManager.AnchorFromSpongy AnchorManager.SpongyAnchors AnchorManager.Dispose() AnchorManager.Reset() AnchorManager.Update() AnchorManager.DebugLogExtra(String) AnchorManager.DebugLogSetup(String) AnchorManager.RemoveSpongyAnchorById(AnchorId) AnchorManager.SaveAnchors() AnchorManager.SaveAnchors(List<AnchorManager.SpongyAnchorWithId>) AnchorManager.LoadAnchors() AnchorManager.LoadAnchors(IPlugin, AnchorId, Transform, List<AnchorManager.SpongyAnchorWithId>) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class AnchorManagerARCore : AnchorManager, IAnchorManager, IDisposable Properties SupportsPersistence Whether the underlying anchors can be locally persisted and reloaded. Declaration public override bool SupportsPersistence { get; } Property Value Type Description Boolean Overrides AnchorManager.SupportsPersistence TrackingStartDelayTime Declaration protected override float TrackingStartDelayTime { get; } Property Value Type Description Single Overrides AnchorManager.TrackingStartDelayTime Methods CreateAnchor(AnchorId, Transform, Pose) Declaration protected override SpongyAnchor CreateAnchor(AnchorId id, Transform parent, Pose initialPose) Parameters Type Name Description AnchorId id Transform parent Pose initialPose Returns Type Description SpongyAnchor Overrides AnchorManager.CreateAnchor(AnchorId, Transform, Pose) DestroyAnchor(AnchorId, SpongyAnchor) Declaration protected override SpongyAnchor DestroyAnchor(AnchorId id, SpongyAnchor spongyAnchor) Parameters Type Name Description AnchorId id SpongyAnchor spongyAnchor Returns Type Description SpongyAnchor Overrides AnchorManager.DestroyAnchor(AnchorId, SpongyAnchor) IsTracking() Declaration protected override bool IsTracking() Returns Type Description Boolean Overrides AnchorManager.IsTracking() TryCreate(IPlugin, IHeadPoseTracker) Declaration public static AnchorManagerARCore TryCreate(IPlugin plugin, IHeadPoseTracker headTracker) Parameters Type Name Description IPlugin plugin IHeadPoseTracker headTracker Returns Type Description AnchorManagerARCore Implements IAnchorManager System.IDisposable"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorManagerNull.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorManagerNull.html",
    "title": "Class AnchorManagerNull | World Locking Tools for Unity Documentation",
    "keywords": "Class AnchorManagerNull Inheritance Object AnchorManager AnchorManagerNull Implements IAnchorManager IDisposable Inherited Members AnchorManager.MinNewAnchorDistance AnchorManager.MaxAnchorEdgeLength AnchorManager.MaxLocalAnchors AnchorManager.ErrorStatus AnchorManager.NumAnchors AnchorManager.NumEdges AnchorManager.AnchorFromSpongy AnchorManager.SpongyAnchors AnchorManager.Dispose() AnchorManager.Reset() AnchorManager.Update() AnchorManager.DebugLogExtra(String) AnchorManager.DebugLogSetup(String) AnchorManager.RemoveSpongyAnchorById(AnchorId) AnchorManager.SaveAnchors() AnchorManager.LoadAnchors() Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class AnchorManagerNull : AnchorManager, IAnchorManager, IDisposable Properties SupportsPersistence Whether the underlying anchors can be locally persisted and reloaded. Declaration public override bool SupportsPersistence { get; } Property Value Type Description Boolean Overrides AnchorManager.SupportsPersistence TrackingStartDelayTime Declaration protected override float TrackingStartDelayTime { get; } Property Value Type Description Single Overrides AnchorManager.TrackingStartDelayTime Methods CreateAnchor(AnchorId, Transform, Pose) Declaration protected override SpongyAnchor CreateAnchor(AnchorId id, Transform parent, Pose initialPose) Parameters Type Name Description AnchorId id Transform parent Pose initialPose Returns Type Description SpongyAnchor Overrides AnchorManager.CreateAnchor(AnchorId, Transform, Pose) DestroyAnchor(AnchorId, SpongyAnchor) Declaration protected override SpongyAnchor DestroyAnchor(AnchorId id, SpongyAnchor spongyAnchor) Parameters Type Name Description AnchorId id SpongyAnchor spongyAnchor Returns Type Description SpongyAnchor Overrides AnchorManager.DestroyAnchor(AnchorId, SpongyAnchor) IsTracking() Declaration protected override bool IsTracking() Returns Type Description Boolean Overrides AnchorManager.IsTracking() LoadAnchors(IPlugin, AnchorId, Transform, List<AnchorManager.SpongyAnchorWithId>) Load the spongy anchors from persistent storage Declaration protected override async Task LoadAnchors(IPlugin plugin, AnchorId firstId, Transform parent, List<AnchorManager.SpongyAnchorWithId> spongyAnchors) Parameters Type Name Description IPlugin plugin AnchorId firstId Transform parent List < AnchorManager.SpongyAnchorWithId > spongyAnchors Returns Type Description Task Overrides AnchorManager.LoadAnchors(IPlugin, AnchorId, Transform, List<AnchorManager.SpongyAnchorWithId>) Remarks The set of spongy anchors loaded by this routine is defined by the frozen anchors previously loaded into the plugin. Likewise, when a spongy anchor fails to load, this routine will delete its frozen counterpart from the plugin. SaveAnchors(List<AnchorManager.SpongyAnchorWithId>) Declaration protected override async Task SaveAnchors(List<AnchorManager.SpongyAnchorWithId> spongyAnchors) Parameters Type Name Description List < AnchorManager.SpongyAnchorWithId > spongyAnchors Returns Type Description Task Overrides AnchorManager.SaveAnchors(List<AnchorManager.SpongyAnchorWithId>) TryCreate(IPlugin, IHeadPoseTracker) Declaration public static AnchorManagerNull TryCreate(IPlugin plugin, IHeadPoseTracker headTracker) Parameters Type Name Description IPlugin plugin IHeadPoseTracker headTracker Returns Type Description AnchorManagerNull Implements IAnchorManager System.IDisposable"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorManagerWSA.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorManagerWSA.html",
    "title": "Class AnchorManagerWSA | World Locking Tools for Unity Documentation",
    "keywords": "Class AnchorManagerWSA Encapsulation of spongy world (raw input) state. Its primary duty is the creation and maintenance of the graph of (spongy) anchors built up over the space traversed by the camera. Inheritance Object AnchorManager AnchorManagerWSA Implements IAnchorManager IDisposable Inherited Members AnchorManager.MinNewAnchorDistance AnchorManager.MaxAnchorEdgeLength AnchorManager.MaxLocalAnchors AnchorManager.ErrorStatus AnchorManager.NumAnchors AnchorManager.NumEdges AnchorManager.AnchorFromSpongy AnchorManager.SpongyAnchors AnchorManager.Dispose() AnchorManager.Reset() AnchorManager.Update() AnchorManager.DebugLogExtra(String) AnchorManager.DebugLogSetup(String) AnchorManager.RemoveSpongyAnchorById(AnchorId) AnchorManager.SaveAnchors() AnchorManager.LoadAnchors() Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class AnchorManagerWSA : AnchorManager, IAnchorManager, IDisposable Remarks Anchor and Edge creation algorithm: Goal: a simple and robust algorithm that guarantees an even distribution of anchors, fully connected by edges between nearest neighbors with a minimum of redundant edges For simplicity, the algorithm should be stateless between time steps Rules two parameters define spheres MIN and MAX around current position whenever MIN does not contain any anchors, a new anchor is created when a new anchor is created is is linked by edges to all anchors within MAX the MAX radius is 20cm larger than MIN radius which would require 12 m/s beyond world record sprinting speed to cover in one frame whenever MIN contains more than one anchor, the anchor closest to current position is connected to all others within MIN Properties SupportsPersistence Whether the underlying anchors can be locally persisted and reloaded. Declaration public override bool SupportsPersistence { get; } Property Value Type Description Boolean Overrides AnchorManager.SupportsPersistence TrackingStartDelayTime Declaration protected override float TrackingStartDelayTime { get; } Property Value Type Description Single Overrides AnchorManager.TrackingStartDelayTime Methods CreateAnchor(AnchorId, Transform, Pose) Declaration protected override SpongyAnchor CreateAnchor(AnchorId id, Transform parent, Pose initialPose) Parameters Type Name Description AnchorId id Transform parent Pose initialPose Returns Type Description SpongyAnchor Overrides AnchorManager.CreateAnchor(AnchorId, Transform, Pose) DestroyAnchor(AnchorId, SpongyAnchor) Declaration protected override SpongyAnchor DestroyAnchor(AnchorId id, SpongyAnchor spongyAnchor) Parameters Type Name Description AnchorId id SpongyAnchor spongyAnchor Returns Type Description SpongyAnchor Overrides AnchorManager.DestroyAnchor(AnchorId, SpongyAnchor) IsTracking() Declaration protected override bool IsTracking() Returns Type Description Boolean Overrides AnchorManager.IsTracking() LoadAnchors(IPlugin, AnchorId, Transform, List<AnchorManager.SpongyAnchorWithId>) Load the spongy anchors from persistent storage Declaration protected override async Task LoadAnchors(IPlugin plugin, AnchorId firstId, Transform parent, List<AnchorManager.SpongyAnchorWithId> spongyAnchors) Parameters Type Name Description IPlugin plugin AnchorId firstId Transform parent List < AnchorManager.SpongyAnchorWithId > spongyAnchors Returns Type Description Task Overrides AnchorManager.LoadAnchors(IPlugin, AnchorId, Transform, List<AnchorManager.SpongyAnchorWithId>) Remarks The set of spongy anchors loaded by this routine is defined by the frozen anchors previously loaded into the plugin. Likewise, when a spongy anchor fails to load, this routine will delete its frozen counterpart from the plugin. SaveAnchors(List<AnchorManager.SpongyAnchorWithId>) Declaration protected override async Task SaveAnchors(List<AnchorManager.SpongyAnchorWithId> spongyAnchors) Parameters Type Name Description List < AnchorManager.SpongyAnchorWithId > spongyAnchors Returns Type Description Task Overrides AnchorManager.SaveAnchors(List<AnchorManager.SpongyAnchorWithId>) TryCreate(IPlugin, IHeadPoseTracker) Declaration public static AnchorManagerWSA TryCreate(IPlugin plugin, IHeadPoseTracker headTracker) Parameters Type Name Description IPlugin plugin IHeadPoseTracker headTracker Returns Type Description AnchorManagerWSA Implements IAnchorManager System.IDisposable"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorSettings.AnchorSubsystem.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorSettings.AnchorSubsystem.html",
    "title": "Enum AnchorSettings.AnchorSubsystem | World Locking Tools for Unity Documentation",
    "keywords": "Enum AnchorSettings.AnchorSubsystem Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public enum AnchorSubsystem Fields Name Description ARCore ARFoundation Null WSA XRSDK"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorSettings.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorSettings.html",
    "title": "Struct AnchorSettings | World Locking Tools for Unity Documentation",
    "keywords": "Struct AnchorSettings Settings related to management of the internal anchor graph. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax [Serializable] public struct AnchorSettings Fields anchorSubsystem Choice of subsystem that supplies anchors. Declaration public AnchorSettings.AnchorSubsystem anchorSubsystem Field Value Type Description AnchorSettings.AnchorSubsystem ARSessionOriginSource GameObject which has (or will have) the ARSessionOrigin component, required when using AR Foundation. Declaration public GameObject ARSessionOriginSource Field Value Type Description GameObject Remarks Ignored except when anchorSubsystem == ARF. ARSessionSource GameObject which has (or will have) the ARSession component, required when using the AR Foundation. Declaration public GameObject ARSessionSource Field Value Type Description GameObject Remarks Ignored except when anchorSubsystem == ARF. MaxAnchorEdgeLength The maximum distance between two anchors to connect them with a graph edge. Declaration public float MaxAnchorEdgeLength Field Value Type Description Single Remarks This must be greater than MinNewAnchorDistance to create a connected graph of anchors. MaxLocalAnchors The maximum number of local anchors in the internal anchor graph. Declaration public int MaxLocalAnchors Field Value Type Description Int32 Remarks Zero or any negative value is considered to be infinite (unlimited). MinNewAnchorDistance The minimum distance to the current closest anchor before creating a new anchor. Declaration public float MinNewAnchorDistance Field Value Type Description Single Remarks A greater value will result in a less dense anchor coverage. NullSubsystemInEditor Use the Null anchor subsystem when running in Unity Editor. Declaration public bool NullSubsystemInEditor Field Value Type Description Boolean Properties IsValid Check the validity of the settings. Declaration public readonly bool IsValid { get; } Property Value Type Description Boolean UseDefaults Ignore set values and use default behavior. When set, will reset all values to defaults. Declaration public bool UseDefaults { get; set; } Property Value Type Description Boolean Methods InitToDefaults() Init all fields to default values. Declaration public void InitToDefaults()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AttachmentPoint.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AttachmentPoint.html",
    "title": "Class AttachmentPoint | World Locking Tools for Unity Documentation",
    "keywords": "Class AttachmentPoint Implementation of the IAttachmentPoint interface. Provides implementations, as well as a binding to the update delegates. Inheritance Object AttachmentPoint Implements IAttachmentPoint Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class AttachmentPoint : IAttachmentPoint Constructors AttachmentPoint(AdjustLocationDelegate, AdjustStateDelegate) Constructor, sets handlers Declaration public AttachmentPoint(AdjustLocationDelegate locationHandler, AdjustStateDelegate stateHandler) Parameters Type Name Description AdjustLocationDelegate locationHandler Handler for positional adjustments, may be null. AdjustStateDelegate stateHandler Handler for connectivity adjustments, may be null. Properties AnchorId Associated anchor id Declaration public AnchorId AnchorId { get; } Property Value Type Description AnchorId CachedPosition Internal history cache. Declaration public Vector3 CachedPosition { get; set; } Property Value Type Description Vector3 FragmentId Associated fragment id Declaration public FragmentId FragmentId { get; } Property Value Type Description FragmentId LocationFromAnchor Position of attachment point in anchor point's space. Declaration public Vector3 LocationFromAnchor { get; set; } Property Value Type Description Vector3 LocationHandler Handler for system positional adjustments. May be null Declaration public AdjustLocationDelegate LocationHandler { get; } Property Value Type Description AdjustLocationDelegate Name Name is auto-populated on create with something unique, but can be renamed to anything useful and convenient. It is only used as a label, so can be anything (including empty or null). Declaration public string Name { get; set; } Property Value Type Description String ObjectAdjustment Cumulative transform adjustment for object(s) bound to this attachment point. Declaration public Pose ObjectAdjustment { get; set; } Property Value Type Description Pose ObjectPosition The position of object(s) bound to this attachment point. Declaration public Vector3 ObjectPosition { get; set; } Property Value Type Description Vector3 State Current state of this attachment point. Declaration public AttachmentPointStateType State { get; set; } Property Value Type Description AttachmentPointStateType Remarks Positioning information is only valid when state is Normal. See AttachmentPointStateType StateHandler Handler for system connectivity adjustments. May be null. Declaration public AdjustStateDelegate StateHandler { get; } Property Value Type Description AdjustStateDelegate Methods HandlePoseAdjustment(Pose) Keep track of cumulative transform adjustment, and pass on to client adjustment handler (if any). Declaration public void HandlePoseAdjustment(Pose adjustment) Parameters Type Name Description Pose adjustment Remarks See ObjectAdjustment and AdjustLocationDelegate HandleStateChange(AttachmentPointStateType) If state has changed, record the new state and pass on to client handler (if any). Declaration public void HandleStateChange(AttachmentPointStateType newState) Parameters Type Name Description AttachmentPointStateType newState The state to change to. MoveTo(IAttachmentPointManager, Vector3) Notify attachment point that it has moved incrementally to a new position. Declaration public void MoveTo(IAttachmentPointManager manager, Vector3 newFrozenPosition) Parameters Type Name Description IAttachmentPointManager manager The mananger Vector3 newFrozenPosition The new position Remarks This should be used for conceptually continuous motion. For discontinuous motion (i.e. teleport), use TeleportTo(IAttachmentPointManager, Vector3, IAttachmentPoint) . This is equivalent to MoveAttachmentPoint(IAttachmentPoint, Vector3) Set(FragmentId, Vector3, AnchorId, Vector3) Set internals of attachment point to new values. Declaration public void Set(FragmentId fragmentId, Vector3 cachedPosition, AnchorId anchorId, Vector3 locationFromAnchor) Parameters Type Name Description FragmentId fragmentId New fragment Vector3 cachedPosition Cache last position moved to. AnchorId anchorId New anchor id Vector3 locationFromAnchor New displacement from anchor TeleportTo(IAttachmentPointManager, Vector3, IAttachmentPoint) Notify attachment point that it has teleported to a new position. Declaration public void TeleportTo(IAttachmentPointManager manager, Vector3 newFrozenPosition, IAttachmentPoint parent) Parameters Type Name Description IAttachmentPointManager manager The manager Vector3 newFrozenPosition The new position IAttachmentPoint parent Remarks This should be used for discontinuous movement, i.e. teleporting. For continuous motion, use MoveTo(IAttachmentPointManager, Vector3) . This is equivalent to TeleportAttachmentPoint(IAttachmentPoint, Vector3, IAttachmentPoint) Implements IAttachmentPoint"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AttachmentPointStateType.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AttachmentPointStateType.html",
    "title": "Enum AttachmentPointStateType | World Locking Tools for Unity Documentation",
    "keywords": "Enum AttachmentPointStateType The states an attachment point can be in. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public enum AttachmentPointStateType Fields Name Description Invalid Normal Pending Released Unconnected"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Diagnostics.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Diagnostics.html",
    "title": "Class Diagnostics | World Locking Tools for Unity Documentation",
    "keywords": "Class Diagnostics Writer of diagnostics for postmortem analysis. Inheritance Object Diagnostics Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax [Serializable] public class Diagnostics : IDisposable Fields persistentDataPath Declaration protected string persistentDataPath Field Value Type Description String serializer Declaration protected IPluginSerializer serializer Field Value Type Description IPluginSerializer writeQueue Declaration protected BlockingCollection<Diagnostics.Record> writeQueue Field Value Type Description BlockingCollection < Diagnostics.Record > writeTask Declaration protected Task writeTask Field Value Type Description Task Properties SharedSettings Provide access to the shared configuration. Get and set of settings is through DiagnosticsSettings Declaration public SharedDiagnosticsSettings SharedSettings { get; set; } Property Value Type Description SharedDiagnosticsSettings Methods createNextFile(DateTime) Declaration protected Stream createNextFile(DateTime time) Parameters Type Name Description DateTime time Returns Type Description Stream deleteObsoleteFiles() Declaration protected void deleteObsoleteFiles() Dispose() Free all, after possible wait for finish. Declaration public void Dispose() processWriteQueue() Declaration protected void processWriteQueue() Start(IPlugin) Get set up. Declaration public void Start(IPlugin plugin) Parameters Type Name Description IPlugin plugin The plugin providing necessary resources Update() Use a time slice for processing any accrued data. Declaration public void Update()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Diagnostics.Record.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Diagnostics.Record.html",
    "title": "Struct Diagnostics.Record | World Locking Tools for Unity Documentation",
    "keywords": "Struct Diagnostics.Record One record (chunk) of data. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax protected struct Record Fields Data Declaration public List<byte[]> Data Field Value Type Description List < Byte []> StartNextFile If true, finish current Declaration public bool StartNextFile Field Value Type Description Boolean Time Declaration public DateTime Time Field Value Type Description DateTime"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.DiagnosticsSettings.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.DiagnosticsSettings.html",
    "title": "Struct DiagnosticsSettings | World Locking Tools for Unity Documentation",
    "keywords": "Struct DiagnosticsSettings Client tune-able settings for the diagnostics. Set through the WorldLockingManager. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax [Serializable] public struct DiagnosticsSettings Fields Enabled Diagnostics can be disabled if unneeded to reclaim any lost performance. Declaration public bool Enabled Field Value Type Description Boolean MaxKilobytesPerFile Max file size. Declaration public int MaxKilobytesPerFile Field Value Type Description Int32 MaxNumberOfFiles Limit number of auto-generated files. Declaration public int MaxNumberOfFiles Field Value Type Description Int32 StorageFileTemplate Base for auto-generated unique filename. Declaration public string StorageFileTemplate Field Value Type Description String StorageSubdirectory Folder in which to keep diagnostics. Declaration public string StorageSubdirectory Field Value Type Description String Properties UseDefaults Ignore set values and use default behavior. When set, will reset all values to defaults. Declaration public bool UseDefaults { get; set; } Property Value Type Description Boolean Methods InitToDefaults() Declaration public DiagnosticsSettings InitToDefaults() Returns Type Description DiagnosticsSettings"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Fragment.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Fragment.html",
    "title": "Class Fragment | World Locking Tools for Unity Documentation",
    "keywords": "Class Fragment Fragment class is a container for attachment points in the same WorldLocking Fragment. It manages their update and adjustment, including merging in the attachment points from another fragment. Inheritance Object Fragment Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class Fragment Constructors Fragment(FragmentId) Declaration public Fragment(FragmentId fragmentId) Parameters Type Name Description FragmentId fragmentId Properties FragmentId Declaration public FragmentId FragmentId { get; } Property Value Type Description FragmentId State Declaration public AttachmentPointStateType State { get; } Property Value Type Description AttachmentPointStateType Methods AbsorbOtherFragment(Fragment) Absorb the contents of another fragment, emptying it. Declaration public void AbsorbOtherFragment(Fragment other) Parameters Type Name Description Fragment other The fragment to lose all its contents to this. AbsorbOtherFragment(Fragment, Pose) Absorb the contents of another fragment, emptying it, and applying an adjustment transform. Declaration public void AbsorbOtherFragment(Fragment other, Pose adjustment) Parameters Type Name Description Fragment other The fragment to lose all its contents to this. Pose adjustment Pose adjustment to apply to contents of other on transition. AddAttachmentPoint(AttachmentPoint) Add an existing attachment point to this fragment. Declaration public void AddAttachmentPoint(AttachmentPoint attachPoint) Parameters Type Name Description AttachmentPoint attachPoint Remarks The attachment point might currently belong to another fragment, if it is being moved from the other to this. Since this is only used internally, it operates directly on an AttachmentPoint rather than an interface to avoid an unnecessary downcast. AdjustAll(IPlugin) Run through all attachment points, get their adjustments from the plugin and apply them. Declaration public void AdjustAll(IPlugin plugin) Parameters Type Name Description IPlugin plugin Remarks This must be called between plugin.Refreeze() and plugin.RefreezeFinish(). ReleaseAll() Release all resources for this fragment. Declaration public void ReleaseAll() ReleaseAttachmentPoint(IAttachmentPoint) Notify system attachment point is no longer needed. See ReleaseAttachmentPoint(IAttachmentPoint) Declaration public void ReleaseAttachmentPoint(IAttachmentPoint attachmentPoint) Parameters Type Name Description IAttachmentPoint attachmentPoint UpdateState(AttachmentPointStateType) Set the state of the contents of this fragment. Declaration public void UpdateState(AttachmentPointStateType attachmentState) Parameters Type Name Description AttachmentPointStateType attachmentState New state"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.HeadPoseTrackerCamera.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.HeadPoseTrackerCamera.html",
    "title": "Class HeadPoseTrackerCamera | World Locking Tools for Unity Documentation",
    "keywords": "Class HeadPoseTrackerCamera Inheritance Object HeadPoseTrackerCamera Implements IHeadPoseTracker Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class HeadPoseTrackerCamera : IHeadPoseTracker Methods BindToCamera(Camera) Declaration public void BindToCamera(Camera c) Parameters Type Name Description Camera c GetHeadPose() Declaration public virtual Pose GetHeadPose() Returns Type Description Pose Reset() Declaration public virtual void Reset() Implements IHeadPoseTracker"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.HeadPoseTrackerXR.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.HeadPoseTrackerXR.html",
    "title": "Class HeadPoseTrackerXR | World Locking Tools for Unity Documentation",
    "keywords": "Class HeadPoseTrackerXR Inheritance Object HeadPoseTrackerXR Implements IHeadPoseTracker Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class HeadPoseTrackerXR : IHeadPoseTracker Methods GetHeadPose() Return the current head pose in Spongy (local) space. Declaration public Pose GetHeadPose() Returns Type Description Pose The current head pose. Reset() Reset is called whenever there is a conceptual restart. Any cached information should be discarded and re-evaluated. Declaration public void Reset() Implements IHeadPoseTracker"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.html",
    "title": "Namespace Microsoft.MixedReality.WorldLocking.Core | World Locking Tools for Unity Documentation",
    "keywords": "Namespace Microsoft.MixedReality.WorldLocking.Core Classes AlignmentManager Unity level implementation of aligning Unity's coordinate system with a discrete finite set of markers in the real world. AlignSubtree Script to use an independent AlignmentManager to align a specific subtree, independent of the rest of the scene. AnchorManager Encapsulation of spongy world (raw input) state. Its primary duty is the creation and maintenance of the graph of (spongy) anchors built up over the space traversed by the camera. AnchorManagerARCore AnchorManagerNull AnchorManagerWSA Encapsulation of spongy world (raw input) state. Its primary duty is the creation and maintenance of the graph of (spongy) anchors built up over the space traversed by the camera. AttachmentPoint Implementation of the IAttachmentPoint interface. Provides implementations, as well as a binding to the update delegates. Diagnostics Writer of diagnostics for postmortem analysis. Fragment Fragment class is a container for attachment points in the same WorldLocking Fragment. It manages their update and adjustment, including merging in the attachment points from another fragment. HeadPoseTrackerCamera HeadPoseTrackerXR Orienter The Orienter class implements IOrienter. OrienterThreeBody Derived class which supports computing implicit rotations in full 3-DOF (6-DOF w/ position). PoseExtensions Extensions for Poses to enable basic transform math. ResourceMirror Class to synchronize a list of resources with associated source data (items). SharedDiagnosticsSettings The SharedSettings boxes the Settings into a sharable reference. SharedManagerSettings Shareable (reference type) version of Settings (value struct). SpacePin Component helper for pinning the world locked space at a single reference point. SpacePinOrientable A component derived from SpacePin which differs only in that, rather than using an explicit rotation passed in, an implicit rotation is calculated based on the relative positions of all active SpacePinOrientable s. SpongyAnchor Wrapper class for Unity spatial anchors, facilitating creation and persistence. SpongyAnchorARCore SpongyAnchorARF Wrapper class for Unity WorldAnchor, facilitating creation and persistence. SpongyAnchorNull Wrapper class for a no-op spatial, platform-free anchor. SpongyAnchorWSA Wrapper class for Unity WorldAnchor, facilitating creation and persistence. SpongyAnchorXR Wrapper class for Unity XRAnchor, facilitating creation and persistence. TransformExtensions Conversion function between a pose and a transform. WorldLockingContext The central component for providing WorldLocking functionality to a scene WorldLockingManager Ultimate manager of World Locking. WorldLockingManager supplies access to the sub-managers, IAnchorManager , IFragmentManager , and IAttachmentPointManager . Structs AnchorManager.SpongyAnchorWithId AnchorSettings Settings related to management of the internal anchor graph. Diagnostics.Record One record (chunk) of data. DiagnosticsSettings Client tune-able settings for the diagnostics. Set through the WorldLockingManager. LinkageSettings Explicitly set required Transform objects. ManagerSettings Manager settings. Orienter.WeightedRotation An object whose rotation needs to be computed, and the weight of its rotation. Interfaces IAlignmentManager Manage pinning the world-locked space to user defined coordinate frame at a discrete set of points in the world. IAnchorManager Create and persist a network of anchors around the camera as it moves around, and feed them into the plugin. IAttachmentPoint Opaque handle to an attachment point. Create one of these to enable WorldLocking to adjust an attached object as corrections to the world locked space optimization are made. IAttachmentPointManager Interface for application creation and manipulation of attachment points. In particular, the creation and release of attachment points must be conducted through the IAttachmentPointManager. IFragmentManager Interface for managing fragments. This mostly comprises the bookkeeping of managing IAttachmentPoint associations, and the intimately related application of refit operations. IHeadPoseTracker Interface for retrieving the current head pose. IOrientable Base class for a thing whose orientation can be inferred from the positions of a collection of IOrientables. IOrienter An object capable of computing self-consistent rotations for IOrientables based on their positions. Enums AnchorSettings.AnchorSubsystem AttachmentPointStateType The states an attachment point can be in. SpacePin.ModelPositionSourceEnum Choice of what to use for modeling position. Delegates AdjustLocationDelegate Notification that a correction in the world locked space has been computed and should be applied to this object. AdjustStateDelegate Notification from the system that the state of the fragment containing the attachment point has changed. The client can take action to hide objects in disconnected space if desired. PostAlignmentLoadedDelegate RefitNotificationDelegate Delegate type for notification of refit operations. ResourceMirror.CompareToResource<ItemType, ResourceType> Function to compare a source item with a resource. It should return: -1 if resource is associated with a smaller item than item. 1 if resource is associated with a larger item than item. 0 if resource is associated with item. ResourceMirror.CreateResource<ItemType, ResourceType> Callback for creating a new instance of a resource matching a specific item. This will be called for each item in Sync's currentItems list which doesn't have a matching resource in Sync's resources list. ResourceMirror.DestroyResource<ResourceType> Callback to release resources. This will be called for each resource in Sync's resource list for which there is no corresponding source data in Sync's currentItems. ResourceMirror.UpdateResource<ItemType, ResourceType> Callback to update existing resources. This will be called for each item and its associated resource in the Sync's currentItems and resources lists."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAlignmentManager.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAlignmentManager.html",
    "title": "Interface IAlignmentManager | World Locking Tools for Unity Documentation",
    "keywords": "Interface IAlignmentManager Manage pinning the world-locked space to user defined coordinate frame at a discrete set of points in the world. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IAlignmentManager Properties NeedSave True if the persistent state of the alignment manager has changed since the last save. Declaration bool NeedSave { get; } Property Value Type Description Boolean PinnedFromLocked The pose to insert into the camera's hierarchy above the WorldLocking Adjustment transform (if any). Declaration Pose PinnedFromLocked { get; } Property Value Type Description Pose Methods AddAlignmentAnchor(String, Pose, Pose) Add an anchor for aligning a virtual pose to a pose in real space. Declaration AnchorId AddAlignmentAnchor(string uniqueName, Pose virtualPose, Pose lockedPose) Parameters Type Name Description String uniqueName Pose virtualPose The pose in modeling space. Pose lockedPose The pose in world locked space. Returns Type Description AnchorId The id for the added anchor if successful, else AnchorId.Unknown. See remarks. Remarks This must be followed by SendAlignmentAnchors() before it will have any effect. The returned AnchorId may be stored for future manipulation of the created anchor (e.g. for individual removal in RemoveAlignmentAnchor(AnchorId) ). The system must be currently tracking to successfully add an alignment anchor. The alignment anchor will be in the current Fragment . The current fragment will be available when there is no tracking, and so this call will fail. If this call fails, indicated by a return of AnchorId.Unknown, then it should be called again on a later frame until it succeeds. ClearAlignmentAnchors() Remove all alignment anchors that have been added. More efficient than removing them individually, and doesn't require having stored their ids on creation. Declaration void ClearAlignmentAnchors() Remarks This is more efficient than removing one by one, but take care to discard all existing AnchorIds returned by AddAlignmentAnchor(String, Pose, Pose) after this call, as it will be an error to try to use any of them. Also note that this clears the Alignment Anchors staged for commit with the next SendAlignmentAnchors() , but the current ones will remain effective until the next call to SendAlignmentAnchors, which will send an empty list, unless it has been repopulated after the call to ClearAlignmentAnchors. ComputePinnedPose(Pose) Update based on new head position. Declaration void ComputePinnedPose(Pose lockedHeadPose) Parameters Type Name Description Pose lockedHeadPose Head pose in world locked space. GetAlignmentPose(AnchorId, out Pose) Get the world locked space pose associated with this alignment anchor. Declaration bool GetAlignmentPose(AnchorId anchorId, out Pose lockedPose) Parameters Type Name Description AnchorId anchorId Which anchor. Pose lockedPose Pose to fill out if alignment anchor is found. Returns Type Description Boolean True if anchor is found and lockedPose filled in, else false and lockedPose set to identity. Load() Load all persisted state required for reconstructing the current pinning. Declaration bool Load() Returns Type Description Boolean True if loaded. Remarks The state required for reconstructing the pinning is loaded, but the reconstruction does not occur. Rather, the PostAlignmentLoadedDelegate is triggered, to prompt external actors to use the RestoreAlignmentAnchor(String, Pose) API to effect the reconstruction. 👍 RegisterForLoad(PostAlignmentLoadedDelegate) Register for notification that pin data has finished loaded and is available. Declaration void RegisterForLoad(PostAlignmentLoadedDelegate del) Parameters Type Name Description PostAlignmentLoadedDelegate del Delegate to notify. Remarks The delegate should be unregistered when no longer needed, e.g. owning object is destroyed. RemoveAlignmentAnchor(AnchorId) Remove the given alignment anchor from the system. Declaration bool RemoveAlignmentAnchor(AnchorId anchorId) Parameters Type Name Description AnchorId anchorId The anchor to remove (as returned by AddAlignmentAnchor(String, Pose, Pose) Returns Type Description Boolean True if the anchor was found. RestoreAlignmentAnchor(String, Pose) Attempt to restore an alignment anchor from an earlier session. Stored alignment anchor must match in both uniqueName and virtual pose. Declaration AnchorId RestoreAlignmentAnchor(string uniqueName, Pose virtualPose) Parameters Type Name Description String uniqueName Unique name use previously to create the alignment anchor. Pose virtualPose Virtual pose to match with stored anchor pose. Returns Type Description AnchorId AnchorId of restored Alignment Anchor on success, else AnchorId.Invalid. Remarks If successful, alignment anchor is added but not sent. It must be followed by a call to SendAlignmentAnchors to take effect. Save() Save state needed to reconstruct later from persistent storage. Declaration bool Save() Returns Type Description Boolean True if saved (even if empty). SendAlignmentAnchors() Submit all accumulated alignment anchors. Declaration void SendAlignmentAnchors() Remarks All anchors previously submitted via SendAlignmentAnchors() will be cleared and replaced by the current set. SendAlignmentAnchors() submits the current set of anchors, but they will have no effect until the next Refreeze() is successfully performed. UnregisterForLoad(PostAlignmentLoadedDelegate) Unregister for notification that pin data has finished loaded and is available. Declaration void UnregisterForLoad(PostAlignmentLoadedDelegate del) Parameters Type Name Description PostAlignmentLoadedDelegate del Delegate to remove from notifications. Events OnTriangulationBuilt New triangulation was built based upon recent poses. Declaration event EventHandler<ITriangulator> OnTriangulationBuilt Event Type Type Description EventHandler < ITriangulator >"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAnchorManager.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAnchorManager.html",
    "title": "Interface IAnchorManager | World Locking Tools for Unity Documentation",
    "keywords": "Interface IAnchorManager Create and persist a network of anchors around the camera as it moves around, and feed them into the plugin. Inherited Members IDisposable.Dispose() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IAnchorManager : IDisposable Properties AnchorFromSpongy Get the transform from spongy space to the space anchors are located in. Declaration UnityEngine.Pose AnchorFromSpongy { get; } Property Value Type Description UnityEngine.Pose Remarks This varies according to the design of the underlying platform anchor subsystem. It may also vary over time (so don't cache this). ErrorStatus Error string for last error, cleared at beginning of each update. Declaration string ErrorStatus { get; } Property Value Type Description String MaxAnchorEdgeLength Maximum distance between two anchors to create an edge between them. Declaration float MaxAnchorEdgeLength { get; set; } Property Value Type Description Single Remarks Note that the MaxAnchorEdgeLength should be longer than the MinAnchorDistance, or else anchors will not be connected into a graph as they are created. MaxLocalAnchors Maximum number of local anchors in the internal anchor graph. Declaration int MaxLocalAnchors { get; set; } Property Value Type Description Int32 Remarks Zero or negative means unlimited anchors. MinNewAnchorDistance Minimum distance of head to nearest anchor to create a new anchor. Declaration float MinNewAnchorDistance { get; set; } Property Value Type Description Single NumAnchors Return the current number of spongy anchors. Declaration int NumAnchors { get; } Property Value Type Description Int32 Remarks The number of anchors known to AnchorManager should always be identical to the frozen anchors known to the engine. NumEdges The number of edges connecting spongy anchors. Declaration int NumEdges { get; } Property Value Type Description Int32 SupportsPersistence Whether the underlying anchors can be locally persisted and reloaded. Declaration bool SupportsPersistence { get; } Property Value Type Description Boolean Methods LoadAnchors() Load the spongy anchors from persistent storage Declaration Task LoadAnchors() Returns Type Description Task Remarks The set of spongy anchors loaded by this routine is defined by the frozen anchors previously loaded into the plugin. Likewise, when a spongy anchor fails to load, this routine will delete its frozen counterpart from the plugin. Reset() Delete all spongy anchor objects and reset internal state Declaration void Reset() SaveAnchors() Save the spongy anchors to persistent storage Declaration Task SaveAnchors() Returns Type Description Task Update() Create any needed anchors/edges and update plugin Declaration bool Update() Returns Type Description Boolean Whether any anchors are active and were updated."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAttachmentPoint.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAttachmentPoint.html",
    "title": "Interface IAttachmentPoint | World Locking Tools for Unity Documentation",
    "keywords": "Interface IAttachmentPoint Opaque handle to an attachment point. Create one of these to enable WorldLocking to adjust an attached object as corrections to the world locked space optimization are made. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IAttachmentPoint Remarks The attachment point gives an interface for notifying the system that you have moved the attached object, and the system indicates that it has computed an adjustment for the object through the callbacks passed into the creation routine. Alternatively, polling is also supported through the State and ObjectAdjustment accessors. Properties AnchorId Associated anchor id Declaration AnchorId AnchorId { get; } Property Value Type Description AnchorId CachedPosition Internal history cache. Declaration Vector3 CachedPosition { get; } Property Value Type Description Vector3 FragmentId Associated fragment id Declaration FragmentId FragmentId { get; } Property Value Type Description FragmentId LocationFromAnchor Position of attachment point in anchor point's space. Declaration Vector3 LocationFromAnchor { get; } Property Value Type Description Vector3 Name Name is auto-populated on create with something unique, but can be renamed to anything useful and convenient. It is only used as a label, so can be anything (including empty or null). Declaration string Name { get; set; } Property Value Type Description String ObjectAdjustment Cumulative transform adjustment for object(s) bound to this attachment point. Declaration Pose ObjectAdjustment { get; } Property Value Type Description Pose ObjectPosition The position of object(s) bound to this attachment point. Declaration Vector3 ObjectPosition { get; } Property Value Type Description Vector3 State Current state of this attachment point. Declaration AttachmentPointStateType State { get; } Property Value Type Description AttachmentPointStateType Remarks Positioning information is only valid when state is Normal. See AttachmentPointStateType Methods MoveTo(IAttachmentPointManager, Vector3) Notify attachment point that it has moved incrementally to a new position. Declaration void MoveTo(IAttachmentPointManager manager, Vector3 newFrozenPosition) Parameters Type Name Description IAttachmentPointManager manager The mananger Vector3 newFrozenPosition The new position Remarks This should be used for conceptually continuous motion. For discontinuous motion (i.e. teleport), use TeleportTo(IAttachmentPointManager, Vector3, IAttachmentPoint) . This is equivalent to MoveAttachmentPoint(IAttachmentPoint, Vector3) TeleportTo(IAttachmentPointManager, Vector3, IAttachmentPoint) Notify attachment point that it has teleported to a new position. Declaration void TeleportTo(IAttachmentPointManager manager, Vector3 newFrozenPosition, IAttachmentPoint context) Parameters Type Name Description IAttachmentPointManager manager The manager Vector3 newFrozenPosition The new position IAttachmentPoint context The context into which to teleport. Can be null. CreateAttachmentPoint(Vector3, IAttachmentPoint, AdjustLocationDelegate, AdjustStateDelegate) Remarks This should be used for discontinuous movement, i.e. teleporting. For continuous motion, use MoveTo(IAttachmentPointManager, Vector3) . This is equivalent to TeleportAttachmentPoint(IAttachmentPoint, Vector3, IAttachmentPoint)"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAttachmentPointManager.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAttachmentPointManager.html",
    "title": "Interface IAttachmentPointManager | World Locking Tools for Unity Documentation",
    "keywords": "Interface IAttachmentPointManager Interface for application creation and manipulation of attachment points. In particular, the creation and release of attachment points must be conducted through the IAttachmentPointManager. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IAttachmentPointManager Remarks Obtain access to the attachment point manager through the WorldLockingManager. Methods CreateAttachmentPoint(Vector3, IAttachmentPoint, AdjustLocationDelegate, AdjustStateDelegate) Create and register a new attachment point. Declaration IAttachmentPoint CreateAttachmentPoint(Vector3 frozenPosition, IAttachmentPoint context, AdjustLocationDelegate locationHandler, AdjustStateDelegate stateHandler) Parameters Type Name Description Vector3 frozenPosition The position in the frozen space at which to start the attachment point IAttachmentPoint context The optional context into which to create the attachment point (may be null) AdjustLocationDelegate locationHandler Delegate to handle Frozen World engine system adjustments to position AdjustStateDelegate stateHandler Delegate to handle Frozen World engine connectivity changes Returns Type Description IAttachmentPoint The new attachment point interface. Remarks The attachment point itself is a fairly opaque handle. Its effects are propagated to the client via the two handlers associated with it. The context interface is optional. It should be given if the new attachment point is conceptually spawned from an existing attachment point (or its target object). If null, then conceptually the new attachment point was spawned from the current camera. The attachment point itself is a fairly opaque handle. The actual adjustments are made via notifications through the two delegates passed into the creation. The locationHandler is strictly to notify of adjustments when refitting (Merge or Refreeze). The stateHandler notifies whether this attachment point is \"connected\" with the current fragment. Both handlers are optional and may be null. MoveAttachmentPoint(IAttachmentPoint, Vector3) Move (as opposed to Teleport) means that the object is meant to have traversed frozen space from its old position to the given new position on some continuous path. Declaration void MoveAttachmentPoint(IAttachmentPoint attachPointIface, Vector3 newFrozenPosition) Parameters Type Name Description IAttachmentPoint attachPointIface Vector3 newFrozenPosition The new position in frozen space Remarks Not to be used for automatic (i.e. FrozenWorld Engine instigated) moves. Use this for continuous movement through space. For discontinuous movement (i.e. teleportation), use TeleportAttachmentPoint(IAttachmentPoint, Vector3, IAttachmentPoint) ReleaseAttachmentPoint(IAttachmentPoint) Release an attachment point for disposal. The attachment point is no longer valid after this call. This also un-registers the handlers (if any) given when it was created. Declaration void ReleaseAttachmentPoint(IAttachmentPoint attachPointIface) Parameters Type Name Description IAttachmentPoint attachPointIface The attachment point to release. Remarks In the unlikely circumstance that another attachment point has been spawned from this one but has not yet been processed (is still in the pending queue), that relationship is broken on release of this one, and when the other attachment point is finally processed, it will be as if it was created with a null context. TeleportAttachmentPoint(IAttachmentPoint, Vector3, IAttachmentPoint) Teleport (as opposed to Move) means that the object is meant to have disappeared at its old position and instantaneously reappeared at its new position in frozen space without traversing the space in between. Declaration void TeleportAttachmentPoint(IAttachmentPoint attachPointIface, Vector3 newFrozenPosition, IAttachmentPoint context) Parameters Type Name Description IAttachmentPoint attachPointIface The attachment point to teleport Vector3 newFrozenPosition The position to teleport to. IAttachmentPoint context The optional context. Remarks Use this for discontinuous movement through space (i.e. teleportation). For continuous movement, use MoveAttachmentPoint(IAttachmentPoint, Vector3) . This is equivalent to releasing the attachment point ( ReleaseAttachmentPoint(IAttachmentPoint) ) and creating it ( CreateAttachmentPoint(Vector3, IAttachmentPoint, AdjustLocationDelegate, AdjustStateDelegate) ) at the new location in the given context, except that using Teleport allows the reference to the existing attachment point to remains valid."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IFragmentManager.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IFragmentManager.html",
    "title": "Interface IFragmentManager | World Locking Tools for Unity Documentation",
    "keywords": "Interface IFragmentManager Interface for managing fragments. This mostly comprises the bookkeeping of managing IAttachmentPoint associations, and the intimately related application of refit operations. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IFragmentManager Properties CurrentFragmentId Get id of currently active fragment Declaration FragmentId CurrentFragmentId { get; } Property Value Type Description FragmentId FragmentIds Return a copy of the current list of fragment ids. Declaration FragmentId[] FragmentIds { get; } Property Value Type Description FragmentId [] NumFragments Current number of fragments. Declaration int NumFragments { get; } Property Value Type Description Int32 Methods ApplyActiveCurrentFragment() Notify all fragments of their current state. Declaration void ApplyActiveCurrentFragment() GetFragmentState(FragmentId) Get the current state of a given fragment. Declaration AttachmentPointStateType GetFragmentState(FragmentId id) Parameters Type Name Description FragmentId id Identifier of the fragment to query. Returns Type Description AttachmentPointStateType The state Merge() Call on the plugin to compute the merge, then apply by setting transforms and adjusting scene graph. Declaration bool Merge() Returns Type Description Boolean True for successful merge. Remarks It is unnecessary to manually merge if autoMerge is true with Update() Pause() Set all fragments unconnected during a temporary system outage, especially while tracking is lost. Declaration void Pause() Remarks Fragments to resume as they were on next update. Pause may be called multiple consecutive frames, as long as the system outage continues, but only Pause or Update should be called on a given frame. Refreeze() Manually invoke a refreeze operation on the plugin, and make all necessary adjustments in bookkeeping after. Declaration bool Refreeze() Returns Type Description Boolean True for successful refreeze. Remarks It is unnecessary to manually refreeze if autoRefreeze is true with Update() RegisterForRefitNotifications(RefitNotificationDelegate) Register a delegate for refit notifications. Declaration void RegisterForRefitNotifications(RefitNotificationDelegate del) Parameters Type Name Description RefitNotificationDelegate del The delegate to call. Reset() Clear all internal state and resources. Declaration void Reset() UnregisterForRefitNotifications(RefitNotificationDelegate) Unregister a previously registered delegate for refit notifications. Declaration void UnregisterForRefitNotifications(RefitNotificationDelegate del) Parameters Type Name Description RefitNotificationDelegate del The delegate to unregister. Update(Boolean, Boolean) Perform any pending refit operations and reconcile state accordingly. Declaration void Update(bool autoRefreeze, bool autoMerge) Parameters Type Name Description Boolean autoRefreeze True to automatically perform a refreeze if indicated by the plugin. Boolean autoMerge True to automatically perform a merge if indicated by the plugin."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IHeadPoseTracker.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IHeadPoseTracker.html",
    "title": "Interface IHeadPoseTracker | World Locking Tools for Unity Documentation",
    "keywords": "Interface IHeadPoseTracker Interface for retrieving the current head pose. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IHeadPoseTracker Methods GetHeadPose() Return the current head pose in Spongy (local) space. Declaration Pose GetHeadPose() Returns Type Description Pose The current head pose. Reset() Reset is called whenever there is a conceptual restart. Any cached information should be discarded and re-evaluated. Declaration void Reset()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IOrientable.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IOrientable.html",
    "title": "Interface IOrientable | World Locking Tools for Unity Documentation",
    "keywords": "Interface IOrientable Base class for a thing whose orientation can be inferred from the positions of a collection of IOrientables. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IOrientable Properties FragmentId What fragment the object belongs in. Objects in different fragments don't affect each other. Declaration FragmentId FragmentId { get; } Property Value Type Description FragmentId LockedPosition The desired position of the object in world locked space. Declaration Vector3 LockedPosition { get; } Property Value Type Description Vector3 LockedRotation The desired rotation of the object in world locked space. Declaration Quaternion LockedRotation { get; } Property Value Type Description Quaternion ModelPosition The position of the object in Modeling space. Declaration Vector3 ModelPosition { get; } Property Value Type Description Vector3 ModelRotation The orientation of the object in Modeling space. Declaration Quaternion ModelRotation { get; } Property Value Type Description Quaternion Methods PushRotation(IAlignmentManager, Quaternion) Accept a rotation computed externally (by an IOrienter ). Declaration void PushRotation(IAlignmentManager mgr, Quaternion lockedRotation) Parameters Type Name Description IAlignmentManager mgr The Alignment Manager in charge. Quaternion lockedRotation The rotation to apply, in world locked space."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IOrienter.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IOrienter.html",
    "title": "Interface IOrienter | World Locking Tools for Unity Documentation",
    "keywords": "Interface IOrienter An object capable of computing self-consistent rotations for IOrientables based on their positions. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IOrienter Properties AlignmentManager Optional subtree alignment manager. Declaration IAlignmentManager AlignmentManager { get; set; } Property Value Type Description IAlignmentManager Remarks If unset, will use global alignment manager, ie WorldLockingManager.GetInstance().AlignmentManager. Methods Register(IOrientable) Add this orientable to the list to be both source of rotation computation, and targets to apply the computed rotation. Declaration void Register(IOrientable orientable) Parameters Type Name Description IOrientable orientable The object to start maintining the orientation of. Reorient(FragmentId, IAlignmentManager) Compute a consistent orientation for all registered IOrientables in the given fragment. Declaration void Reorient(FragmentId fragmentId, IAlignmentManager mgr) Parameters Type Name Description FragmentId fragmentId The fragment to selectively apply to. IAlignmentManager mgr The manager governing the process. Unregister(IOrientable) Stop managing orientation for this object, and release all references to it. Declaration void Unregister(IOrientable orientable) Parameters Type Name Description IOrientable orientable The object to forget."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.LinkageSettings.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.LinkageSettings.html",
    "title": "Struct LinkageSettings | World Locking Tools for Unity Documentation",
    "keywords": "Struct LinkageSettings Explicitly set required Transform objects. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax [Serializable] public struct LinkageSettings Remarks If Use Existing is not set, then null Transform objects will override the currently set Transforms. When one of the Transform objects is set to null, the system attempts to infer a reasonable choice. For complicated scenes, this inference may be incorrect. For non-trivial scenes: ** If the camera rig is loaded per scene, then a Linkage Setting (via WorldLockingContext) should be set per scene explicitly pointing into that scene's camera hierarchy. ** If the camera rig is loaded once in a shared scene, the Linkage Setting should be in that scene only, and all other Linkage Settings should set \"Use Existing\" to true. ** If the camera rig is created/managed dynamically from script, then that script should also be responsible for setting the appropriate linkages, and all LinkageSettings should specify \"Use Existing\". Fields AdjustmentFrame The transform at which to apply the camera adjustment. This can't be the camera node, as its transform is overwritten every frame with head pose data. But the camera should be an attached descendant of this node. Declaration public Transform AdjustmentFrame Field Value Type Description Transform CameraParent The camera parent node defines the \"spongy frame of reference\". All raw head based data, such as the spatial mapping, gesture events, and XR head pose data, are relative to this transform. Declaration public Transform CameraParent Field Value Type Description Transform NoPitchAndRoll Zero out pitch and roll from the FrozenWorldEngine correction. Declaration public bool NoPitchAndRoll Field Value Type Description Boolean Properties ApplyAdjustment Apply world locking adjustment to the AdjustmentFrame. Declaration public bool ApplyAdjustment { get; set; } Property Value Type Description Boolean Remarks If this is false, then it is up to the application to apply the correction. This allows the correction to be applied selectively to subsets of the scene hierarchy. UseExisting Ignore set values keep existing linkage, and use whatever was set last. Declaration public bool UseExisting { get; set; } Property Value Type Description Boolean Methods InitToDefaults() Init all fields to default values. Declaration public void InitToDefaults()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ManagerSettings.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ManagerSettings.html",
    "title": "Struct ManagerSettings | World Locking Tools for Unity Documentation",
    "keywords": "Struct ManagerSettings Manager settings. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax [Serializable] public struct ManagerSettings Fields AutoLoad Automatically load the WorldLocking state from disk from previous run at startup. Declaration public bool AutoLoad Field Value Type Description Boolean AutoMerge Automatically trigger a fragment merge whenever the FrozenWorld engine indicates that one would be appropriate. Declaration public bool AutoMerge Field Value Type Description Boolean AutoRefreeze Automatically trigger a refreeze whenever the FrozenWorld engine indicates that one would be appropriate. Declaration public bool AutoRefreeze Field Value Type Description Boolean AutoSave Periodically save the WorldLocking state to disk. Declaration public bool AutoSave Field Value Type Description Boolean Enabled Whether the WorldLocking stabilization is active or bypassed (if not Enabled). Declaration public bool Enabled Field Value Type Description Boolean Properties UseDefaults Ignore set values and use default behavior. When set, will reset all values to defaults. Declaration public bool UseDefaults { get; set; } Property Value Type Description Boolean Methods InitToDefaults() Put this into default initialized state. Declaration public ManagerSettings InitToDefaults() Returns Type Description ManagerSettings This initialized to defaults."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Orienter.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Orienter.html",
    "title": "Class Orienter | World Locking Tools for Unity Documentation",
    "keywords": "Class Orienter The Orienter class implements IOrienter. Inheritance Object Orienter OrienterThreeBody Implements IOrienter Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class Orienter : MonoBehaviour, IOrienter Remarks It derives from MonoBehaviour only to facilitate assigning it in the Inspector. Alternatively, it could be implemented as a singleton service. There are pros and cons in either direction. The MonoBehaviour assigned in inspector was chosen to make explicit the dependency, rather than a dependency hidden by a static get internally. Fields actives Orientables in the currently processing fragment. Declaration protected readonly List<Orienter.WeightedRotation> actives Field Value Type Description List < Orienter.WeightedRotation > Properties AlignmentManager Declaration public IAlignmentManager AlignmentManager { get; set; } Property Value Type Description IAlignmentManager Methods AverageRotation(Orienter.WeightedRotation, Orienter.WeightedRotation) Compute a new weighted rotation representing the two input weighted rotations. Declaration protected Orienter.WeightedRotation AverageRotation(Orienter.WeightedRotation accum, Orienter.WeightedRotation add) Parameters Type Name Description Orienter.WeightedRotation accum The accumulator rotation. Orienter.WeightedRotation add The rotation to add in. Returns Type Description Orienter.WeightedRotation A new aggregate weighted rotation. ComputeRotation(IOrientable, IOrientable) Compute the rotation that aligns a and b correctly in pinned space. Declaration protected virtual Orienter.WeightedRotation ComputeRotation(IOrientable a, IOrientable b) Parameters Type Name Description IOrientable a IOrientable b Returns Type Description Orienter.WeightedRotation ComputeRotations() Compute rotations by pairs, weighting by distance and averaging for each orientable. Declaration protected virtual bool ComputeRotations() Returns Type Description Boolean Register(IOrientable) Declaration public void Register(IOrientable orientable) Parameters Type Name Description IOrientable orientable Reorient(FragmentId, IAlignmentManager) Declaration public void Reorient(FragmentId fragmentId, IAlignmentManager mgr) Parameters Type Name Description FragmentId fragmentId IAlignmentManager mgr Unregister(IOrientable) Declaration public void Unregister(IOrientable orientable) Parameters Type Name Description IOrientable orientable Implements IOrienter"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Orienter.WeightedRotation.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Orienter.WeightedRotation.html",
    "title": "Struct Orienter.WeightedRotation | World Locking Tools for Unity Documentation",
    "keywords": "Struct Orienter.WeightedRotation An object whose rotation needs to be computed, and the weight of its rotation. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax protected struct WeightedRotation Fields orientable Declaration public IOrientable orientable Field Value Type Description IOrientable rotation Declaration public Quaternion rotation Field Value Type Description Quaternion weight Declaration public float weight Field Value Type Description Single Properties FragmentId Declaration public readonly FragmentId FragmentId { get; } Property Value Type Description FragmentId"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.OrienterThreeBody.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.OrienterThreeBody.html",
    "title": "Class OrienterThreeBody | World Locking Tools for Unity Documentation",
    "keywords": "Class OrienterThreeBody Derived class which supports computing implicit rotations in full 3-DOF (6-DOF w/ position). Inheritance Object Orienter OrienterThreeBody Implements IOrienter Inherited Members Orienter.actives Orienter.AlignmentManager Orienter.Register(IOrientable) Orienter.Unregister(IOrientable) Orienter.Reorient(FragmentId, IAlignmentManager) Orienter.AverageRotation(Orienter.WeightedRotation, Orienter.WeightedRotation) Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class OrienterThreeBody : Orienter, IOrienter Remarks Whereas the base Orienter class uses the simplifying assumption of only adjusting yaw, that is rotation about the gravity vector Y-axis, the OrienterThreeBody computes an arbitrary 3-DOF rotation to align modeling space with the supplied physical reference points. Since at least three non-collinear points are necessary to compute such a rotation, until they are available, it falls back on a simplified computation. To summarize: Zero points - identity transform One point - position alignment only (identity rotation) All points collinear - yaw and pitch about the line, but no roll about the line. Non-collinear - 3-DOF alignment. Methods ComputeRotation(IOrientable, IOrientable) Compute yaw and pitch to align virtual line with physical. Declaration protected override Orienter.WeightedRotation ComputeRotation(IOrientable a, IOrientable b) Parameters Type Name Description IOrientable a First point IOrientable b Second point Returns Type Description Orienter.WeightedRotation Computed rotation weighted by inverse distance between points. Overrides Orienter.ComputeRotation(IOrientable, IOrientable) ComputeRotations() Override to compute rotations unconstrained as a rotation about the gravity vector, Y-axis. Declaration protected override bool ComputeRotations() Returns Type Description Boolean True on success. Overrides Orienter.ComputeRotations() Remarks It takes at least 3 non-collinear points to imply a rotation. If there are fewer than that, this reverts back to the behavior of computing a rotation which pitches to align points but doesn't introduce roll. Implements IOrienter"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.PoseExtensions.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.PoseExtensions.html",
    "title": "Class PoseExtensions | World Locking Tools for Unity Documentation",
    "keywords": "Class PoseExtensions Extensions for Poses to enable basic transform math. Inheritance Object PoseExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public static class PoseExtensions Methods Inverse(Pose) Declaration public static Pose Inverse(this Pose t) Parameters Type Name Description Pose t Returns Type Description Pose Multiply(Pose, Pose) Declaration public static Pose Multiply(this Pose lhs, Pose rhs) Parameters Type Name Description Pose lhs Pose rhs Returns Type Description Pose Multiply(Pose, Vector3) Declaration public static Vector3 Multiply(this Pose pose, Vector3 position) Parameters Type Name Description Pose pose Vector3 position Returns Type Description Vector3"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.PostAlignmentLoadedDelegate.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.PostAlignmentLoadedDelegate.html",
    "title": "Delegate PostAlignmentLoadedDelegate | World Locking Tools for Unity Documentation",
    "keywords": "Delegate PostAlignmentLoadedDelegate Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate void PostAlignmentLoadedDelegate();"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.RefitNotificationDelegate.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.RefitNotificationDelegate.html",
    "title": "Delegate RefitNotificationDelegate | World Locking Tools for Unity Documentation",
    "keywords": "Delegate RefitNotificationDelegate Delegate type for notification of refit operations. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate void RefitNotificationDelegate(FragmentId mergedId, FragmentId[] absorbedIds); Parameters Type Name Description FragmentId mergedId The fragment id of the target merged fragment. FragmentId [] absorbedIds Fragment ids of all affected fragments. Remarks In the case of a merge operation, absorbedIds will contain all and only the ids of the fragments that were merged into mergedId, but not including mergedId. In the case of a refreeze operation, absorbedIds will also contain mergedId."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.CompareToResource-2.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.CompareToResource-2.html",
    "title": "Delegate ResourceMirror.CompareToResource<ItemType, ResourceType> | World Locking Tools for Unity Documentation",
    "keywords": "Delegate ResourceMirror.CompareToResource<ItemType, ResourceType> Function to compare a source item with a resource. It should return: -1 if resource is associated with a smaller item than item. 1 if resource is associated with a larger item than item. 0 if resource is associated with item. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate int CompareToResource<ItemType, ResourceType>(ItemType item, ResourceType resource); Parameters Type Name Description ItemType item Instance of source data. ResourceType resource Instance of resource. Returns Type Description Int32 Type Parameters Name Description ItemType Type of source data. ResourceType Type of managed resource. Remarks Note that \"smaller\" and \"larger\" above must have the identical meaning to the comparison the lists input into Sync are sorted by."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.CreateResource-2.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.CreateResource-2.html",
    "title": "Delegate ResourceMirror.CreateResource<ItemType, ResourceType> | World Locking Tools for Unity Documentation",
    "keywords": "Delegate ResourceMirror.CreateResource<ItemType, ResourceType> Callback for creating a new instance of a resource matching a specific item. This will be called for each item in Sync's currentItems list which doesn't have a matching resource in Sync's resources list. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate bool CreateResource<ItemType, ResourceType>(ItemType item, out ResourceType resource); Parameters Type Name Description ItemType item The source item to create a new resource for. ResourceType resource out param for created resource. Returns Type Description Boolean Returns true if a resource was created successfully. Type Parameters Name Description ItemType Type of the source data. ResourceType Type of the resources to be managed. Remarks Note that it is not an error to return false, it only means that for any reason the resource was not created. However, if the resource is not created, then in the next call to Sync, it will be noted that the item doesn't have a matching resource and the create call will be made again. To prevent fruitless and possibly expensive create calls, the offending item should be removed from the items list passed into Sync. As noted below, all additions and removals from the items list must happen outside the Sync call."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.DestroyResource-1.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.DestroyResource-1.html",
    "title": "Delegate ResourceMirror.DestroyResource<ResourceType> | World Locking Tools for Unity Documentation",
    "keywords": "Delegate ResourceMirror.DestroyResource<ResourceType> Callback to release resources. This will be called for each resource in Sync's resource list for which there is no corresponding source data in Sync's currentItems. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate void DestroyResource<ResourceType>(ResourceType resource); Parameters Type Name Description ResourceType resource The resource instance to destroy. Type Parameters Name Description ResourceType Type of the resource to destroy."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.html",
    "title": "Class ResourceMirror | World Locking Tools for Unity Documentation",
    "keywords": "Class ResourceMirror Class to synchronize a list of resources with associated source data (items). Inheritance Object ResourceMirror Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class ResourceMirror Methods Sync<ItemType, ResourceType>(IReadOnlyList<ItemType>, List<ResourceType>, ResourceMirror.CompareToResource<ItemType, ResourceType>, ResourceMirror.CreateResource<ItemType, ResourceType>, ResourceMirror.UpdateResource<ItemType, ResourceType>, ResourceMirror.DestroyResource<ResourceType>) Given a sorted list of source data items (currentItems), and a sorted list of resources: For each source item that doesn't have a matching resource, attempt to create a resource. For each resource that doesn't have a matching source item, destroy that resource. For each source item with a matching resource, update the resource. Declaration public static void Sync<ItemType, ResourceType>(IReadOnlyList<ItemType> currentItems, List<ResourceType> resources, ResourceMirror.CompareToResource<ItemType, ResourceType> compareIds, ResourceMirror.CreateResource<ItemType, ResourceType> creator, ResourceMirror.UpdateResource<ItemType, ResourceType> updater, ResourceMirror.DestroyResource<ResourceType> destroyer) Parameters Type Name Description IReadOnlyList <ItemType> currentItems List of current source items. List <ResourceType> resources List of resources to by synced to currentItems. ResourceMirror.CompareToResource <ItemType, ResourceType> compareIds Function to compare an item with a resource. See above. ResourceMirror.CreateResource <ItemType, ResourceType> creator Callback to create a missing resource. See above. ResourceMirror.UpdateResource <ItemType, ResourceType> updater Callback to update an existing resource. See above. ResourceMirror.DestroyResource <ResourceType> destroyer Callback to destroy a resource which no longer has a matching source item. Type Parameters Name Description ItemType Type of source items. ResourceType Type of resources. Remarks After this Sync, the list of resources will have exactly one resource for each item in currentItems, and currentItems and resources will be the same length. The exception is if the creator function returns false for any item(s), then those item(s) will not have matching resources, and resources will be shorter than currentItems. In any case, resources will remain sorted. Sync completes in a single pass over the data, so in O(max(currentItems.Count, resources.Count)) time."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.UpdateResource-2.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.UpdateResource-2.html",
    "title": "Delegate ResourceMirror.UpdateResource<ItemType, ResourceType> | World Locking Tools for Unity Documentation",
    "keywords": "Delegate ResourceMirror.UpdateResource<ItemType, ResourceType> Callback to update existing resources. This will be called for each item and its associated resource in the Sync's currentItems and resources lists. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate void UpdateResource<ItemType, ResourceType>(ItemType item, ResourceType resource); Parameters Type Name Description ItemType item The source item. ResourceType resource The associated resource. Type Parameters Name Description ItemType Type of the source data. ResourceType Type of the managed resources. Remarks Only one of create/update/destroy will be called for a given item/resource pair during a single Sync."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirrorHelper.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirrorHelper.html",
    "title": "Namespace Microsoft.MixedReality.WorldLocking.Core.ResourceMirrorHelper | World Locking Tools for Unity Documentation",
    "keywords": "Namespace Microsoft.MixedReality.WorldLocking.Core.ResourceMirrorHelper Structs IdPair<IdType, T> Helper pair for keeping track of things by ID."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirrorHelper.IdPair-2.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirrorHelper.IdPair-2.html",
    "title": "Struct IdPair<IdType, T> | World Locking Tools for Unity Documentation",
    "keywords": "Struct IdPair<IdType, T> Helper pair for keeping track of things by ID. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core.ResourceMirrorHelper Assembly : cs.temp.dll.dll Syntax public struct IdPair<IdType, T> Type Parameters Name Description IdType Type of the identifier. T Type of the data associated with the identifier. Remarks The IdType is typically an AnchorId, but any type using the Comparer.Default.Compare is fine. Note this is independent of the ResourceMirror, and currently only used to internally for resources identified by anchorId, and to expedite tests. Fields id Identifier field. Declaration public IdType id Field Value Type Description IdType target Data associated with identifier. Declaration public T target Field Value Type Description T Methods CompareById(IdPair<IdType, T>, IdPair<IdType, T>) Convenience comparison function comparing by identifier (ignoring associated data). Declaration public static int CompareById(IdPair<IdType, T> lhs, IdPair<IdType, T> rhs) Parameters Type Name Description IdPair <IdType, T> lhs The left hand side. IdPair <IdType, T> rhs The right hand side. Returns Type Description Int32 If lhs GT rhs then -1 else if lhs LT rhs then 1 else 0"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SharedDiagnosticsSettings.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SharedDiagnosticsSettings.html",
    "title": "Class SharedDiagnosticsSettings | World Locking Tools for Unity Documentation",
    "keywords": "Class SharedDiagnosticsSettings The SharedSettings boxes the Settings into a sharable reference. Inheritance Object SharedDiagnosticsSettings Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax [Serializable] public class SharedDiagnosticsSettings Constructors SharedDiagnosticsSettings() Declaration public SharedDiagnosticsSettings() Fields settings Declaration public DiagnosticsSettings settings Field Value Type Description DiagnosticsSettings"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SharedManagerSettings.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SharedManagerSettings.html",
    "title": "Class SharedManagerSettings | World Locking Tools for Unity Documentation",
    "keywords": "Class SharedManagerSettings Shareable (reference type) version of Settings (value struct). Inheritance Object SharedManagerSettings Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax [Serializable] public class SharedManagerSettings Constructors SharedManagerSettings() Wrap a copy of settings initialized to default values. Declaration public SharedManagerSettings() Fields anchorSettings Anchor management settings. Declaration public AnchorSettings anchorSettings Field Value Type Description AnchorSettings linkageSettings Transform links to be shared. Declaration public LinkageSettings linkageSettings Field Value Type Description LinkageSettings settings The manager settings to be shared. Declaration public ManagerSettings settings Field Value Type Description ManagerSettings"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpacePin.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpacePin.html",
    "title": "Class SpacePin | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePin Component helper for pinning the world locked space at a single reference point. Inheritance Object SpacePin SpacePinOrientable Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class SpacePin : MonoBehaviour Remarks This component captures the initial pose of its gameObject, and then a second pose. It then adds that pair to the WorldLocking Alignment Manager. The manager then negotiates between all such added pins, based on the current head pose, to generate a frame-to-frame mapping aligning the Frozen Space, i.e. Unity's Global Space, such that the pins match up as well as possible. Another way to phrase this is: Given an arbitrary pose (the \"modeling pose\"), and a pose aligned somehow to the real world (the \"world locked pose\"), apply a correction to the camera such that a virtual object with coordinates of the modeling pose will appear overlaid on the real world at the position and orientation described by the locked pose. For this component, the locked pose must come in via one of the following three APIs: SetFrozenPose(Pose) with input pose in Frozen Space, which includes pinning. SetSpongyPose(Pose) with input pose in Spongy Space, which is the space of the camera's parent, and is the same space the camera moves in, and that native APIs return values in (e.g. XR). SetLockedPose(Pose) with input pose in Locked Space, which is the space stabilized by the Frozen World engine DLL but excluding pinning. Note that since the Frozen Space is shifted by the AlignmentManager, calling SetFrozenPose(p) with the same Pose p twice is probably an error, since the Pose p would refer to different a location after the first call. Properties AlignmentManager Accessor for overriding the AlignmentManager from script. Declaration public IAlignmentManager AlignmentManager { get; set; } Property Value Type Description IAlignmentManager AnchorId This wrapper for the anchorId is because the anchorId has to be stored as a ulong, which is the base class for the AnchorId enum. Unity only supports int-based enums, so will complain on serialization etc. for the ulong based AnchorId. Declaration public AnchorId AnchorId { get; } Property Value Type Description AnchorId AnchorName Provide a unique anchor name. This is used for persistence. Declaration protected virtual string AnchorName { get; } Property Value Type Description String FragmentId Id for fragment this pin belongs in. Declaration public FragmentId FragmentId { get; } Property Value Type Description FragmentId GlobalFromParent Return the Pose transforming from parent space to global space. Declaration protected Pose GlobalFromParent { get; } Property Value Type Description Pose Remarks If the SpacePin has no parent, this will be the identity Pose. LockedPose Accessor for world locked pose for derived classes. Declaration public Pose LockedPose { get; protected set; } Property Value Type Description Pose Manager Read only access to manager dependency from derived classes. Declaration protected WorldLockingManager Manager { get; } Property Value Type Description WorldLockingManager ModelingPoseGlobal First of the pair of poses submitted to alignment manager for alignment. Declaration public Pose ModelingPoseGlobal { get; } Property Value Type Description Pose ModelPositionSource Where to find model space position on target. Transform is preferable, but if transforms are baked in, renderer or collider may be more appropriate. Declaration public SpacePin.ModelPositionSourceEnum ModelPositionSource { get; set; } Property Value Type Description SpacePin.ModelPositionSourceEnum Remarks Note that orientation always comes from transform, as renderer and collider bounds have no orientation. ParentFromGlobal Return the Pose transforming from global space to the parent's space. Declaration protected Pose ParentFromGlobal { get; } Property Value Type Description Pose PinActive Whether this space pin is in active use pinning space Declaration public bool PinActive { get; } Property Value Type Description Boolean RestorePoseLocal Pose to restore after manipulation (if any). Declaration protected Pose RestorePoseLocal { get; } Property Value Type Description Pose Methods ExtractModelPose() Declaration protected Pose ExtractModelPose() Returns Type Description Pose ExtractModelPoseFromCollider() Declaration protected Pose ExtractModelPoseFromCollider() Returns Type Description Pose ExtractModelPoseFromRenderer() Declaration protected Pose ExtractModelPoseFromRenderer() Returns Type Description Pose ExtractModelPoseFromTransform() Declaration protected Pose ExtractModelPoseFromTransform() Returns Type Description Pose ForceAttachment() Ensure that there is an attachment, and it is positioned up to date. Declaration protected void ForceAttachment() GetModelPoseFromGlobalPosition(Vector3) Declaration protected Pose GetModelPoseFromGlobalPosition(Vector3 globalPosition) Parameters Type Name Description Vector3 globalPosition Returns Type Description Pose OnDestroy() On destroy, unregister for the loaded event. Declaration protected virtual void OnDestroy() OnLocationUpdate(Pose) Callback for refit operations. Apply adjustment transform to locked pose. Declaration protected virtual void OnLocationUpdate(Pose adjustment) Parameters Type Name Description Pose adjustment Adjustment to apply. PushAlignmentData(IAlignmentManager) Communicate the data from this point to the alignment manager. Declaration protected void PushAlignmentData(IAlignmentManager mgr) Parameters Type Name Description IAlignmentManager mgr ReleaseAttachment() Dispose of any previously created attachment point. Declaration protected void ReleaseAttachment() Reset() Go back to initial state, including removal of self-artifacts from alignment manager. Declaration public virtual void Reset() ResetModelingPose() Reset the modeling pose to the current transform. Declaration public virtual void ResetModelingPose() Remarks In normal usage, the modeling pose is the transform as set in Unity and as cached at start. In some circumstances, such as creation of pins from script, it may be convenient to set the transform after Start(). In this case, the change of transform should be recorded by a call to ResetModelingPose(). This must happen before the modeling pose is used implicitly by a call to set the virtual pose, via SetFrozenPose, SetSpongyPose, or SetLockedPose. RestoreOnLoad() Callback on notification of the alignment manager's database to check if this preset has been persisted, and restore it to operation if it has. Declaration protected virtual void RestoreOnLoad() SendAlignmentData(IAlignmentManager) Notify the manager that all necessary updates have been submitted and are ready for processing. Declaration protected void SendAlignmentData(IAlignmentManager mgr) Parameters Type Name Description IAlignmentManager mgr SetFrozenPose(Pose) Transform pose to Locked Space and pass through. Declaration public void SetFrozenPose(Pose frozenPose) Parameters Type Name Description Pose frozenPose Pose in frozen space. SetLockedPose(Pose) Record the locked pose and push data to the manager. Declaration public virtual void SetLockedPose(Pose lockedPose) Parameters Type Name Description Pose lockedPose SetSpongyPose(Pose) Transform pose to Locked Space and pass through. Declaration public void SetSpongyPose(Pose spongyPose) Parameters Type Name Description Pose spongyPose Pose in spongy space. Start() Declaration protected virtual void Start()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpacePin.ModelPositionSourceEnum.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpacePin.ModelPositionSourceEnum.html",
    "title": "Enum SpacePin.ModelPositionSourceEnum | World Locking Tools for Unity Documentation",
    "keywords": "Enum SpacePin.ModelPositionSourceEnum Choice of what to use for modeling position. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public enum ModelPositionSourceEnum Remarks In general, the transform's global position is the preferred source of the model position. However, there are times when that is not practical. Specifically, if the model's transform has been \"baked\" into the model's vertices, leaving an identity transform, then while the transform's position is no longer meaningful, the renderer's world-space bounds and/or the collider's world-space bounds may still have a useful reference position. Also, it is very easy to offset the collider's bounds, when it might be more cumbersome to modify either the transform position or the renderer's bounds. Note that orientation always comes from transform, as renderer and collider bounds have no orientation. Fields Name Description ColliderBounds RendererBounds Transform"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpacePinOrientable.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpacePinOrientable.html",
    "title": "Class SpacePinOrientable | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePinOrientable A component derived from SpacePin which differs only in that, rather than using an explicit rotation passed in, an implicit rotation is calculated based on the relative positions of all active SpacePinOrientable s. Inheritance Object SpacePin SpacePinOrientable Implements IOrientable Inherited Members SpacePin.ModelPositionSource SpacePin.Manager SpacePin.AlignmentManager SpacePin.AnchorId SpacePin.AnchorName SpacePin.PinActive SpacePin.RestorePoseLocal SpacePin.ModelingPoseGlobal SpacePin.LockedPose SpacePin.GlobalFromParent SpacePin.ParentFromGlobal SpacePin.OnDestroy() SpacePin.SetFrozenPose(Pose) SpacePin.SetSpongyPose(Pose) SpacePin.ResetModelingPose() SpacePin.ExtractModelPose() SpacePin.ExtractModelPoseFromTransform() SpacePin.GetModelPoseFromGlobalPosition(Vector3) SpacePin.ExtractModelPoseFromRenderer() SpacePin.ExtractModelPoseFromCollider() SpacePin.ForceAttachment() SpacePin.ReleaseAttachment() SpacePin.PushAlignmentData(IAlignmentManager) SpacePin.SendAlignmentData(IAlignmentManager) Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class SpacePinOrientable : SpacePin, IOrientable Remarks The implementation of IOrientable allows it to provide an input position and receive an output rotation from the managing IOrienter . Properties FragmentId The fragment this belongs to. Public property to satisfy IOrientable interface. Declaration public FragmentId FragmentId { get; } Property Value Type Description FragmentId Remarks Only elements within the same fragment are allowed to interact with each other, because by definition the relationship between coordinates of elements of differing fragments are undefined. LockedPosition Declaration public Vector3 LockedPosition { get; } Property Value Type Description Vector3 LockedRotation Declaration public Quaternion LockedRotation { get; } Property Value Type Description Quaternion ModelPosition Declaration public Vector3 ModelPosition { get; } Property Value Type Description Vector3 ModelRotation Declaration public Quaternion ModelRotation { get; } Property Value Type Description Quaternion Orienter Input dependency of the managing Orienter which will arbitrate individual rotations. Declaration public IOrienter Orienter { get; set; } Property Value Type Description IOrienter Remarks Access to the orienter is strictly by interface IOrienter. The type of the orienter member is Orienter to allow it to be set explicitly in the Inspector (see notes in Orienter ), but any object implementing IOrienter can be used by explicit setting through SetOrienter(IOrienter) . Methods OnLocationUpdate(Pose) Callback for refit operations. Declaration protected override void OnLocationUpdate(Pose adjustment) Parameters Type Name Description Pose adjustment Adjustment transform to apply. Overrides SpacePin.OnLocationUpdate(Pose) Remarks Note that the FragmentId may change here. PushRotation(IAlignmentManager, Quaternion) Accept the rotation as computed by the IOrienter. Declaration public void PushRotation(IAlignmentManager mgr, Quaternion lockedRotation) Parameters Type Name Description IAlignmentManager mgr The alignment manager which needs to receive the updated Pose. Quaternion lockedRotation The new world locked rotation to adopt. Reset() Reset and unregister from the IOrienter. Declaration public override void Reset() Overrides SpacePin.Reset() RestoreOnLoad() If base restore on load succeeds, register with orienter for further manipulation. Declaration protected override void RestoreOnLoad() Overrides SpacePin.RestoreOnLoad() SetFrozenPosition(Vector3) Set the position in frozen space. Rotation not needed since it is computed based on relative positions. Declaration public void SetFrozenPosition(Vector3 frozenPosition) Parameters Type Name Description Vector3 frozenPosition Position in frozen space. SetLockedPose(Pose) Override of base SetLockedPose to allow insertion of the computation of rotation. Declaration public override void SetLockedPose(Pose lockedPose) Parameters Type Name Description Pose lockedPose The new pose in world locked space. Overrides SpacePin.SetLockedPose(Pose) Remarks Note that base class implementation is not invoked here, but rather this override performs the same steps but with additional computations (for the rotation) interleaved. SetLockedPosition(Vector3) Set the position in world locked space. Rotation not needed since it is computed based on relative positions. Declaration public void SetLockedPosition(Vector3 lockedPosition) Parameters Type Name Description Vector3 lockedPosition Position in locked space. SetOrienter(IOrienter) Explicitly set the managing IOrienter, overriding any setting from the Inspector. Declaration public void SetOrienter(IOrienter iorienter) Parameters Type Name Description IOrienter iorienter Remarks The Orienter is nominally a completely internal artifact. The public setter is to allow construction from script. SetSpongyPosition(Vector3) Set the position in spongy space. Rotation not needed since it is computed based on relative positions. Declaration public void SetSpongyPosition(Vector3 spongyPosition) Parameters Type Name Description Vector3 spongyPosition Position in spongyt space. Start() Adopt the Inspector set Orienter as the interface iorienter. Declaration protected override void Start() Overrides SpacePin.Start() Implements IOrientable"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpongyAnchor.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpongyAnchor.html",
    "title": "Class SpongyAnchor | World Locking Tools for Unity Documentation",
    "keywords": "Class SpongyAnchor Wrapper class for Unity spatial anchors, facilitating creation and persistence. Inheritance Object SpongyAnchor SpongyAnchorARCore SpongyAnchorARF SpongyAnchorNull SpongyAnchorWSA SpongyAnchorXR Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public abstract class SpongyAnchor : MonoBehaviour Properties Delta Diagnostic only - to be removed. Declaration public virtual Vector3 Delta { get; set; } Property Value Type Description Vector3 IsLocated Returns true if the anchor is reliably located. False might mean loss of tracking or not fully initialized. Declaration public abstract bool IsLocated { get; } Property Value Type Description Boolean IsSaved Whether the underlying spatial anchor is known to be in the local anchor store. Declaration public virtual bool IsSaved { get; set; } Property Value Type Description Boolean Remarks Note that the anchor might be in the anchor store but isn't known to be, so IsSaved == false. In particular, a different anchor might be stored under the same name, in which case saving this anchor probably requires deleting the old anchor first. SpongyPose Return the anchor's pose in spongy space. Declaration public abstract Pose SpongyPose { get; } Property Value Type Description Pose"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpongyAnchorARCore.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpongyAnchorARCore.html",
    "title": "Class SpongyAnchorARCore | World Locking Tools for Unity Documentation",
    "keywords": "Class SpongyAnchorARCore Inheritance Object SpongyAnchor SpongyAnchorARCore Inherited Members SpongyAnchor.IsSaved SpongyAnchor.Delta Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class SpongyAnchorARCore : SpongyAnchor Fields TrackingStartDelayTime Declaration public static float TrackingStartDelayTime Field Value Type Description Single Properties IsLocated Returns true if the anchor is reliably located. False might mean loss of tracking or not fully initialized. Declaration public override bool IsLocated { get; } Property Value Type Description Boolean Overrides SpongyAnchor.IsLocated SpongyPose Declaration public override Pose SpongyPose { get; } Property Value Type Description Pose Overrides SpongyAnchor.SpongyPose"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpongyAnchorARF.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpongyAnchorARF.html",
    "title": "Class SpongyAnchorARF | World Locking Tools for Unity Documentation",
    "keywords": "Class SpongyAnchorARF Wrapper class for Unity WorldAnchor, facilitating creation and persistence. Inheritance Object SpongyAnchor SpongyAnchorARF Inherited Members SpongyAnchor.IsSaved SpongyAnchor.Delta Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class SpongyAnchorARF : SpongyAnchor Fields TrackingStartDelayTime Declaration public static float TrackingStartDelayTime Field Value Type Description Single Properties IsLocated Returns true if the anchor is reliably located. False might mean loss of tracking or not fully initialized. Declaration public override bool IsLocated { get; } Property Value Type Description Boolean Overrides SpongyAnchor.IsLocated SpongyPose Declaration public override Pose SpongyPose { get; } Property Value Type Description Pose Overrides SpongyAnchor.SpongyPose"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpongyAnchorNull.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpongyAnchorNull.html",
    "title": "Class SpongyAnchorNull | World Locking Tools for Unity Documentation",
    "keywords": "Class SpongyAnchorNull Wrapper class for a no-op spatial, platform-free anchor. Inheritance Object SpongyAnchor SpongyAnchorNull Inherited Members SpongyAnchor.IsSaved SpongyAnchor.Delta Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class SpongyAnchorNull : SpongyAnchor Fields TrackingStartDelayTime Declaration public static float TrackingStartDelayTime Field Value Type Description Single Properties IsLocated Returns true if the anchor is reliably located. False might mean loss of tracking or not fully initialized. Declaration public override bool IsLocated { get; } Property Value Type Description Boolean Overrides SpongyAnchor.IsLocated SpongyPose Declaration public override Pose SpongyPose { get; } Property Value Type Description Pose Overrides SpongyAnchor.SpongyPose"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpongyAnchorWSA.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpongyAnchorWSA.html",
    "title": "Class SpongyAnchorWSA | World Locking Tools for Unity Documentation",
    "keywords": "Class SpongyAnchorWSA Wrapper class for Unity WorldAnchor, facilitating creation and persistence. Inheritance Object SpongyAnchor SpongyAnchorWSA Inherited Members SpongyAnchor.IsSaved SpongyAnchor.Delta Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class SpongyAnchorWSA : SpongyAnchor Fields TrackingStartDelayTime Timeout that protects against SpatialAnchor easing Declaration public static float TrackingStartDelayTime Field Value Type Description Single Properties IsLocated Returns true if the anchor is reliably located. False might mean loss of tracking or not fully initialized. Declaration public override bool IsLocated { get; } Property Value Type Description Boolean Overrides SpongyAnchor.IsLocated SpongyPose Declaration public override Pose SpongyPose { get; } Property Value Type Description Pose Overrides SpongyAnchor.SpongyPose"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpongyAnchorXR.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpongyAnchorXR.html",
    "title": "Class SpongyAnchorXR | World Locking Tools for Unity Documentation",
    "keywords": "Class SpongyAnchorXR Wrapper class for Unity XRAnchor, facilitating creation and persistence. Inheritance Object SpongyAnchor SpongyAnchorXR Inherited Members SpongyAnchor.IsSaved SpongyAnchor.Delta Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class SpongyAnchorXR : SpongyAnchor Fields TrackingStartDelayTime Declaration public static float TrackingStartDelayTime Field Value Type Description Single Properties IsLocated Returns true if the anchor is reliably located. False might mean loss of tracking or not fully initialized. Declaration public override bool IsLocated { get; } Property Value Type Description Boolean Overrides SpongyAnchor.IsLocated IsReliablyLocated Whether the anchor is being tracked reliably. Declaration public bool IsReliablyLocated { get; set; } Property Value Type Description Boolean Remarks This state is managed by the anchor manager. SpongyPose Declaration public override Pose SpongyPose { get; } Property Value Type Description Pose Overrides SpongyAnchor.SpongyPose"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.TransformExtensions.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.TransformExtensions.html",
    "title": "Class TransformExtensions | World Locking Tools for Unity Documentation",
    "keywords": "Class TransformExtensions Conversion function between a pose and a transform. Inheritance Object TransformExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public static class TransformExtensions Methods GetGlobalPose(Transform) Declaration public static Pose GetGlobalPose(this Transform transform) Parameters Type Name Description Transform transform Returns Type Description Pose GetLocalPose(Transform) Declaration public static Pose GetLocalPose(this Transform transform) Parameters Type Name Description Transform transform Returns Type Description Pose SetGlobalPose(Transform, Pose) Declaration public static void SetGlobalPose(this Transform transform, Pose pose) Parameters Type Name Description Transform transform Pose pose SetLocalPose(Transform, Pose) Declaration public static void SetLocalPose(this Transform transform, Pose pose) Parameters Type Name Description Transform transform Pose pose"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.html",
    "title": "Namespace Microsoft.MixedReality.WorldLocking.Core.Triangulator | World Locking Tools for Unity Documentation",
    "keywords": "Namespace Microsoft.MixedReality.WorldLocking.Core.Triangulator Classes Interpolant Container for three indices and a weight for each index, everything needed to interpolate between the data associated with each index, except for the data itself. SimpleTriangulator Basic implementation of ITriangulator. Not optimized. Interfaces ITriangulator Very simple interface for triangulator, to avoid building complex dependencies."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.Interpolant.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.Interpolant.html",
    "title": "Class Interpolant | World Locking Tools for Unity Documentation",
    "keywords": "Class Interpolant Container for three indices and a weight for each index, everything needed to interpolate between the data associated with each index, except for the data itself. Inheritance Object Interpolant Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core.Triangulator Assembly : cs.temp.dll.dll Syntax public class Interpolant Remarks This could be generalized to have N-indices and weights instead, for example to represent interpolation along an edge, or exact hit on a single index, or even weighted averages of N-polygons. Fields idx Three indices. Declaration public readonly int[] idx Field Value Type Description Int32 [] weights Three weights. Declaration public readonly float[] weights Field Value Type Description Single [] Properties IsInterior True if this represents a true interpolation (rather than an extrapolation). Declaration public bool IsInterior { get; } Property Value Type Description Boolean"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.ITriangulator.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.ITriangulator.html",
    "title": "Interface ITriangulator | World Locking Tools for Unity Documentation",
    "keywords": "Interface ITriangulator Very simple interface for triangulator, to avoid building complex dependencies. Namespace : Microsoft.MixedReality.WorldLocking.Core.Triangulator Assembly : cs.temp.dll.dll Syntax public interface ITriangulator Methods Add(Vector3[]) Add vertices. Declaration bool Add(Vector3[] vertices) Parameters Type Name Description Vector3 [] vertices The vertices to add. Returns Type Description Boolean True on success. Clear() Clear out all vertices added so far. Declaration void Clear() Find(Vector3) Find the interpolant for the given query position. Declaration Interpolant Find(Vector3 pos) Parameters Type Name Description Vector3 pos The query positon. Returns Type Description Interpolant An interpolant if found, else null. Remarks Note that one or more weights may be zero, but otherwise all indices returned will be valid. But while the data behind a vertex with weight zero may be referenced (as the index is valid), it is otherwise meaningless. The return value of null only happens if no vertices have been added to be interpolated. SetBounds(Vector3, Vector3) Set the bounds of vertices to be triangulated. All vertices entered in Add() should be inside the quad formed by these bounds. Declaration void SetBounds(Vector3 minPos, Vector3 maxPos) Parameters Type Name Description Vector3 minPos The minimum coordinates of the bounds. Vector3 maxPos The maximum coordinates of the bounds. Remarks The vertical coordinate Y is ignored. Note that queries outsde the bounds are okay, only all vertices must be contained."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.SimpleTriangulator.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.SimpleTriangulator.html",
    "title": "Class SimpleTriangulator | World Locking Tools for Unity Documentation",
    "keywords": "Class SimpleTriangulator Basic implementation of ITriangulator. Not optimized. Inheritance Object SimpleTriangulator Implements ITriangulator Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core.Triangulator Assembly : cs.temp.dll.dll Syntax public class SimpleTriangulator : ITriangulator Remarks This has been written for simplicity for triangulating a small number of vertices. It lacks optimizations such as a full Delaunay triangulation on setup or hierarchical search (e.g. quadtree) on search. Properties Triangles SpacePinMeshVisualizer uses this dto as reference. Declaration public int[] Triangles { get; } Property Value Type Description Int32 [] Vertices SpacePinMeshVisualizer uses this dto as reference. Declaration public List<Vector3> Vertices { get; } Property Value Type Description List < Vector3 > Methods Add(Vector3[]) Add vertices to further triangulate. Declaration public bool Add(Vector3[] vertices) Parameters Type Name Description Vector3 [] vertices The new vertices to add. Returns Type Description Boolean True on success. Remarks Bounds should already be set. Also, the bounds should be big enough to contain all vertices being added. Clear() Reset to original state, discarding all. Declaration public void Clear() Remarks Note this discards the bounds as well, so they must be set again after each clear. Find(Vector3) Declaration public Interpolant Find(Vector3 pos) Parameters Type Name Description Vector3 pos Returns Type Description Interpolant SetBounds(Vector3, Vector3) Declaration public void SetBounds(Vector3 minPos, Vector3 maxPos) Parameters Type Name Description Vector3 minPos Vector3 maxPos Implements ITriangulator"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.WorldLockingContext.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.WorldLockingContext.html",
    "title": "Class WorldLockingContext | World Locking Tools for Unity Documentation",
    "keywords": "Class WorldLockingContext The central component for providing WorldLocking functionality to a scene Inheritance Object WorldLockingContext Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class WorldLockingContext : MonoBehaviour Remarks This component must be placed on a single GameObject in the scene. Typically, this would be a dedicated root GameObject with identity transform. Properties DiagnosticsSettings Diagnostics settings. These are shared with the manager when active. Changes from script should be made through the manager's interface, but will be visible here in inspector. Declaration public SharedDiagnosticsSettings DiagnosticsSettings { get; } Property Value Type Description SharedDiagnosticsSettings SharedSettings WorldLocking settings. These are shared with the manager when active. Changes from script should be made through the manager's interface, but will be visible here in inspector. Declaration public SharedManagerSettings SharedSettings { get; } Property Value Type Description SharedManagerSettings"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.WorldLockingManager.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.WorldLockingManager.html",
    "title": "Class WorldLockingManager | World Locking Tools for Unity Documentation",
    "keywords": "Class WorldLockingManager Ultimate manager of World Locking. WorldLockingManager supplies access to the sub-managers, IAnchorManager , IFragmentManager , and IAttachmentPointManager . Inheritance Object WorldLockingManager Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class WorldLockingManager Fields Plugin Direct interface to the plugin. It is not generally necessary or desired to directly manipulate the plugin, but may be useful for manual override of some plugin inputs, outputs, or controls. Declaration public readonly IPlugin Plugin Field Value Type Description IPlugin Properties AdjustmentFrame The transform at which to apply the camera adjustment. This can't be the camera node, as its transform is overwritten every frame with head pose data. But the camera should be an attached descendant of this node. Declaration public Transform AdjustmentFrame { get; set; } Property Value Type Description Transform AlignmentManager Declaration public IAlignmentManager AlignmentManager { get; } Property Value Type Description IAlignmentManager AnchorManager Interface to the Anchor Manager. Declaration public IAnchorManager AnchorManager { get; } Property Value Type Description IAnchorManager AnchorSettings Access to anchor management settings. Declaration public AnchorSettings AnchorSettings { get; set; } Property Value Type Description AnchorSettings Remarks Use ResetAnchorManager() to change the type of the anchor manager after startup, or just rebuild it from scratch. ApplyAdjustment Apply the computed adjustment via the AdjustmentFrame transform. Declaration public bool ApplyAdjustment { get; } Property Value Type Description Boolean Remarks If ApplyAdjustment is false, then WLT does the same computations, but it is up to the application to apply the computed transforms correctly, either in the camera hierarchy, or elsewhere in the scene hierarchy. AttachmentPointManager Interface to the attachment point manager. Use for creating and manipulating attachment points. Declaration public IAttachmentPointManager AttachmentPointManager { get; } Property Value Type Description IAttachmentPointManager AutoLoad Automatically load the WorldLocking state from disk at startup. Declaration public bool AutoLoad { get; } Property Value Type Description Boolean AutoMerge Automatically trigger a fragment merge whenever the FrozenWorld engine indicates that one would be appropriate. Declaration public bool AutoMerge { get; } Property Value Type Description Boolean AutoRefreeze Automatically trigger a refreeze whenever the FrozenWorld engine indicates that one would be appropriate. Declaration public bool AutoRefreeze { get; } Property Value Type Description Boolean AutoSave Periodically save the WorldLocking state to disk. Declaration public bool AutoSave { get; } Property Value Type Description Boolean CameraFromSpongy Inverse of the camera transform (camera from parent). Declaration public Pose CameraFromSpongy { get; } Property Value Type Description Pose CameraParent The camera parent node defines the \"spongy frame of reference\". All raw head based data, such as the spatial mapping, gesture events, and XR head pose data, are relative to this transform. Declaration public Transform CameraParent { get; set; } Property Value Type Description Transform DiagnosticsSettings Get a copy of the shared diagnostics configuration settings, or set the shared settings to a copy of the input. Declaration public DiagnosticsSettings DiagnosticsSettings { get; set; } Property Value Type Description DiagnosticsSettings Enabled Whether the system is currently active and stabilizing space. Declaration public bool Enabled { get; } Property Value Type Description Boolean ErrorStatus The current error status of the WorldLockingManager Declaration public string ErrorStatus { get; } Property Value Type Description String FragmentManager Interface to the fragment manager. Declaration public IFragmentManager FragmentManager { get; } Property Value Type Description IFragmentManager FrozenFromLocked Declaration public Pose FrozenFromLocked { get; } Property Value Type Description Pose FrozenFromPinned Any application applied transform above the adjustment node. Declaration public Pose FrozenFromPinned { get; } Property Value Type Description Pose FrozenFromSpongy Transform from spongy space to frozen space. Spongy space is that native to XR interfaces. Frozen is Unity's global coordinate space. Transform includes the WorldLocking adjustment to the camera, as well as any other transforms applied to the camera (e.g. teleport). Declaration public Pose FrozenFromSpongy { get; } Property Value Type Description Pose FrozenWorldFileName Filename at which to Save subsequent FrozenWorldEngine state to, and from which to Load it. Declaration public string FrozenWorldFileName { get; set; } Property Value Type Description String Remarks Some error checking for common mistakes is made, but some common sense should prevail. Use valid, normal filenames. A subpath may be introduced, but the entire path must be relative. Some examples: Good: 'myfile.myext', 'mypath/myfile.myext' Bad: null, '/myfile.myext' The actual final full path name used will be off of Application.persistentDataPath, which is platform dependent. HasPendingIO Whether the manager is currently asynchronously loading or saving state. Declaration public bool HasPendingIO { get; } Property Value Type Description Boolean Remarks Any attempt to manually initiate a Save or Load while HasPendingIO is true will quietly fail. LinkageSettings Access to linkage settings. Declaration public LinkageSettings LinkageSettings { get; set; } Property Value Type Description LinkageSettings LockedFromFrozen Declaration public Pose LockedFromFrozen { get; } Property Value Type Description Pose LockedFromPinned From pinned space back to the world-locked space. Declaration public Pose LockedFromPinned { get; } Property Value Type Description Pose LockedFromPlayspace Adjustment transform to world-lock the coordinate space. Declaration public Pose LockedFromPlayspace { get; set; } Property Value Type Description Pose LockedFromSpongy Declaration public Pose LockedFromSpongy { get; } Property Value Type Description Pose MergeIndicated Indicator for the FrozenWorld engine internal heuristics of whether a merge should be performed Declaration public bool MergeIndicated { get; } Property Value Type Description Boolean NoPitchAndRoll Zero out pitch and roll from FrozenWorldEngine's computed correction. Declaration public bool NoPitchAndRoll { get; } Property Value Type Description Boolean Remarks This does not affect pitch and roll from the AlignmentManager (SpacePins). PinnedFromFrozen Transform from application's frozen space back to space computed by WorldLocking. Declaration public Pose PinnedFromFrozen { get; } Property Value Type Description Pose PinnedFromLocked Transform from the world locked space computed by WorldLocking to the space pinned in place. Declaration public Pose PinnedFromLocked { get; set; } Property Value Type Description Pose PlayspaceFromLocked Inverse of adjustment transform to world-lock the coordinate space. Declaration public Pose PlayspaceFromLocked { get; } Property Value Type Description Pose PlayspaceFromSpongy Transform applied by (optional) camera parent node (e.g. for teleport). Declaration public Pose PlayspaceFromSpongy { get; } Property Value Type Description Pose RefreezeIndicated Indicator for the FrozenWorld engine internal heuristics of whether a refreeze should be performed Declaration public bool RefreezeIndicated { get; } Property Value Type Description Boolean Settings The configuration settings may only be set as a block. Get returns a snapshot of current settings, and set copies entire block. Declaration public ManagerSettings Settings { get; set; } Property Value Type Description ManagerSettings Remarks To change an individual field in the settings, retrieve the entire settings block, change the desired field(s), then set the entire block. E.g. var settings = mgr.Settings; settings.AutoLoad = false; settings.AutoSave = true; mgr.Settings = settings; SpongyFromCamera The camera transform (parent from camera). Declaration public Pose SpongyFromCamera { get; set; } Property Value Type Description Pose SpongyFromFrozen Transform from frozen space to XR native spongy space, including other transforms accumulated in the camera's ancestors (e.g. teleport). Declaration public Pose SpongyFromFrozen { get; } Property Value Type Description Pose SpongyFromLocked Declaration public Pose SpongyFromLocked { get; } Property Value Type Description Pose SpongyFromPlayspace Inverse of transform applied by (optional) camera parent node (e.g. for teleport). Declaration public Pose SpongyFromPlayspace { get; } Property Value Type Description Pose Version The version of this release. This will be displayed in the WorldLockingContext component in the Unity Inspector, allowing quick visual verification of the version of World Locking Tools for Unity currently installed. It has no effect in code, but serves only as a label. A \"_dev\" suffix means it's the main branch under current development (between releases). When released, the _dev suffix is removed. For example, 1.5.9_dev is released as 1.5.9. Declaration public static string Version { get; } Property Value Type Description String Methods Dispose() Dispose of internals on shutdown. Declaration public void Dispose() Finalize() Dispose of internals on shutdown. Declaration protected void Finalize() GetInstance() Get the WorldLockingManager instance. This may be called at any time in program execution, but if called during load its settings may not have been loaded from a new scene yet. Declaration public static WorldLockingManager GetInstance() Returns Type Description WorldLockingManager The WorldLockingManager Load() Manually trigger a load operation for the WorldLocking state Declaration public void Load() Reset() Bring WorldLocking to a well-defined, empty state Declaration public void Reset() ResetAnchorManager() Perform any initialization only appropriate once. This is called after giving the caller a chance to change settings. Declaration public async void ResetAnchorManager() Save() Manually trigger a save operation for the WorldLocking state Declaration public void Save() SetContext(WorldLockingContext) Start using shared settings from given context. Declaration public void SetContext(WorldLockingContext context) Parameters Type Name Description WorldLockingContext context The context supplying the new shared settings."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.AlignmentControl.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.AlignmentControl.html",
    "title": "Class AlignmentControl | World Locking Tools for Unity Documentation",
    "keywords": "Class AlignmentControl Inheritance Object AlignmentControl Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class AlignmentControl : MonoBehaviour Methods Clear() Declaration public void Clear()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.CircleCam.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.CircleCam.html",
    "title": "Class CircleCam | World Locking Tools for Unity Documentation",
    "keywords": "Class CircleCam Inheritance Object CircleCam Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class CircleCam : MonoBehaviour Fields distance Declaration public float distance Field Value Type Description Single lookAngle Declaration public float lookAngle Field Value Type Description Single rpm Declaration public float rpm Field Value Type Description Single"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.DashboardCommand.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.DashboardCommand.html",
    "title": "Class DashboardCommand | World Locking Tools for Unity Documentation",
    "keywords": "Class DashboardCommand The DashboardCommand class provides a proxy layer between interactive elements (e.g. buttons) and the actions that need to be performed (e.g. WorldLockingManager perform a merge). Inheritance Object DashboardCommand Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class DashboardCommand : MonoBehaviour Properties AnchorVisualization Toggle anchor visualization. Declaration public bool AnchorVisualization { get; set; } Property Value Type Description Boolean AutoMerge Toggle automatic merging whenever indicated by underlying system. Declaration public bool AutoMerge { get; set; } Property Value Type Description Boolean AutoRefreeze Toggle automatic refreezing whenever indicated by underlying system. Declaration public bool AutoRefreeze { get; set; } Property Value Type Description Boolean AutoSave Toggle automatic saving of state for later restore. Declaration public bool AutoSave { get; set; } Property Value Type Description Boolean HasSpatialMap Return whether there is an available frozen spatial mapping setup and attached. Declaration public bool HasSpatialMap { get; } Property Value Type Description Boolean InfoEnabled Toggle info display. Declaration public bool InfoEnabled { get; set; } Property Value Type Description Boolean ManagerEnabled Whether the WorldLockingManager is actively stabilizing space or being bypassed. Declaration public bool ManagerEnabled { get; set; } Property Value Type Description Boolean MetricsEnabled Toggle Metrics display Declaration public bool MetricsEnabled { get; set; } Property Value Type Description Boolean SpatialMapDisplayEnabled Toggle whether the spatial mapping mesh is displayed. Declaration public bool SpatialMapDisplayEnabled { get; set; } Property Value Type Description Boolean StateEnabled Toggle state display Declaration public bool StateEnabled { get; set; } Property Value Type Description Boolean StatusEnabled Toggle status display Declaration public bool StatusEnabled { get; set; } Property Value Type Description Boolean Methods Load() Load the last frozen world state, overwriting current state. Declaration public void Load() Merge() Perform a merge. Declaration public void Merge() Refreeze() Perform a refreeze Declaration public void Refreeze() Reset() Reset the frozen world state to a starting condition. Declaration public void Reset() Save() Save current frozen world state. Declaration public void Save() ToggleGui() Declaration public void ToggleGui() ToggleManager() Declaration public void ToggleManager()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.DashboardUI.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.DashboardUI.html",
    "title": "Class DashboardUI | World Locking Tools for Unity Documentation",
    "keywords": "Class DashboardUI Simple class to manage synchronizing state up to UI elements. Inheritance Object DashboardUI Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class DashboardUI : MonoBehaviour Fields ButtonLoad Manual perform load of last saved anchor state, overwriting current state. Declaration public Interactable ButtonLoad Field Value Type Description Interactable ButtonMerge Button to perform a merge, only enabled when a refreeze is available. Declaration public Interactable ButtonMerge Field Value Type Description Interactable ButtonRefreeze Button to perform a refreeze, only enabled when a refreeze is available. Declaration public Interactable ButtonRefreeze Field Value Type Description Interactable ButtonSave Manual perform save of current anchor state. Declaration public Interactable ButtonSave Field Value Type Description Interactable CheckBoxAutoMerge Toggle automatic merge operation when indicated by engine. Declaration public Interactable CheckBoxAutoMerge Field Value Type Description Interactable CheckBoxAutoRefreeze Toggle automatic refreeze operations when indicated by engine. Declaration public Interactable CheckBoxAutoRefreeze Field Value Type Description Interactable CheckBoxAutoSave Toggle periodic automatic saves of anchor state. Declaration public Interactable CheckBoxAutoSave Field Value Type Description Interactable CheckBoxManagerEnabled Toggle Frozen World Manager. Declaration public Interactable CheckBoxManagerEnabled Field Value Type Description Interactable CheckBoxShowAnchors Toggle diagnostic display of anchors. Declaration public Interactable CheckBoxShowAnchors Field Value Type Description Interactable CheckBoxShowInfo Toggle display of basic information. Declaration public Interactable CheckBoxShowInfo Field Value Type Description Interactable CheckBoxShowMetrics Toggle display of detailed metrics. Declaration public Interactable CheckBoxShowMetrics Field Value Type Description Interactable CheckBoxShowSpatMap Toggle display of spatial map. Declaration public Interactable CheckBoxShowSpatMap Field Value Type Description Interactable dashboardCommand Dashboard command dispatcher. Declaration public DashboardCommand dashboardCommand Field Value Type Description DashboardCommand"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.FallOut.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.FallOut.html",
    "title": "Class FallOut | World Locking Tools for Unity Documentation",
    "keywords": "Class FallOut Inheritance Object FallOut Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class FallOut : MonoBehaviour Fields KillHeight The height below the camera at which a falling object disappears. Object's position is based on local space origin, not bounds. Declaration public float KillHeight Field Value Type Description Single"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.html",
    "title": "Namespace Microsoft.MixedReality.WorldLocking.Examples | World Locking Tools for Unity Documentation",
    "keywords": "Namespace Microsoft.MixedReality.WorldLocking.Examples Classes AlignmentControl CircleCam DashboardCommand The DashboardCommand class provides a proxy layer between interactive elements (e.g. buttons) and the actions that need to be performed (e.g. WorldLockingManager perform a merge). DashboardUI Simple class to manage synchronizing state up to UI elements. FallOut PhysicsBeamSample Example component using Frozen World to facilitate physics simulation. PinManipulator Helper class to add MRTK object manipulation controls to an object. RayPins SpacePinManipulation Make the SpacePin manually manipulable, using MRTK controls. SpacePinOrientableManipulation Component that adds MRTK object manipulation capabilities on top of the auto-orienting SpacePinOrientable . Delegates ManipulationEndedDelegate Callback for when the user has finished positioning and/or orienting the target. ManipulationStartedDelegate Callback for when the user starts positioning and/or orienting the target."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.ManipulationEndedDelegate.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.ManipulationEndedDelegate.html",
    "title": "Delegate ManipulationEndedDelegate | World Locking Tools for Unity Documentation",
    "keywords": "Delegate ManipulationEndedDelegate Callback for when the user has finished positioning and/or orienting the target. Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public delegate void ManipulationEndedDelegate();"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.ManipulationStartedDelegate.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.ManipulationStartedDelegate.html",
    "title": "Delegate ManipulationStartedDelegate | World Locking Tools for Unity Documentation",
    "keywords": "Delegate ManipulationStartedDelegate Callback for when the user starts positioning and/or orienting the target. Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public delegate void ManipulationStartedDelegate();"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.PhysicsBeamSample.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.PhysicsBeamSample.html",
    "title": "Class PhysicsBeamSample | World Locking Tools for Unity Documentation",
    "keywords": "Class PhysicsBeamSample Example component using Frozen World to facilitate physics simulation. Inheritance Object PhysicsBeamSample Implements IMixedRealityPointerHandler Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class PhysicsBeamSample : InputSystemGlobalHandlerListener Remarks This MRTK based component uses MRTK for inputs to abstract out device. In all modes, the ray cast intersection as reported by MRTK is further filtered to specifically exclude UI elements. Along with collidable objects in the scene, a collidable spatial map is also included as ray cast target. The \"hit point\" is the intersection of the currently active pointer ray with those collidables, along with information about that object and the intersection (e.g. surface normal at hit point). If there is no current hit point, after excluding UI elements, no operation is performed. The component itself has 5 modes of operation: Idle - ignore inputs, do nothing Throw darts - compute and display an ballistic arc to toss a physics rigid body at the current hit point. Place pillar - Place an upright pillar at hit point. If the hit object is not a beam or pillar (e.g. is the spatial map), then a static pillar is added, else a physically simulated pillar. Place beam - A two part operation. The first select of a hit point establishes the first end point of a beam, and the second hit point the other beam's end point. A physically simulated beam stretched to have those two endpoints is generated and added to the scene. Remove object - Clicking on an object added to the scene in one of the above modes will remove it from the scene. Mode selection is done via the MRTK radio buttons (see Microsoft.MixedReality.Toolkit.UI.InteractableToggleCollection) included in the scene as an addition to the dashboard. Properties AttachRoot The subroot to attach created objects to. Declaration public Transform AttachRoot { get; } Property Value Type Description Transform LineMaterial Material to use when rendering line for beam placement. Declaration public Material LineMaterial { get; } Property Value Type Description Material PrefabBeam The prefab of the beam to place in the world at gaze position on air taps. Declaration public GameObject PrefabBeam { get; } Property Value Type Description GameObject PrefabDart The prefab of the dart to place in the world at gaze position on air taps. Declaration public GameObject PrefabDart { get; } Property Value Type Description GameObject PrefabHybridLockedSphere The prefab of the hybrid-locked 'sphere' to place in the world at gaze position on air taps in Pin Sphere Mode. Declaration public GameObject PrefabHybridLockedSphere { get; } Property Value Type Description GameObject PrefabPillarDynamic The prefab of dynamic pillars to place in the world at gaze position on air taps. Declaration public GameObject PrefabPillarDynamic { get; } Property Value Type Description GameObject PrefabPillarFixed The prefab of fixed pillars to place in the world at gaze position on air taps. Declaration public GameObject PrefabPillarFixed { get; } Property Value Type Description GameObject PrefabUnlockedSphere The prefab of the non-locked 'sphere' to place in the world at gaze position on air taps in Pin Sphere Mode. Declaration public GameObject PrefabUnlockedSphere { get; } Property Value Type Description GameObject PrefabWorldLockedSphere The prefab of the world-locked 'sphere' to place in the world at gaze position on air taps in Pin Sphere Mode. Declaration public GameObject PrefabWorldLockedSphere { get; } Property Value Type Description GameObject Methods EnterBeamMode() Switch into cross-beam placement mode. Declaration public void EnterBeamMode() EnterDartMode() Switch into dart tossing mode. Declaration public void EnterDartMode() EnterIdleMode() Switch into idle mode. Declaration public void EnterIdleMode() EnterPillarMode() Switch into pillar placement mode. Declaration public void EnterPillarMode() EnterPinSphereMode() Declaration public void EnterPinSphereMode() EnterRemoveMode() Switch into object removal mode. Declaration public void EnterRemoveMode() EnterWorldLockHybridLocked() Declaration public void EnterWorldLockHybridLocked() EnterWorldLockUnlocked() Declaration public void EnterWorldLockUnlocked() EnterWorldLockWorldLocked() Declaration public void EnterWorldLockWorldLocked() OnPointerClicked(MixedRealityPointerEventData) Process pointer clicked event if ray cast has result. Declaration public void OnPointerClicked(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData OnPointerDown(MixedRealityPointerEventData) No-op on pointer down. Declaration public void OnPointerDown(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData OnPointerDragged(MixedRealityPointerEventData) No-op on pointer drag. Declaration public void OnPointerDragged(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData OnPointerUp(MixedRealityPointerEventData) No-op on pointer up. Declaration public void OnPointerUp(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData RegisterHandlers() Declaration protected override void RegisterHandlers() Start() Override InputSystemGlobalListener Start() method for additional one-time setup. Declaration protected override void Start() UnregisterHandlers() Declaration protected override void UnregisterHandlers() Implements IMixedRealityPointerHandler"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.PinManipulator.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.PinManipulator.html",
    "title": "Class PinManipulator | World Locking Tools for Unity Documentation",
    "keywords": "Class PinManipulator Helper class to add MRTK object manipulation controls to an object. Inheritance Object PinManipulator Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class PinManipulator Constructors PinManipulator(Transform, GameObject, ManipulationEndedDelegate) Backward compat with no specified manipulation started callback. Declaration public PinManipulator(Transform ownder, GameObject prefab, ManipulationEndedDelegate ended) Parameters Type Name Description Transform ownder GameObject prefab The visualization prefab to instantiate. ManipulationEndedDelegate ended The manipulation ended callback. PinManipulator(Transform, GameObject, ManipulationStartedDelegate, ManipulationEndedDelegate) Constructor accepts readonly dependencies. Declaration public PinManipulator(Transform owner, GameObject prefab, ManipulationStartedDelegate started, ManipulationEndedDelegate ended) Parameters Type Name Description Transform owner The object to manipulate. GameObject prefab The visualization prefab to instantiate. ManipulationStartedDelegate started The manipulation started callback. ManipulationEndedDelegate ended The manipulation ended callback. Properties UserOriented Whether to enable user orientation of the object. If false, only positioning enabled. Declaration public bool UserOriented { get; set; } Property Value Type Description Boolean Remarks May be toggled from script during runtime. Methods Shutdown() Cleanup. Declaration public virtual void Shutdown() Startup() Get set up. Declaration public void Startup() Update() If active, position and orient the visualization. Declaration public virtual void Update()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.RayPins.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.RayPins.html",
    "title": "Class RayPins | World Locking Tools for Unity Documentation",
    "keywords": "Class RayPins Inheritance Object RayPins Implements IMixedRealityPointerHandler Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class RayPins : InputSystemGlobalHandlerListener Fields spacePinPoints Global position of each of the space pins points can be matched to a ray cast against the environment. Declaration public List<Transform> spacePinPoints Field Value Type Description List < Transform > Properties ActivePin Accessor for currently active pin. Declaration public int ActivePin { get; set; } Property Value Type Description Int32 Methods ClearAll() Disable the effects of all pins, as if they had never been set. Declaration public void ClearAll() CreateSpacePins() Destroy any existing pins, and create new pins, one for each spacePinPoint. Declaration public bool CreateSpacePins() Returns Type Description Boolean True on success. Remarks If the spacePinPoint list is modified from script, CreateSpacePins should be called to resynchronize. OnPointerClicked(MixedRealityPointerEventData) Process pointer clicked event if ray cast has result. Declaration public void OnPointerClicked(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData OnPointerDown(MixedRealityPointerEventData) No-op on pointer down. Declaration public void OnPointerDown(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData OnPointerDragged(MixedRealityPointerEventData) No-op on pointer drag. Declaration public void OnPointerDragged(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData OnPointerUp(MixedRealityPointerEventData) No-op on pointer up. Declaration public void OnPointerUp(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData RegisterHandlers() Declaration protected override void RegisterHandlers() SetActivePin(Int32) Function for setting active pin from MRTK GUI callbacks. Declaration public void SetActivePin(int i) Parameters Type Name Description Int32 i The new current pin. Start() Create a shared orienter, and create space pins for any spacePinPoints set in the inspector. Declaration protected override void Start() UnregisterHandlers() Declaration protected override void UnregisterHandlers() Implements IMixedRealityPointerHandler"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.SpacePinManipulation.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.SpacePinManipulation.html",
    "title": "Class SpacePinManipulation | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePinManipulation Make the SpacePin manually manipulable, using MRTK controls. Inheritance Object SpacePinManipulation Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class SpacePinManipulation : SpacePin Properties Prefab_FeelerRay Proxy renderable to show axis alignment during manipulations. Declaration public GameObject Prefab_FeelerRay { get; set; } Property Value Type Description GameObject Methods OnDestroy() Shutdown the manipulation controls. Declaration protected override void OnDestroy() OnFinishManipulation() Callback for when the user has finished positioning the target. Declaration protected virtual void OnFinishManipulation() OnStartManipulation() Callback for when the user starts manipulating the target. Declaration protected virtual void OnStartManipulation() Start() Start(), and set up MRTK manipulation controls. Declaration protected override void Start()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.SpacePinOrientableManipulation.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.SpacePinOrientableManipulation.html",
    "title": "Class SpacePinOrientableManipulation | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePinOrientableManipulation Component that adds MRTK object manipulation capabilities on top of the auto-orienting SpacePinOrientable . Inheritance Object SpacePinOrientableManipulation Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class SpacePinOrientableManipulation : SpacePinOrientable Properties AllowRotation Whether to show the MRTK rotation gizmos. Declaration public bool AllowRotation { get; set; } Property Value Type Description Boolean Remarks Rotating the SpacePinOrientableManipulation object only has any effect when the first pin is manipulated. Once the second object is manipulated, and ever after, the orientation is implied by the alignment of the pin objects, and actual orientation of the objects is ignored. Prefab_FeelerRay Proxy renderable to show axis alignment during manipulations. Declaration public GameObject Prefab_FeelerRay { get; set; } Property Value Type Description GameObject Methods OnDestroy() Shutdown the manipulation controls. Declaration protected override void OnDestroy() OnFinishManipulation() Callback for when the user has finished positioning the target. Declaration protected virtual void OnFinishManipulation() OnStartManipulation() Callback for when the user starts manipulating the target. Declaration protected virtual void OnStartManipulation() Start() Start(), and set up MRTK manipulation controls. Declaration protected override void Start()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AdjusterBase.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AdjusterBase.html",
    "title": "Class AdjusterBase | World Locking Tools for Unity Documentation",
    "keywords": "Class AdjusterBase Dummy class to identify components as implementing Frozen World's adjustment handler(s). Inheritance Object AdjusterBase AdjusterFixed Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class AdjusterBase : MonoBehaviour Remarks Derivation from this class is not necessary to implement the necessary handling of state and transform messages from the system, as that handling is implemented by delegates, not inheritance. However, having a component derived from this base class attached to an object notifies the system that the object's handling of Frozen World system adjustments is covered, and prevents the system from automatically adding its own handlers to that object (if so configured)."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AdjusterFixed.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AdjusterFixed.html",
    "title": "Class AdjusterFixed | World Locking Tools for Unity Documentation",
    "keywords": "Class AdjusterFixed Component to handle frozen world adjustments for fixed (stationary) objects. Inheritance Object AdjusterBase AdjusterFixed AdjusterMoving Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class AdjusterFixed : AdjusterBase Remarks For dynamic objects, use AdjusterMoving . This component is appropriate for inheriting from, to let it take care of lifetime management and book-keeping, then just override HandleAdjustLocation(Pose) and/or HandleAdjustState(AttachmentPointStateType) with actions more suitable for your application. Properties AttachmentPoint The attachment point which this component wraps. Declaration protected IAttachmentPoint AttachmentPoint { get; } Property Value Type Description IAttachmentPoint Manager The attachment point manager interface which this component subscribes to. Declaration protected IAttachmentPointManager Manager { get; } Property Value Type Description IAttachmentPointManager Methods HandleAdjustLocation(Pose) Handle a pose adjustment due to a refit operation. Declaration protected virtual void HandleAdjustLocation(Pose adjustment) Parameters Type Name Description Pose adjustment The pose adjustment to apply/ Remarks This simple implementation folds the adjustment into the current pose. HandleAdjustState(AttachmentPointStateType) Handle a change in associated fragment state. Declaration protected virtual void HandleAdjustState(AttachmentPointStateType state) Parameters Type Name Description AttachmentPointStateType state The new state. Remarks The only state under which the visual location can be regarded as reliable is the Normal state. This simple implementation disables the object tree when its location is unreliable, and enables it when its location is reliable. Actual appropriate behavior is highly application dependent. Some questions to ask: Is there a more appropriate way to hide the object (e.g. move it far away)? Should the update pause, or just stop rendering? (Disabling pauses update and render). Is it better to hide the object, or to display it in alternate form? Etc. UpdatePosition() For infrequent moves under script control, UpdatePosition notifies the system that the object has relocated. It should be called after any scripted movement of the object (but not after movement triggered by WLT, such as in HandleAdjustLocation(Pose) ). Declaration public void UpdatePosition()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AdjusterMoving.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AdjusterMoving.html",
    "title": "Class AdjusterMoving | World Locking Tools for Unity Documentation",
    "keywords": "Class AdjusterMoving Component to handle frozen world adjustments for dynamic (moving) objects. Inheritance Object AdjusterBase AdjusterFixed AdjusterMoving Inherited Members AdjusterFixed.Manager AdjusterFixed.AttachmentPoint AdjusterFixed.UpdatePosition() AdjusterFixed.HandleAdjustLocation(Pose) AdjusterFixed.HandleAdjustState(AttachmentPointStateType) Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class AdjusterMoving : AdjusterFixed Remarks For stationary objects, use AdjusterFixed . This component uses the Unity Update pass to keep the World Locking Tools system apprised of the target object's position. While that operation is cheap, even just the cost of an additional Update() is best avoided for stationary objects. If the object moves very infrequently under script control, consider using an AdjusterFixed , and notifying it after moves with UpdatePosition() ."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AnchorGraphVisual.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AnchorGraphVisual.html",
    "title": "Class AnchorGraphVisual | World Locking Tools for Unity Documentation",
    "keywords": "Class AnchorGraphVisual Optional visualizer of anchors and edges Inheritance Object AnchorGraphVisual Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class AnchorGraphVisual : MonoBehaviour Fields Prefab_FrameViz Prefab for the frame (axes) visualization. Declaration public FrameVisual Prefab_FrameViz Field Value Type Description FrameVisual Prefab_FrozenAnchorViz Prefab for frozen anchors. Declaration public FrozenAnchorVisual Prefab_FrozenAnchorViz Field Value Type Description FrozenAnchorVisual Prefab_SpongyAnchorViz Prefab for spongy anchors. Declaration public SpongyAnchorVisual Prefab_SpongyAnchorViz Field Value Type Description SpongyAnchorVisual Properties VerticalDisplacement Vertical distance to offset from actual anchors, to avoid visuals at eye level. Declaration public float VerticalDisplacement { get; set; } Property Value Type Description Single Remarks Set this to zero to display visuals at actual anchor locations."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.ConnectingLine.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.ConnectingLine.html",
    "title": "Class ConnectingLine | World Locking Tools for Unity Documentation",
    "keywords": "Class ConnectingLine Helper class for visualizing a graph of connected transforms. Inheritance Object ConnectingLine Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class ConnectingLine : MonoBehaviour Methods Create(Transform, Transform, Transform, Single, Color) Create line segment connecting two transforms and attached to a third Declaration public static ConnectingLine Create(Transform parent, Transform transformA, Transform transformB, float width, Color color) Parameters Type Name Description Transform parent Parent to hang the line segment off of Transform transformA Beginning endpoint of line segment Transform transformB Enging endpoint of line segment Single width Width of the Unity LineRenderer Color color Color of the line segment Returns Type Description ConnectingLine"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrameVisual.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrameVisual.html",
    "title": "Class FrameVisual | World Locking Tools for Unity Documentation",
    "keywords": "Class FrameVisual Component for adjusting color and description text of visual origin markers in a frame (coordinate system axes). Inheritance Object FrameVisual Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class FrameVisual : MonoBehaviour Properties color Text and axes color Declaration public Color color { get; set; } Property Value Type Description Color"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenAnchorVisual.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenAnchorVisual.html",
    "title": "Class FrozenAnchorVisual | World Locking Tools for Unity Documentation",
    "keywords": "Class FrozenAnchorVisual Component for controlling color and ID text of anchor visualizations. Inheritance Object FrozenAnchorVisual Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class FrozenAnchorVisual : MonoBehaviour Remarks The text will be set to the AnchorID. The color will be kept in sync with the parent frame. Methods Instantiate(String, FrameVisual) Create an instance of a frame visualizer Declaration public FrozenAnchorVisual Instantiate(string name, FrameVisual parent) Parameters Type Name Description String name The name of the anchor to be displayed FrameVisual parent The frame visualization object that defines the color of this anchor Returns Type Description FrozenAnchorVisual"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenSpatialMapping.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenSpatialMapping.html",
    "title": "Class FrozenSpatialMapping | World Locking Tools for Unity Documentation",
    "keywords": "Class FrozenSpatialMapping Class to reinterpret spatial mapping data from \"spongy\" space into \"frozen\" space. This is unnecessary when using MRTK's spatial mapping, which provides this and other enhancements over the native spatial mapping. Inheritance Object FrozenSpatialMapping Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class FrozenSpatialMapping : MonoBehaviour Properties Active Whether the Mapping is active. If inactive, all resources disposed and only remade when active again. Declaration public bool Active { get; set; } Property Value Type Description Boolean CenterObject Object around which spatial mappings are centered. Set to null to center around the camera. Declaration public Transform CenterObject { get; } Property Value Type Description Transform Collide Whether to perform collisions and raycasts against these surfaces. Declaration public bool Collide { get; } Property Value Type Description Boolean Display Whether to render the active surfaces with the given material. Declaration public bool Display { get; set; } Property Value Type Description Boolean DrawMaterial Material to draw surfaces with. May be null if no display wanted. Declaration public Material DrawMaterial { get; } Property Value Type Description Material HangerObject Object to attach surface objects to. May be null to add surface objects to scene root. Declaration public Transform HangerObject { get; } Property Value Type Description Transform Quality Quality at which to tessellate. Declaration public FrozenSpatialMapping.QualityType Quality { get; } Property Value Type Description FrozenSpatialMapping.QualityType Radius Radius around the camera to map. Declaration public float Radius { get; } Property Value Type Description Single UpdatePeriod Period in seconds at which to update surfaces. Declaration public float UpdatePeriod { get; } Property Value Type Description Single"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenSpatialMapping.QualityType.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenSpatialMapping.QualityType.html",
    "title": "Enum FrozenSpatialMapping.QualityType | World Locking Tools for Unity Documentation",
    "keywords": "Enum FrozenSpatialMapping.QualityType Supported tessellation quality levels. Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public enum QualityType Fields Name Description High Low Medium"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenTapToAdd.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenTapToAdd.html",
    "title": "Class FrozenTapToAdd | World Locking Tools for Unity Documentation",
    "keywords": "Class FrozenTapToAdd Simple class to adapt Unity's input results from spongy space into frozen space. This is unnecessary when using MRTK's input system, which already provides this and other enhancements and abstactions. Inheritance Object FrozenTapToAdd Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class FrozenTapToAdd : MonoBehaviour Properties Active Enable and disable processing of tap events. Declaration public bool Active { get; set; } Property Value Type Description Boolean PrefabToPlace The prefab to place in the world at gaze position on air taps. Declaration public GameObject PrefabToPlace { get; } Property Value Type Description GameObject"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.html",
    "title": "Namespace Microsoft.MixedReality.WorldLocking.Tools | World Locking Tools for Unity Documentation",
    "keywords": "Namespace Microsoft.MixedReality.WorldLocking.Tools Classes AdjusterBase Dummy class to identify components as implementing Frozen World's adjustment handler(s). AdjusterFixed Component to handle frozen world adjustments for fixed (stationary) objects. AdjusterMoving Component to handle frozen world adjustments for dynamic (moving) objects. AnchorGraphVisual Optional visualizer of anchors and edges ConnectingLine Helper class for visualizing a graph of connected transforms. FrameVisual Component for adjusting color and description text of visual origin markers in a frame (coordinate system axes). FrozenAnchorVisual Component for controlling color and ID text of anchor visualizations. FrozenSpatialMapping Class to reinterpret spatial mapping data from \"spongy\" space into \"frozen\" space. This is unnecessary when using MRTK's spatial mapping, which provides this and other enhancements over the native spatial mapping. FrozenTapToAdd Simple class to adapt Unity's input results from spongy space into frozen space. This is unnecessary when using MRTK's input system, which already provides this and other enhancements and abstactions. SimpleConsole A simple runtime console to help in debugging on device. SimpleSprite Very simple class to rotate sprites to face the camera. SpacePinMeshVisualizer SpacePinPercentageVisualizer SpongyAnchorVisual Component for controlling location, visual appearance and ID text of a spongy anchor visualization. StatusToText Helper to bind WorldLockingManager diagnostics to text meshes for display. ToggleWorldAnchor WorldAnchorAdapter Adapter for aligning an object with a WorldAnchor. WorldLockingSetup Collection of menu driven Editor only functions to automate WLT configuration. Enums FrozenSpatialMapping.QualityType Supported tessellation quality levels."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.SimpleConsole.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.SimpleConsole.html",
    "title": "Class SimpleConsole | World Locking Tools for Unity Documentation",
    "keywords": "Class SimpleConsole A simple runtime console to help in debugging on device. Inheritance Object SimpleConsole Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class SimpleConsole : MonoBehaviour Remarks The system accepts a verbosity level along with each line of text. If the system is enabled, If the verbosity level is >= the logVerbosity the line is written to the Unity log file via Debug.Log(). If the verbosity level is >= the screenVerbosity the line will be displayed on screen. If the system is NOT enabled If the verbosity level is >= 5 the line is written to the Unity log file. To enable the system: Add a SimpleConsole component to any game object in the scene. Fill in the SimpleConsole's TextMesh console field with a valid TextMesh. Ideally, place the console TextMesh where it can be seen. If enabled, then every frame the last lineCount lines added are displayed on the console TextMesh, where lineCount is an inspector accessible property below. Use is thread safe, and from threads besides the main thread. Fields console Declaration public TextMesh console Field Value Type Description TextMesh logVerbosity Declaration public int logVerbosity Field Value Type Description Int32 screenVerbosity Declaration public int screenVerbosity Field Value Type Description Int32 Properties Active Whether the onscreen component is active. Declaration public static bool Active { get; } Property Value Type Description Boolean LineCount The maximum number of lines to display. Declaration public int LineCount { get; set; } Property Value Type Description Int32 LogFile Declaration public string LogFile { get; set; } Property Value Type Description String Methods AddLine(Int32, String) Static helper for adding a line of text for output. Declaration public static int AddLine(int level, string line) Parameters Type Name Description Int32 level The verbosity level of this line. String line The text to display and/or write. Returns Type Description Int32 The number of lines added."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.SimpleSprite.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.SimpleSprite.html",
    "title": "Class SimpleSprite | World Locking Tools for Unity Documentation",
    "keywords": "Class SimpleSprite Very simple class to rotate sprites to face the camera. Inheritance Object SimpleSprite Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class SimpleSprite : MonoBehaviour Properties Swivel Swivel means rotate about Y-axis, set to false to face directly at target. Declaration public bool Swivel { get; set; } Property Value Type Description Boolean Target Object to face towards. Defaults to camera at time Start is called. Declaration public Transform Target { get; set; } Property Value Type Description Transform"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.SpacePinMeshVisualizer.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.SpacePinMeshVisualizer.html",
    "title": "Class SpacePinMeshVisualizer | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePinMeshVisualizer Inheritance Object SpacePinMeshVisualizer Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class SpacePinMeshVisualizer : MonoBehaviour Fields extrapolatedMeshMaterial Declaration public Material extrapolatedMeshMaterial Field Value Type Description Material meshMaterial Declaration public Material meshMaterial Field Value Type Description Material percentageWorldSpaceCanvasPrefab Declaration public GameObject percentageWorldSpaceCanvasPrefab Field Value Type Description GameObject textVerticalOffset Declaration public float textVerticalOffset Field Value Type Description Single verticalFromOrigin Declaration public bool verticalFromOrigin Field Value Type Description Boolean verticalOffset Declaration public float verticalOffset Field Value Type Description Single weightCubeMaxSize Declaration public float weightCubeMaxSize Field Value Type Description Single weightsMaterial Declaration public Material weightsMaterial Field Value Type Description Material wireFrameMaterial Declaration public Material wireFrameMaterial Field Value Type Description Material Properties TargetSubtree Subtree whose SpacePins should be visualized. Null for global AlignmentManager. Declaration public AlignSubtree TargetSubtree { get; set; } Property Value Type Description AlignSubtree Methods GetVisibility() Declaration public bool GetVisibility() Returns Type Description Boolean SetVisibility(Boolean) Declaration public void SetVisibility(bool visible) Parameters Type Name Description Boolean visible"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.SpacePinPercentageVisualizer.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.SpacePinPercentageVisualizer.html",
    "title": "Class SpacePinPercentageVisualizer | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePinPercentageVisualizer Inheritance Object SpacePinPercentageVisualizer Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class SpacePinPercentageVisualizer : MonoBehaviour Fields highPercentageColor Declaration public Color highPercentageColor Field Value Type Description Color highPercentageOutlineColor Declaration public Color highPercentageOutlineColor Field Value Type Description Color lowPercentageColor Declaration public Color lowPercentageColor Field Value Type Description Color lowPercentageOutlineColor Declaration public Color lowPercentageOutlineColor Field Value Type Description Color middlePercentageColor Declaration public Color middlePercentageColor Field Value Type Description Color middlePercentageOutlineColor Declaration public Color middlePercentageOutlineColor Field Value Type Description Color percentageNumberText Declaration public Text percentageNumberText Field Value Type Description Text percentageNumberTextOutline Declaration public Outline percentageNumberTextOutline Field Value Type Description Outline Methods SetVisibility(Boolean) Declaration public void SetVisibility(bool visibility) Parameters Type Name Description Boolean visibility UpdatePercentage(Single) Declaration public void UpdatePercentage(float percentage) Parameters Type Name Description Single percentage"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.SpongyAnchorVisual.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.SpongyAnchorVisual.html",
    "title": "Class SpongyAnchorVisual | World Locking Tools for Unity Documentation",
    "keywords": "Class SpongyAnchorVisual Component for controlling location, visual appearance and ID text of a spongy anchor visualization. Inheritance Object SpongyAnchorVisual Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class SpongyAnchorVisual : MonoBehaviour Remarks Spongy anchors are visualized by a concentric pair of an outer ring and an inner disc The outer ring of fixed size indicates the state of the spatial anchor by its color: green: support(area of inner circle indicating relevance) red: support with zero relevance yellow: not a support gray: anchor not located(i.e.currently not part of spongy world) The inner disc indicates the relevance of the spongy anchor (0..100%) by its area. Methods Instantiate(FrameVisual, SpongyAnchor, Single) Create a visualizer for a spongy anchor. Declaration public SpongyAnchorVisual Instantiate(FrameVisual parent, SpongyAnchor spongyAnchor, float verticalDisplacement) Parameters Type Name Description FrameVisual parent Coordinate space to create the visualizer in SpongyAnchor spongyAnchor The spongyAnchor component assigned to some other object that this object is supposed to sync with Single verticalDisplacement Returns Type Description SpongyAnchorVisual SetNoSupport() Declare as not being a support. Declaration public void SetNoSupport() SetSupportRelevance(Single) Set the relevance, which sets the color. Declaration public void SetSupportRelevance(float relevance) Parameters Type Name Description Single relevance The new relevance"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.StatusToText.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.StatusToText.html",
    "title": "Class StatusToText | World Locking Tools for Unity Documentation",
    "keywords": "Class StatusToText Helper to bind WorldLockingManager diagnostics to text meshes for display. Inheritance Object StatusToText Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class StatusToText : MonoBehaviour Properties ErrorStatusEnabled Text mesh for display of error status. Declaration public bool ErrorStatusEnabled { get; set; } Property Value Type Description Boolean InfoEnabled Text mesh for display of summary info. Declaration public bool InfoEnabled { get; set; } Property Value Type Description Boolean MetricsEnabled Whether display of detailed metrics currently enabled. Declaration public bool MetricsEnabled { get; set; } Property Value Type Description Boolean StateIndicatorEnabled Text mesh for display of current state. Declaration public bool StateIndicatorEnabled { get; set; } Property Value Type Description Boolean VersionTimestampEnabled Text mesh to display version and timestamp. Declaration public bool VersionTimestampEnabled { get; set; } Property Value Type Description Boolean"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.ToggleWorldAnchor.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.ToggleWorldAnchor.html",
    "title": "Class ToggleWorldAnchor | World Locking Tools for Unity Documentation",
    "keywords": "Class ToggleWorldAnchor Inheritance Object ToggleWorldAnchor Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class ToggleWorldAnchor : MonoBehaviour Properties AlwaysLock Always use WorldAnchor to world lock, whether Frozen World is active or not. Declaration public bool AlwaysLock { get; set; } Property Value Type Description Boolean AttachmentPoint Declaration protected IAttachmentPoint AttachmentPoint { get; } Property Value Type Description IAttachmentPoint"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.WorldAnchorAdapter.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.WorldAnchorAdapter.html",
    "title": "Class WorldAnchorAdapter | World Locking Tools for Unity Documentation",
    "keywords": "Class WorldAnchorAdapter Adapter for aligning an object with a WorldAnchor. Inheritance Object WorldAnchorAdapter Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class WorldAnchorAdapter : MonoBehaviour Properties TargetObject The GameObject to be aligned to the WorldAnchor. Declaration public Transform TargetObject { get; set; } Property Value Type Description Transform WorldAnchorObject The GameObject holding the WorldAnchor component. Declaration public GameObject WorldAnchorObject { get; set; } Property Value Type Description GameObject"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.WorldLockingSetup.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.WorldLockingSetup.html",
    "title": "Class WorldLockingSetup | World Locking Tools for Unity Documentation",
    "keywords": "Class WorldLockingSetup Collection of menu driven Editor only functions to automate WLT configuration. Inheritance Object WorldLockingSetup Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class WorldLockingSetup"
  },
  "README.html": {
    "href": "README.html",
    "title": "Welcome! | World Locking Tools for Unity Documentation",
    "keywords": "Welcome! World Locking Tools for Unity provides a stable and reliable world-locked coordinate system, binding the virtual/holographic world to the physical world. World Locking Tools take the burden of world-locking holograms off of the developer, as well as enabling scenarios that were previously unreachable. It currently supports the HoloLens family of devices via Unity's built-in VR support. Initial support for other platforms via Unity's new XR SDK plugin system is also available. World Locking Tools locks the entire holograph space of your application to the physical world. A hologram put in position relative to physical world features will stay fixed relative to those features, as well as remaining fixed relative to other holograms. World Locking Tools scale naturally with both the complexity and size of the scene. Large models, large collections of models, and multi-room environments are all handled gracefully. Published documentation For the most up-to-date documentation, see the World Locking Tools for Unity documentation portal . Getting started Dive into the full documentation, beginning with the organization of the documentation itself, from the Guides section . Or a quick overview of key concepts behind World Locking Tools is contained in this FAQ . Or skip straight into introduction of key concepts, leading to further details of concepts and solutions, beginning in the Concepts section . A number of samples are contained in a sibling repo, World Locking Tools Samples . Be sure to have a look there for an instructive example. And if you don't find what you are looking for there, you are encouraged to submit a suggestion or even your own sample. Easy and efficient World Locking Tools is both powerful and easy to use. Furthermore, it strives to supply only as much as a specific application requires. Any World Locking Tools feature not required by an application will incur no cost in resources or performance. See also These ideas are further explored in the conceptual guide. To complement the theoretical description, pragmatic samples are provided, along with how-to articles to walk through the steps involved in building applications using the World Locking Tools' stable and reliable coordinate system. Conceptual guide How-to articles Samples Further, reference materials for interfacing through script with World Locking Tools is included in the API Documentation . Build Status Branch CI Status Docs Status master Useful resources on Microsoft Windows Dev Center Academy Design Development Community See code examples. Do a coding tutorial. Watch guest lectures. Get design guides. Build user interface. Learn interactions and input. Get development guides. Learn the technology. Understand the science. Join open source projects. Ask questions on forums. Attend events and meetups. How to Contribute This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.microsoft.com . When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA. View the How To Contribute page for the most up to date instructions on contributing to World Locking Tools for Unity. Microsoft Open Source Code of Conduct This project has adopted the Microsoft Open Source Code of Conduct . Resources: Microsoft Open Source Code of Conduct Microsoft Code of Conduct FAQ Contact opencode@microsoft.com with questions or concerns."
  }
}